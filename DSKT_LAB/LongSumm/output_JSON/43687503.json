{
    "abstractText": "We introduce the â€œNoBackTrackâ€ algorithm to train the parameters of dynamical systems such as recurrent neural networks. This algorithm works in an online, memoryless setting, thus requiring no backpropagation through time, and is scalable, avoiding the large computational and memory cost of maintaining the full gradient of the current state with respect to the parameters. The algorithm essentially maintains, at each time, a single search direction in parameter space. The evolution of this search direction is partly stochastic and is constructed in such a way to provide, at every time, an unbiased random estimate of the gradient of the loss function with respect to the parameters. Because the gradient estimate is unbiased, on average over time the parameter is updated as it should. The resulting gradient estimate can then be fed to a lightweight Kalman-like filter to yield an improved algorithm. For recurrent neural networks, the resulting algorithms scale linearly with the number of parameters. Small-scale experiments confirm the suitability of the approach, showing that the stochastic approximation of the gradient introduced in the algorithm is not detrimental to learning. In particular, the Kalman-like version of NoBackTrack is superior to backpropagation through time (BPTT) when the time span of dependencies in the data is longer than the truncation span for BPTT. Consider the problem of training the parameters Î¸ of a dynamical system over a variable h âˆˆ Rn subjected to the evolution equation h(t + 1) = f(h(t), x(t), Î¸) (1) where f is a fixed function of h and of an input signal x(t), depending on parameters Î¸. The goal is online minimization of a loss function âˆ‘ï¸€ t lt(y(t), y(t)) between a desired output y(t) at time t and a prediction1 y(t) = Y (h(t), Ï†) (2) 1The prediction y may not live in the same set as y. Often, y encodes a probability distribution over the possible values of y, and the loss is the logarithmic loss l = âˆ’ log py(y). 1 ar X iv :1 50 7. 07 68 0v 2 [ cs .N E ] 2 0 N ov 2 01 5 computed from h(t) and additional parameters Ï†. A typical example we have in mind is a recurrent neural network, with activities ai(t) := sigm(hi(t)) and evolution equation hi(t + 1) = bi + âˆ‘ï¸€ k rkixk(t) + âˆ‘ï¸€ j Wjiaj(t), with parameter Î¸ = (bi, rki, Wji)i,j,k. If the full target sequence y(t)tâˆˆ[0;T ] is known in advance, one strategy is to use the backpropagation through time algorithm (BPTT, see e.g. [Jae02]) to compute the gradient of the total loss LT := âˆ‘ï¸€T t=0 lt with respect to the parameters Î¸ and Ï†, and use gradient descent on Î¸ and Ï†. However, if the data y(t + 1) arrive one at a time in a streaming fashion, backpropagation through time would require making a full backward computation from time t + 1 to time 0 after each new data point becomes available. This results in an Î©(t2) complexity and in the necessity to store past states, inputs, and outputs. A possible strategy is to only backtrack by a finite number of time steps [Jae02] rather than going back all the way to t = 0. But this provides biased gradient estimates and may impair detection of time dependencies with a longer range than the backtracking time range. By contrast, methods which are fully online are typically not scalable. One strategy, known as real-time recurrent learning (RTRL) in the recurrent network community,2 maintains the full gradient of the current state with respect to the parameters: G(t) := âˆ‚h(t) âˆ‚Î¸ (3) which satisfies the evolution equation G(t + 1) = âˆ‚f(h(t), x(t), Î¸) âˆ‚h G(t) + âˆ‚f(h(t), x(t), Î¸) âˆ‚Î¸ (4) (by differentiating (1)). Knowing G(t) allows to minimize the loss via a stochastic gradient descent on the parameters Î¸, namely,3 Î¸ â† Î¸ âˆ’ Î·t âˆ‚lt âˆ‚Î¸ âŠ¤ (5) with learning rate Î·t. Indeed, the latter quantity can be computed from Gt and from the way the predictions depend on h(t), via the chain rule âˆ‚lt âˆ‚Î¸ = âˆ‚lt(Y (h(t), Ï†), y(t)) âˆ‚h G(t) (6) However, the full gradient G(t) is an object of dimension dim h Ã— dim Î¸. This prevents computing or even storing G(t) for moderately largedimensional dynamical systems, such as recurrent neural networks. 2This amounts to applying forward automatic differentiation. 3We use the standard convention for Jacobian matrices, namely, âˆ‚x/âˆ‚y is the matrix with entries âˆ‚xi/âˆ‚yj . Then the chain rule writes âˆ‚x âˆ‚y âˆ‚y âˆ‚z = âˆ‚x âˆ‚z . This makes the derivatives âˆ‚lt/âˆ‚Î¸ into row vectors so that gradient descent is Î¸ â† Î¸ âˆ’ (âˆ‚lt/âˆ‚Î¸).",
    "authors": [
        {
            "affiliations": [],
            "name": "Yann Ollivier"
        },
        {
            "affiliations": [],
            "name": "Corentin Tallec"
        },
        {
            "affiliations": [],
            "name": "Guillaume Charpiat"
        }
    ],
    "id": "SP:04af117cc4a19a7e5ad3d26abe7c7f5c2bed2678",
    "references": [
        {
            "authors": [
                "Ron Begleiter",
                "Ran El-Yaniv",
                "Golan Yona"
            ],
            "title": "On prediction using variable order markov models",
            "venue": "Journal of Artificial Intelligence Research,",
            "year": 2004
        },
        {
            "authors": [
                "Olivier CappÃ©"
            ],
            "title": "Online EM algorithm for hidden Markov models",
            "venue": "J. Comput. Graph. Statist.,",
            "year": 2011
        },
        {
            "authors": [
                "Simon Haykin"
            ],
            "title": "Kalman filtering and neural networks",
            "year": 2004
        },
        {
            "authors": [
                "Herbert Jaeger"
            ],
            "title": "Tutorial on training recurrent neural networks, covering BPTT, RTRL, EKF and the â€˜â€˜echo state networkâ€™",
            "venue": "Technical Report 159,",
            "year": 2002
        },
        {
            "authors": [
                "Yann Ollivier"
            ],
            "title": "Riemannian metrics for neural networks I: feedforward networks",
            "venue": "Information and Inference,",
            "year": 2015
        },
        {
            "authors": [
                "Yann Ollivier"
            ],
            "title": "Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences",
            "venue": "Information and Inference,",
            "year": 2015
        }
    ],
    "sections": [
        {
            "text": "The algorithm essentially maintains, at each time, a single search direction in parameter space. The evolution of this search direction is partly stochastic and is constructed in such a way to provide, at every time, an unbiased random estimate of the gradient of the loss function with respect to the parameters. Because the gradient estimate is unbiased, on average over time the parameter is updated as it should.\nThe resulting gradient estimate can then be fed to a lightweight Kalman-like filter to yield an improved algorithm. For recurrent neural networks, the resulting algorithms scale linearly with the number of parameters.\nSmall-scale experiments confirm the suitability of the approach, showing that the stochastic approximation of the gradient introduced in the algorithm is not detrimental to learning. In particular, the Kalman-like version of NoBackTrack is superior to backpropagation through time (BPTT) when the time span of dependencies in the data is longer than the truncation span for BPTT.\nConsider the problem of training the parameters ğœƒ of a dynamical system over a variable â„ âˆˆ Rğ‘› subjected to the evolution equation\nâ„(ğ‘¡ + 1) = ğ‘“(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ) (1)\nwhere ğ‘“ is a fixed function of â„ and of an input signal ğ‘¥(ğ‘¡), depending on parameters ğœƒ. The goal is online minimization of a loss function âˆ‘ï¸€ ğ‘¡ â„“ğ‘¡(ğ‘¦(ğ‘¡), ğ‘¦(ğ‘¡)) between a desired output ğ‘¦(ğ‘¡) at time ğ‘¡ and a prediction1\nğ‘¦(ğ‘¡) = ğ‘Œ (â„(ğ‘¡), ğœ™) (2) 1The prediction ğ‘¦ may not live in the same set as ğ‘¦. Often, ğ‘¦ encodes a probability distribution over the possible values of ğ‘¦, and the loss is the logarithmic loss â„“ = âˆ’ log ğ‘ğ‘¦(ğ‘¦).\nar X\niv :1\n50 7.\n07 68\n0v 2\n[ cs\n.N E\n] 2\n0 N\nov 2\n01 5\ncomputed from â„(ğ‘¡) and additional parameters ğœ™. A typical example we have in mind is a recurrent neural network, with activities ğ‘ğ‘–(ğ‘¡) := sigm(â„ğ‘–(ğ‘¡)) and evolution equation â„ğ‘–(ğ‘¡ + 1) = ğ‘ğ‘– + âˆ‘ï¸€ ğ‘˜ ğ‘Ÿğ‘˜ğ‘–ğ‘¥ğ‘˜(ğ‘¡) + âˆ‘ï¸€ ğ‘— ğ‘Šğ‘—ğ‘–ğ‘ğ‘—(ğ‘¡), with parameter ğœƒ = (ğ‘ğ‘–, ğ‘Ÿğ‘˜ğ‘–, ğ‘Šğ‘—ğ‘–)ğ‘–,ğ‘—,ğ‘˜.\nIf the full target sequence ğ‘¦(ğ‘¡)ğ‘¡âˆˆ[0;ğ‘‡ ] is known in advance, one strategy is to use the backpropagation through time algorithm (BPTT, see e.g. [Jae02]) to compute the gradient of the total loss ğ¿ğ‘‡ := âˆ‘ï¸€ğ‘‡ ğ‘¡=0 â„“ğ‘¡ with respect to the parameters ğœƒ and ğœ™, and use gradient descent on ğœƒ and ğœ™. However, if the data ğ‘¦(ğ‘¡ + 1) arrive one at a time in a streaming fashion, backpropagation through time would require making a full backward computation from time ğ‘¡ + 1 to time 0 after each new data point becomes available. This results in an Î©(ğ‘¡2) complexity and in the necessity to store past states, inputs, and outputs. A possible strategy is to only backtrack by a finite number of time steps [Jae02] rather than going back all the way to ğ‘¡ = 0. But this provides biased gradient estimates and may impair detection of time dependencies with a longer range than the backtracking time range.\nBy contrast, methods which are fully online are typically not scalable. One strategy, known as real-time recurrent learning (RTRL) in the recurrent network community,2 maintains the full gradient of the current state with respect to the parameters:\nğº(ğ‘¡) := ğœ•â„(ğ‘¡) ğœ•ğœƒ\n(3)\nwhich satisfies the evolution equation\nğº(ğ‘¡ + 1) = ğœ•ğ‘“(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ) ğœ•â„ ğº(ğ‘¡) + ğœ•ğ‘“(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ) ğœ•ğœƒ\n(4)\n(by differentiating (1)). Knowing ğº(ğ‘¡) allows to minimize the loss via a stochastic gradient descent on the parameters ğœƒ, namely,3\nğœƒ â† ğœƒ âˆ’ ğœ‚ğ‘¡ ğœ•â„“ğ‘¡ ğœ•ğœƒ\nâŠ¤ (5)\nwith learning rate ğœ‚ğ‘¡. Indeed, the latter quantity can be computed from ğºğ‘¡ and from the way the predictions depend on â„(ğ‘¡), via the chain rule\nğœ•â„“ğ‘¡ ğœ•ğœƒ = ğœ•â„“ğ‘¡(ğ‘Œ (â„(ğ‘¡), ğœ™), ğ‘¦(ğ‘¡)) ğœ•â„ ğº(ğ‘¡) (6)\nHowever, the full gradient ğº(ğ‘¡) is an object of dimension dim â„ Ã— dim ğœƒ. This prevents computing or even storing ğº(ğ‘¡) for moderately largedimensional dynamical systems, such as recurrent neural networks.\n2This amounts to applying forward automatic differentiation. 3We use the standard convention for Jacobian matrices, namely, ğœ•ğ‘¥/ğœ•ğ‘¦ is the matrix\nwith entries ğœ•ğ‘¥ğ‘–/ğœ•ğ‘¦ğ‘— . Then the chain rule writes ğœ•ğ‘¥ğœ•ğ‘¦ ğœ•ğ‘¦ ğœ•ğ‘§ = ğœ•ğ‘¥ ğœ•ğ‘§ . This makes the derivatives ğœ•â„“ğ‘¡/ğœ•ğœƒ into row vectors so that gradient descent is ğœƒ â† ğœƒ âˆ’ (ğœ•â„“ğ‘¡/ğœ•ğœƒ)âŠ¤.\nAlgorithms using a Kalman filter on ğœƒ also4 rely on this derivative ğœ•â„“ğ‘¡ğœ•ğœƒ (see [Hay04, Jae02] for the case of recurrent networks). So any efficient way of estimating this derivative can be fed, in turn, to a Kalman-type algorithm.\nAlgorithms suggested to train hidden Markov models online (e.g., [Cap11], based on expectation-maximization instead of gradient descent) share the same algebraic structure and suffer from the same problem."
        },
        {
            "heading": "1 The NoBackTrack algorithm",
            "text": ""
        },
        {
            "heading": "1.1 The rank-one trick: an expectation-preserving reduction",
            "text": "We propose to build an approximation ?Ìƒ?(ğ‘¡) of ğº(ğ‘¡) with a more sustainable algorithmic cost; ?Ìƒ?(ğ‘¡) will be random with the property E?Ìƒ?(ğ‘¡) = ğº(ğ‘¡) for all ğ‘¡. Then the stochastic gradient (5) based on ?Ìƒ?(ğ‘¡) will introduce noise, but no bias, on the learning of ğœƒ: the average change in ğœƒ after a large number of time steps will reflect the true gradient direction. (This is true only if the noises on ?Ìƒ?(ğ‘¡) at different times ğ‘¡ are sufficiently decorrelated. This is the case if the dynamical system (1) is sufficiently ergodic.) Such unbiasedness does not hold, for instance, if the gradient estimate is simply projected onto the nearest small-rank or diagonal plus small-rank approximation.5\nThe construction of an unbiased ?Ìƒ? is based on the following â€œrank-one trickâ€.\nProposition 1 (Rank-one trick). Given a decomposition of a matrix ğ´ as a sum of rank-one outer products, ğ´ = âˆ‘ï¸€ ğ‘– ğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘– , and independent uniform random signs ğœ€ğ‘– âˆˆ {âˆ’1, 1}, then\nğ´ := ( âˆ‘ï¸€ ğ‘–ğœ€ğ‘–ğ‘£ğ‘–) (ï¸âˆ‘ï¸€ ğ‘—ğœ€ğ‘—ğ‘¤ğ‘— )ï¸âŠ¤\n(7)\nsatisfies Eğ´ = âˆ‘ï¸ ğ‘– ğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘– = ğ´ (8)\nthat is, ğ´ is an expectation-preserving rank-one approximation of ğ´. Moreover, one can minimize the variance of ğ´ by taking advantage of additional degrees of freedom in this decomposition, namely, one may first replace ğ‘£ğ‘– and ğ‘¤ğ‘– with ğœŒğ‘–ğ‘£ğ‘– and ğ‘¤ğ‘–/ğœŒğ‘– for any ğœŒğ‘– âˆˆ R*. The choice of ğœŒğ‘– which yields minimal variance of ğ´ is when the norms of ğ‘£ğ‘– and ğ‘¤ğ‘– become equal, namely, ğœŒğ‘– = âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘£ğ‘–â€–.\n4One may use Kalman filtering either on ğœƒ alone or on the pair (ğœƒ, â„). In the first case, ğœ•â„“ğ‘¡ ğœ•ğœƒ\nis explicitly needed. In the second case, all the information about how ğœƒ influences the current state â„(ğ‘¡) is contained in the covariance between ğœƒ and â„, which the algorithm must maintain, and which is as costly as maintaining ğº(ğ‘¡) above.\n5We tried such methods first, with less satisfying results. In practice, consecutive projections tend to interact badly and reduce too much the older contributions to the gradient.\nThe proof of the first statement is immediate. The statement about minimizing variance is proven in Appendix A. Minimizing variance thanks to ğœŒğ‘– is quite important in practice, see Section 1.3. The rank-one trick also extends to tensors of arbitrary order; this may be useful in more complex situations.6 The rank-one reduction ğ´ depends, not only on the value of ğ´, but also on the way ğ´ is decomposed as a sum of rank-one terms. In the applications to recurrent networks below, there is a natural such choice.7\nWe use this reduction operation at each step of the dynamical system, to build an approximation ?Ìƒ? of ğº. A key property is that the evolution equation (4) satisfied by ğº is affine, so that if ?Ìƒ?(ğ‘¡) is an unbiased estimate of ğº(ğ‘¡), then ğœ•ğ‘“(â„(ğ‘¡),ğ‘¥(ğ‘¡),ğœƒ)ğœ•â„ ?Ìƒ?(ğ‘¡) + ğœ•ğ‘“(â„(ğ‘¡),ğ‘¥(ğ‘¡),ğœƒ) ğœ•ğœƒ is an unbiased estimate of ğº(ğ‘¡ + 1).\nThis leads to the NoBackTrack algorithm (Euclidean version) described in Algorithm 1. At each step, this algorithm maintains an approximation of ğº as\n?Ìƒ? = ğ‘£?Ì„?âŠ¤+ âˆ‘ï¸\nğ‘–\nğ‘’ğ‘–ğ‘¤ âŠ¤ ğ‘– (9)\nwhere ğ‘’ğ‘– is the ğ‘–-th basis vector in space â„, and ğ‘¤ğ‘– := ğœ•ğ‘“ğ‘–ğœ•ğœƒ âŠ¤ are sparse vectors.\nTo understand this structure, say that ?Ìƒ?(ğ‘¡ âˆ’ 1) = ğ‘£?Ì„?âŠ¤ is a rank-one unbiased approximation of ğº(ğ‘¡âˆ’ 1). Then the evolution equation (4) for ğº yields (ï¸ ğœ•ğ‘“ ğœ•â„ )ï¸ (ï¸ ğ‘£?Ì„?âŠ¤ )ï¸ + ğœ•ğ‘“ğœ•ğœƒ = (ï¸ ğœ•ğ‘“ ğœ•â„ğ‘£ )ï¸ ?Ì„?âŠ¤+ âˆ‘ï¸€ ğ‘– ğ‘’ğ‘– ğœ•ğ‘“ğ‘– ğœ•ğœƒ as an approximation of ?Ìƒ?(ğ‘¡). This new approximation is not rank-one any more, but it can be used to perform a gradient step on ğœƒ, and then reduced to a rank-one approximation before the next time step.\nNote that handling ğœ•ğ‘“ğ‘–ğœ•ğœƒ is usually cheap: in many situations, only a small subset of the parameter ğœƒ directly influences each component â„ğ‘–(ğ‘¡ + 1) given â„(ğ‘¡), so that for each component ğ‘– of the state space, ğœ•ğ‘“ğ‘–ğœ•ğœƒ has few non-zero components. For instance, for a recurrent neural network with activities\n6The most symmetric way to do this is to use complex roots of unity, for instance, âˆ‘ï¸€\nğ‘– ğ‘¢ğ‘–âŠ— ğ‘£ğ‘– âŠ— ğ‘¤ğ‘– = ERe (ï¸ ( âˆ‘ï¸€\nğ‘– ğœğ‘–ğ‘¢ğ‘–)( âˆ‘ï¸€ ğ‘— ğœğ‘—ğ‘£ğ‘—)( âˆ‘ï¸€ ğ‘˜ ğœğ‘˜ğ‘¤ğ‘˜) )ï¸ where each ğœğ‘– is taken independently at\nrandom among {1, eÂ±2ğ‘–ğœ‹/3}. This involves complex numbers but there is no need to complexify the original dynamical system (1). Another, complex-free possibility is to apply the rank-one trick recursively to tensors of smaller order, for instance, âˆ‘ï¸€ ğ‘– ğ‘¢ğ‘–âŠ—ğ‘£ğ‘–âŠ—ğ‘¤ğ‘–âŠ—ğ‘¥ğ‘– =âˆ‘ï¸€\nğ‘– (ğ‘¢ğ‘– âŠ— ğ‘£ğ‘–)âŠ— (ğ‘¤ğ‘– âŠ— ğ‘¥ğ‘–) = E\n[ï¸ ( âˆ‘ï¸€\nğ‘– ğœ€ğ‘–ğ‘¢ğ‘– âŠ— ğ‘£ğ‘–)( âˆ‘ï¸€ ğ‘— ğœ€ğ‘—ğ‘¤ğ‘— âŠ— ğ‘¥ğ‘—) ]ï¸\nand then apply independent rank-one decompositions in turn to âˆ‘ï¸€ ğ‘– ğœ€ğ‘–ğ‘¢ğ‘– âŠ— ğ‘£ğ‘– and to âˆ‘ï¸€ ğ‘—\nğœ€ğ‘—ğ‘¤ğ‘— âŠ— ğ‘¥ğ‘— . 7The rank-one trick may also be performed using random Gaussian vectors, namely ğ´ = E[ğœ‰(ğœ‰âŠ¤Î£âˆ’1ğ´)] with ğœ‰ = ğ’© (0, Î£). This version does not depend on a chosen decomposition of ğ´, but depends on a choice of Î£. Variance can be much larger in this case: for instance, if ğ´ = ğ‘£ğ‘¤âŠ¤ is actually rank-one, then (ğœ€ğ‘£)(ğœ€ğ‘¤âŠ¤) = ğ‘£ğ‘¤âŠ¤ so that the rank-one trick with random signs is exact, whereas the Gaussian version yields (ğœ‰ğœ‰âŠ¤Î£âˆ’1)ğ‘£ğ‘¤âŠ¤ which is correct only in expectation. This case is particularly relevant because we are going to apply a reduction at each time step, thus working on objects that stay close to rank-one. The generalization to tensors is also more cumbersome in the Gaussian case.\nğ‘ğ‘–(ğ‘¡) := sigm(â„ğ‘–(ğ‘¡)) and evolution equation â„ğ‘–(ğ‘¡ + 1) = ğ‘ğ‘– + âˆ‘ï¸€\nğ‘˜ ğ‘Ÿğ‘–ğ‘˜ğ‘¥ğ‘˜(ğ‘¡) +âˆ‘ï¸€ ğ‘— ğ‘Šğ‘—ğ‘–ğ‘ğ‘—(ğ‘¡), the derivative of â„ğ‘–(ğ‘¡ + 1) with respect to the parameter ğœƒ = (ğ‘, ğ‘Ÿ, ğ‘Š ) only involves the parameters ğ‘ğ‘–, ğ‘Ÿğ‘–ğ‘˜, ğ‘Šğ‘—ğ‘– of unit ğ‘–. In such situations, the total cost of computing and storing all the ğ‘¤ğ‘–â€™s is of the same order as the cost of computing â„(ğ‘¡ + 1) itself. See Section 1.3 for details on this example.\nAfter the reduction step of Algorithm 1, ?Ì„? may be interpreted as a â€œsearch directionâ€ in parameter space ğœƒ, while ğ‘£ is an estimate of the effect on the current state â„(ğ‘¡) of changing ğœƒ in the direction ?Ì„?. The search direction ?Ì„? evolves stochastically, but not fully at random, over time, so that on average ğ‘£?Ì„?âŠ¤ is a fair estimate of the actual influence of the parameter ğœƒ.\nNote that in Algorithm 1, the non-recurrent output parameters ğœ™ are trained according to their exact gradient. The rank-one trick is used only for the recurrent part of the system.\nBy construction, at each step of Algorithm 1, the quantity ?Ìƒ?ğ‘¡ := ğ‘£?Ì„?âŠ¤+âˆ‘ï¸€ ğ‘– ğ‘’ğ‘–ğ‘¤ âŠ¤ ğ‘– satisfies E?Ìƒ?ğ‘¡ = ğœ•â„(ğ‘¡) ğœ•ğœƒ . However, since the value of ğœƒ changes along the algorithm, we must be careful about the meaning of this statement. Intuitively, this derivative with respect to ğœƒ is taken along the actual trajectory of parameters ğœƒğ‘¡ realized by the algorithm.\nMore formally, let ğœƒ = (ğœƒ0, . . . , ğœƒğ‘¡, . . .) be any sequence of parameters. Let ğ‘“ be any function depending on this sequence ğœƒ, such as the state of the system at time ğ‘¡ (all functions considered below will depend only on a finite initial segment of ğœƒ). Define ğœƒ + ğœ€ := (ğœƒ0 + ğœ€, . . . , ğœƒğ‘¡ + ğœ€, . . .) and say that ğ‘“ has derivative ğœ•ğ‘“ğœ•ğœƒ with respect to ğœƒ if ğ‘“(ğœƒ + ğœ€) = ğ‘“(ğœƒ) + ğœ€ ğœ•ğ‘“ ğœ•ğœƒ + ğ‘‚(ğœ€\n2) for small ğœ€.\nThanks to this convention, the evolution equation (4) for the evolution of ğº(ğ‘¡) holds for any sequence of parameters ğœƒ, with ğº(ğ‘¡) defined as ğœ•â„(ğ‘¡)ğœ•ğœƒ . The following statement is then easily proved by induction.\nProposition 2 (Unbiased rank-one gradient estimate for dynamical systems). At each time step ğ‘¡, the quantity ?Ìƒ?ğ‘¡ := ğ‘£?Ì„?âŠ¤ +âˆ‘ï¸€\nğ‘– ğ‘’ğ‘–ğ‘¤ âŠ¤ ğ‘– from Algorithm 1 is an unbiased estimate of the gradient of the state\nof the system with respect to the parameter:\nE?Ìƒ?ğ‘¡ = ğœ•â„(ğ‘¡)\nğœ•ğœƒ (19)\nwhere ğœƒ is the sequence of parameters produced by the algorithm.\nIn particular, for learning rates ğœ‚ tending to 0, the parameter evolves slowly so that the derivative ğœ•â„(ğ‘¡)ğœ•ğœƒ is close to a derivative with respect to the current value ğœƒğ‘¡ of the parameter. Thus, in this regime, ğœ•â„(ğ‘¡)ğœ•ğœƒ tends to ğœ•â„(ğ‘¡) ğœ•ğœƒğ‘¡\n, and since ?Ìƒ?ğ‘¡ is an unbiased estimate of ğºğ‘¡, the situation gets closer and closer to an ordinary stochastic gradient descent if ğœ‚ is small. Presumably\nParameters: â„(0) (initial state), ğœƒ0, ğœ™0 (initial value of the internal and output parameters), ğœ‚ğ‘¡ (learning rate scheme); Data: ğ‘¥(ğ‘¡) (input signal), ğ‘¦(ğ‘¡) (output signal); Maintains: â„(ğ‘¡) (current state), ğœƒ, ğœ™ (internal and output parameters), ğ‘£ (column vector of size dim â„), ?Ì„? (column vector of size dim ğœƒ), ğ‘¤ğ‘– (sparse column vectors of size dim ğœƒ) for ğ‘– = 1, . . . , dim â„. Initialization: ğœƒ â† ğœƒ0, ğœ™â† ğœ™0, ğ‘£ â† 0, ?Ì„? â† 0, ğ‘¤ğ‘– â† 0; for ğ‘¡ = 0 to end-of-time do\nObservation step: Compute prediction ğ‘¦(ğ‘¡) = ğ‘Œ (â„(ğ‘¡), ğœ™) from current state â„(ğ‘¡). Observe ğ‘¦(ğ‘¡) and incur loss â„“ğ‘¡(ğ‘¦(ğ‘¡), ğ‘¦(ğ‘¡)). Update step: Compute derivative of loss with respect to output parameters, ğœ•â„“ğ‘¡ğœ•ğœ™ = ğœ•â„“ğ‘¡(ğ‘Œ (â„(ğ‘¡),ğœ™),ğ‘¦(ğ‘¡)) ğœ•ğœ™ , and update output parameters:\nğœ™â† ğœ™âˆ’ ğœ‚ğ‘¡ ğœ•â„“ğ‘¡ ğœ•ğœ™\nâŠ¤ (10)\nCompute derivative of loss with respect to current state,\nğ» â† ğœ•â„“ğ‘¡ (ğ‘Œ (â„(ğ‘¡), ğœ™), ğ‘¦(ğ‘¡)) ğœ•â„\n(11)\nUpdate internal parameters ğœƒ:\nğœƒ â† ğœƒ âˆ’ ğœ‚ğ‘¡ (ğ»ğ‘£)?Ì„? âˆ’ ğœ‚ğ‘¡ âˆ‘ï¸€ ğ‘–ğ»ğ‘–ğ‘¤ğ‘– (12)\n(this is a gradient step ğœƒ â† ğœƒ âˆ’ ğœ‚ğ‘¡(ğ»?Ìƒ?)âŠ¤ using the current gradient estimate ?Ìƒ? from (9)). Reduction step: Draw independent uniform random signs ğœ€ğ‘– = Â±1. Let ğ‘’ğ‘– be the ğ‘–-th basis vector in state space. Compute ğœŒ := âˆšï¸€ â€–?Ì„?â€– / â€–ğ‘£â€– and ğœŒğ‘– := âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘’ğ‘–â€– for each ğ‘–. Update\nğ‘£ â† ğœŒğ‘£ + âˆ‘ï¸€\nğ‘–ğœ€ğ‘–ğœŒğ‘–ğ‘’ğ‘– (13) ?Ì„? â† ?Ì„?/ğœŒ + âˆ‘ï¸€ ğ‘–ğœ€ğ‘–ğ‘¤ğ‘–/ğœŒğ‘– (14) ğ‘¤ğ‘– â† 0 (15)\nTransition step: Observe new value of input signal ğ‘¥(ğ‘¡) and compute next state â„(ğ‘¡ + 1) = ğ‘“(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ). Update estimate ?Ìƒ?:\nğ‘£ â† ğœ•ğ‘“(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ) ğœ•â„ ğ‘£ (16)\nğ‘¤ğ‘– â† ğœ•ğ‘“ğ‘–(â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ)\nğœ•ğœƒ\nâŠ¤ (17)\nğ‘¡â† ğ‘¡ + 1 (18)\nend Algorithm 1: NoBackTrack algorithm, Euclidean version.\nthis happens whenever the learning rate is small enough for ğœƒ not to change too much within a time range corresponding to a â€œforgetting timeâ€ of the dynamical system, although more work is needed here.\n1.2 Feeding the gradient estimate to an extended Kalman filter\nThe Euclidean version of the NoBackTrack algorithm presented in Algorithm 1 is not enough to obtain good performance fast. Online estimation often yields best results when using filters from the Kalman family. We refer to [Hay04, Jae02] for a discussion of Kalman filtering applied to recurrent neural networks.\nKalman-based approaches rely on a covariance matrix estimate ğ‘ƒ (ğ‘¡) on ğœƒ. After observing ğ‘¦(ğ‘¡), the parameter ğœƒ gets adjusted via8\nğœƒ â† ğœƒ âˆ’ ğ‘ƒ (ğ‘¡)ğœ•â„“ğ‘¡ ğœ•ğœƒ\nâŠ¤ (20)\nwhere the derivative of the loss with respect to ğœƒ is computed, as above, via the product of the derivative of the loss with respect to the current state â„(ğ‘¡), and the derivative ğº(ğ‘¡) = ğœ•â„(ğ‘¡)ğœ•ğœƒ .\nMaintaining a full covariance matrix on ğœƒ is usually too costly. However, having a good approximation of ğ‘ƒ (ğ‘¡) is not as critical as having a good approximation of ğœ•â„“ğ‘¡ğœ•ğœƒ . Indeed, given an unbiased approximation of ğœ•â„“ğ‘¡ ğœ•ğœƒ , any symmetric positive definite matrix ğ‘ƒ (ğ‘¡) which changes slowly enough in time will yield an unbiased trajectory for ğœƒ.\nThus, we will use more aggressive matrix reduction techniques on ğ‘ƒ (ğ‘¡), such as block-diagonal (as in [Hay04]) or quasi-diagonal [Oll15a] approximations. In our setting, the main point of using the covariance matrix is to get both a sensible scaling of the learning rate for each component of ğœƒ, and reparametrization-invariance properties [Oll15a].\nIn Kalman filtering, in the case when the â€œtrueâ€ underlying parameter ğœƒ in the extended Kalman filter is constant, it is better to work with the inverse covariance matrix ğ½(ğ‘¡) := ğ‘ƒ (ğ‘¡)âˆ’1, and the extended Kalman filter on ğœƒ can be rewritten as\nğ½(ğ‘¡)â† ğ½(ğ‘¡âˆ’ 1) + ğœ•ğ‘¦ğ‘¡ ğœ•ğœƒ\nâŠ¤ ğ¼ğ‘¡\nğœ•ğ‘¦ğ‘¡ ğœ•ğœƒ\n(21)\nğœƒ â† ğœƒ âˆ’ ğ½(ğ‘¡)âˆ’1 ğœ•â„“ğ‘¡ ğœ•ğœƒ\nâŠ¤ (22)\nwhere ğ‘¦ğ‘¡ is the prediction at time ğ‘¡, where both ğœ•ğ‘¦ğ‘¡ğœ•ğœƒ and ğœ•â„“ğ‘¡ ğœ•ğœƒ can be computed from â„(ğ‘¡) via the chain rule if ğº(ğ‘¡) = ğœ•â„(ğ‘¡)ğœ•ğœƒ is known, and where ğ¼ğ‘¡ is the 8Indeed, in standard Kalman filter notation, one has ğ¾ğ‘¡ğ‘… = ğ‘ƒğ‘¡ğ»âŠ¤ğ‘¡ , so that for the quadratic loss â„“ = 12 (ğ‘¦ âˆ’ ğ‘¦) âŠ¤ğ‘…âˆ’1(ğ‘¦ âˆ’ ğ‘¦) (log-loss of a Gaussian model with coraviance matrix ğ‘…), the Kalman update for ğœƒ is equivalent to ğœƒ â† ğœƒ âˆ’ ğ‘ƒ (ğ‘¡) ğœ•â„“ğ‘¡ ğœ•ğœƒ âŠ¤.\nFisher information matrix of ğ‘¦ğ‘¡ as a probability distribution on ğ‘¦ğ‘¡. (For exponential families this is just the Hessian âˆ’ğœ•2â„“ğ‘¡\nğœ•ğ‘¦2ğ‘¡ of the loss with respect\nto the prediction). This is the so-called information filter, because ğ½(ğ‘¡) approximates the Fisher information matrix on ğœƒ given the observations up to time ğ‘¡. This is basically a natural gradient descent on ğœƒ.\nThis approach is summarized in Algorithm 2, which we describe more loosely since matrix approximation schemes may depend on the application.\nAlgorithm 2 uses a decay factor (1âˆ’ğ›¾ğ‘¡) on the inverse covariance matrices to limit the influence of old computations made with outdated values of ğœƒ. The factor ğ›¾ğ‘¡ also controls the effective learning rate of the algorithm, since, in line with Kalman filtering, we have not included a learning rate for the update of ğœƒ (namely, ğœ‚ğ‘¡ = 1): the step size is adapted via the magnitude of ğ½ . For ğ›¾ğ‘¡ = 0, ğ½ grows linearly so that step size is ğ‘‚(1/ğ‘¡).\nMoreover, we have included a regularization term Î› for matrix inversion; in the Bayesian interpretation of Kalman filtering this corresponds to having a Gaussian prior on the parameters with inverse covariance matrix Î›. This is important to avoid fast divergence in the very first steps.\nIn practice we have used ğ›¾ğ‘¡ = ğ‘‚(1/ âˆš\nğ‘¡) and Î› = (dim â„). Id. The simplest and fastest way to approximate the Fisher matrix in Algorithm 2 is the outer product approximation (see discussion in [Oll15a]), which we have used in the experiments below. Namely, we simply use ğ¼ğ‘¡ â† ğœ•â„“ğ‘¡ğœ•ğ‘¦ğ‘¡ âŠ¤ğœ•â„“ğ‘¡ ğœ•ğ‘¦ğ‘¡ so that the updates to ğ½ğœ™ and ğ½ğœƒ simplify and become rank-one outer product updates using the gradient of the loss, namely, ğ½ğœƒ â† (1âˆ’ ğ›¾ğ‘¡)ğ½ğœƒ + ğœ•â„“ğ‘¡ğœ•ğœƒ âŠ¤ğœ•â„“ğ‘¡ ğœ•ğœƒ and likewise for ğœ™. Here the derivative ğœ•â„“ğ‘¡ğœ•ğœƒ is estimated from the current gradient estimate ?Ìƒ?.\nFor the matrix reductions, we have used a block-wise quasi-diagonal reduction as in [Oll15a]. This makes the cost of handling the various matrices linear in the number of parameters."
        },
        {
            "heading": "1.3 Examples",
            "text": "Let us show how Algorithm 1 works out on explicit examples.\nThe importance of norm rescaling. Let us first consider a simple dynamical system which illustrates the importance of rescaling the norms by ğœŒ and ğœŒğ‘–. Let 0 < ğ›¼ < 1 and consider the system\nâ„(ğ‘¡ + 1) = (1âˆ’ ğ›¼)â„(ğ‘¡) + ğœƒ (28)\nwith both â„ and ğœƒ in Rğ‘›. This quickly converges towards ğœƒ/ğ›¼. We have ğœ•ğ‘“/ğœ•â„ = (1 âˆ’ ğ›¼) Id and ğœ•ğ‘“/ğœ•ğœƒ = Id and so ğœ•ğ‘“ğ‘–/ğœ•ğœƒâŠ¤ = ğ‘’ğ‘–, the ğ‘–-th basis vector. Then the reduction and transition steps in Algorithm 1, if the scalings\nParameters: â„(0) (initial state), ğœƒ0, ğœ™0 (initial value of the parameters), 0 6 ğ›¾ğ‘¡ < 1 (covariance decay parameter scheme), Î›ğœ™ and Î›ğœƒ (inverse covariance matrix of the prior on the parameters); Maintains: Same as Algorithm 1, plus a representation of matrices ğ½ğœƒ and ğ½ğœ™ allowing for efficient inversion; Subroutines: A matrix reduction method MatrixReduce(ğ‘€) which only evaluates a small number of entries of its argument ğ‘€ and returns an approximation of ğ‘€ that can be inverted efficiently; A routine FisherApprox(ğ‘¦ğ‘¡, ğ‘¦ğ‘¡) which returns either a positive definite approximation of the Fisher information matrix of ğ‘¦ğ‘¡ as a probability distribution on ğ‘¦ğ‘¡, or a positive definite approximation of the Hessian âˆ’ğœ•2â„“ğ‘¡\nğœ•ğ‘¦2ğ‘¡ of the loss with respect to the prediction.\nInitialization: as in Algorithm 1, and ğ½ğœƒ â† 0, ğ½ğœ™ â† 0; for ğ‘¡ = 0 to end-of-time do\nObservation step: as in Algorithm 1. Update step: Compute approximate Fisher information matrix w.r.t. ğ‘¦ğ‘¡:\nğ¼ğ‘¡ â† FisherApprox(ğ‘¦ğ‘¡, ğ‘¦ğ‘¡) (23)\nCompute derivative of prediction and of loss with respect to output parameters, ğœ•ğ‘¦ğ‘¡ğœ•ğœ™ and ğœ•â„“ğ‘¡ ğœ•ğœ™ . Update inverse covariance matrix of output parameters ğœ™:\nğ½ğœ™ â† (1âˆ’ ğ›¾ğ‘¡)ğ½ğœ™ + MatrixReduce (ï¸ƒ\nğœ•ğ‘¦ğ‘¡ ğœ•ğœ™\nâŠ¤ ğ¼ğ‘¡\nğœ•ğ‘¦ğ‘¡ ğœ•ğœ™\n)ï¸ƒ (24)\nand update output parameters:\nğœ™â† ğœ™âˆ’ (ğ½ğœ™ + Î›ğœ™)âˆ’1 ğœ•â„“ğ‘¡ ğœ•ğœ™\nâŠ¤ (25)\nCompute derivative ğœ•ğ‘¦ğ‘¡ğœ•â„ of prediction with respect to current state â„(ğ‘¡). Update inverse covariance matrix of internal parameters ğœƒ:\nğ½ğœƒ â† (1âˆ’ ğ›¾ğ‘¡)ğ½ğœƒ + MatrixReduce (ï¸ƒ\n?Ìƒ?âŠ¤ ğœ•ğ‘¦ğ‘¡ ğœ•â„\nâŠ¤ ğ¼ğ‘¡\nğœ•ğ‘¦ğ‘¡ ğœ•â„ ?Ìƒ?\n)ï¸ƒ (26)\nand update internal parameters ğœƒ:\nğœƒ â† ğœƒ âˆ’ (ğ½ğœƒ + Î›ğœƒ)âˆ’1ğ›¿ğœƒ (27)\nwhere ğ›¿ğœƒ := (ğ»ğ‘£)?Ì„? âˆ’ âˆ‘ï¸€\nğ‘–ğ»ğ‘–ğ‘¤ğ‘– is the update of ğœƒ from Algorithm 1. Reduction step: Same as in Algorithm 1, but the norms used to compute ğœŒ and ğœŒğ‘– are derived from ğ½âˆ’1ğœƒ (cf. Appendix B). Transition step: Same as in Algorithm 1.\nend Algorithm 2: NoBackTrack algorithm, Kalman version.\nğœŒ are not used, amount to\nğ‘£ğ‘¡+1 = (1âˆ’ ğ›¼) (ğ‘£ğ‘¡ + âˆ‘ï¸€\nğ‘–ğœ€ğ‘–(ğ‘¡)ğ‘’ğ‘–) (29) ?Ì„?ğ‘¡+1 = ?Ì„?ğ‘¡ + âˆ‘ï¸€ ğ‘–ğœ€ğ‘–(ğ‘¡)ğ‘’ğ‘– (30)\nwith the ğœ€ğ‘–(ğ‘¡) independent at each step ğ‘¡. The resulting estimate of ğœ•â„(ğ‘¡)/ğœ•ğœƒ is unbiased, but its variance grows linearly with time. Indeed, the dynamics of ğ‘£ğ‘¡ is stationary thanks to the factor (1 âˆ’ ğ›¼), but the dynamics of ?Ì„?ğ‘¡ is purely additive so that ğ‘¤ğ‘¡ is just a ğ‘‘-dimensional random walk. On the other hand, if rescaling by ğœŒ is used, then both ğ‘£ and ?Ì„? get rescaled by âˆš 1âˆ’ ğ›¼ at each step,9 so that their dynamics becomes stationary and variance does not grow.\nRecurrent neural networks. The next example is a standard recurrent neural network (RNN). The state of the system is the set of pre-activation values â„ğ‘–(ğ‘¡), and the activities are ğ‘ğ‘–(ğ‘¡) := ğœ(â„ğ‘–(ğ‘¡)) where ğœ is some activation function such as tanh or sigmoid. The recurrent dynamics of â„ is\nâ„ğ‘–(ğ‘¡ + 1) = âˆ‘ï¸ ğ‘—â†’ğ‘– ğ‘Šğ‘—ğ‘– ğœ(â„ğ‘—(ğ‘¡)) + âˆ‘ï¸ ğ‘™ ğ‘Ÿğ‘™ğ‘–ğ‘¥ğ‘™(ğ‘¡) (31)\nin which â„(ğ‘¡), â„(ğ‘¡+1) âˆˆ Rğ‘›, (ğ‘Šğ‘—ğ‘–)ğ‘—â†’ğ‘– are a set of weights defining a graph on ğ‘› nodes, and (ğ‘Ÿğ‘™ğ‘–)(ğ‘–,ğ‘™) are the input weights.10 The parameter is ğœƒ = (ğ‘Š, ğ‘Ÿ). We hereby omit the output part of the network,11 as it is of no use to analyze the estimation of ğœ•â„(ğ‘¡)/ğœ•ğœƒ.\n(We have chosen the pre-activation values â„, rather than the activities ğ‘ = ğœ(â„), as the state of the system. This results in simpler expressions, especially for the input weights ğ‘Ÿ.)\nThus, the function ğ‘“ defining the dynamical system for the variable â„ is (31). The derivatives of ğ‘“ are immediately computed as ğœ•ğ‘“ğ‘–/ğœ•ğ‘Šğ‘—ğ‘– = ğœ(â„ğ‘—), ğœ•ğ‘“ğ‘–/ğœ•ğ‘Ÿğ‘™ğ‘– = ğ‘¥ğ‘™, ğœ•ğ‘“ğ‘–/ğœ•â„ğ‘— = ğ‘Šğ‘—ğ‘– ğœâ€²(â„ğ‘—), and all other derivatives are 0.\nAlgorithm 1 maintains, after the reduction step, an approximation ğœ•â„(ğ‘¡)ğœ•ğœƒ â‰ˆ ğ‘£(ğ‘¡)?Ì„?(ğ‘¡)âŠ¤. We can decompose ?Ì„?(ğ‘¡) = (?Ì„? (ğ‘¡), ğ‘Ÿ(ğ‘¡)) into the components corresponding to the internal and input weights of the parameter ğœƒ = (ğ‘Š, ğ‘Ÿ), so that\nğœ•â„ğ‘–(ğ‘¡) ğœ•ğ‘Šğ‘˜ğ‘— â‰ˆ ğ‘£ğ‘–(ğ‘¡)?Ì„?ğ‘˜ğ‘—(ğ‘¡) (32) ğœ•â„ğ‘–(ğ‘¡) ğœ•ğ‘Ÿğ‘™ğ‘— â‰ˆ ğ‘£ğ‘–(ğ‘¡)ğ‘Ÿğ‘™ğ‘—(ğ‘¡). (33)\n9Proof: By induction one has ğ‘£ = ?Ì„? after the reduction step and ğ‘£ = (1âˆ’ ğ›¼)?Ì„? after the transition step, and ğœŒ = 1/ âˆš 1âˆ’ ğ›¼.\n10Biases are omitted; they can be treated by the inclusion of an always-activated united ğ‘–0 with ğ‘ğ‘–0 (ğ‘¡) â‰¡ 1.\n11The experiments below use a softmax output with output parameters ğœ™, see Section 2.\nBy plugging the values of the partial derivatives of ğ‘“ into Algorithm 1, we find the following update equations for the value of ğ‘£, ?Ì„? and ğ‘Ÿ right after the reduction step:\nğ‘£ğ‘–(ğ‘¡ + 1) = ğœŒ âˆ‘ï¸ ğ‘—â†’ğ‘– ğ‘Šğ‘—ğ‘– ğœ â€²(â„ğ‘—(ğ‘¡)) ğ‘£ğ‘—(ğ‘¡) + ğœ€ğ‘–ğœŒğ‘– (34)\n?Ì„?ğ‘˜ğ‘—(ğ‘¡ + 0) = ?Ì„?ğ‘˜ğ‘—(ğ‘¡)\nğœŒ + ğœ€ğ‘— ğœ(â„ğ‘˜(ğ‘¡)) ğœŒğ‘—\n(35)\nğ‘Ÿğ‘™ğ‘—(ğ‘¡ + 1) = ğ‘Ÿğ‘™ğ‘—(ğ‘¡)\nğœŒ + ğœ€ğ‘— ğ‘¥ğ‘™(ğ‘¡) ğœŒğ‘—\n(36)\nwhere the ğœ€ğ‘— are independent symmetric binary random variables, taking values Â±1 with probability 12 . Any non-zero choice of ğœŒğ‘— leads to an unbiased estimation, though the values are to be optimized as mentioned above.\nApplying this update has the same algorithmic cost as implementing one step (31) of the recurrent network itself.\nLeaky recurrent neural networks. To capture long-term dependencies, in the experiments below we also use a leaky RNN, obtained via the addition of a direct feedback term:\nâ„ğ‘–(ğ‘¡ + 1) = ğ›¼ğ‘–â„ğ‘–(ğ‘¡) + âˆ‘ï¸\nğ‘™\nğ‘Ÿğ‘™ğ‘–ğ‘¥ğ‘™(ğ‘¡) + âˆ‘ï¸\nğ‘—\nğ‘Šğ‘—ğ‘–ğ‘ğ‘—(ğ‘¡) ğ‘ğ‘—(ğ‘¡) := ğœ(â„ğ‘—(ğ‘¡)) (37)\nwith ğ›¼ğ‘– âˆˆ [0; 1] for all ğ‘–. (See [Jae02] for similar models.) This feedback term reduces the impact of the vanishing gradient issue and keeps a longer memory of past inputs.\nThis only changes the derivative of ğ‘“ğ‘– with respect to â„ğ‘— , which becomes ğœ•ğ‘“ğ‘–/ğœ•â„ğ‘— = ğ‘Šğ‘—ğ‘–ğœâ€²(â„ğ‘—) + ğ›¼ğ‘–ğ›¿ğ‘–ğ‘— . Consequently the update rules (35)â€“(36) for ?Ì„? and ğ‘Ÿ are unchanged, while the update of ğ‘£ becomes\nğ‘£ğ‘–(ğ‘¡ + 1) = ğœŒğ›¼ğ‘–ğ‘£ğ‘–(ğ‘¡) + ğœŒ âˆ‘ï¸ ğ‘—â†’ğ‘– ğ‘Šğ‘—ğ‘– ğœ â€²(â„ğ‘—(ğ‘¡)) ğ‘£ğ‘—(ğ‘¡) + ğœ€ğ‘–ğœŒğ‘– (38)\nMultilayer recurrent neural networks. Let us now treat the case of a multilayer recurrent neural network with dynamics\nâ„(1)(ğ‘¡ + 1) = ğ‘“ (1)(ğ‘¥(ğ‘¡), â„(1)(ğ‘¡), ğœƒ1) (39) â„(2)(ğ‘¡ + 1) = ğ‘“ (2)(ğ‘¥(ğ‘¡), â„(1)(ğ‘¡ + 1), â„(2)(ğ‘¡), ğœƒ2) (40) ... (41) â„(ğ‘›)(ğ‘¡ + 1) = ğ‘“ (ğ‘›)(ğ‘¥(ğ‘¡), â„(ğ‘›âˆ’1)(ğ‘¡ + 1), â„(ğ‘›)(ğ‘¡), ğœƒğ‘›) (42)\nwhere each layer â„(ğ‘–) and ğ‘“ (ğ‘–) define an RNN as in (31) above. Directly applying the rank-one approximation to the function ğ‘“ = (ğ‘“ (1), ğ‘“ (2), . . . , ğ‘“ (ğ‘›))\nwould be cumbersome: since the activity of a neuron of the ğ‘–-th layer at time ğ‘¡ + 1 depends on all parameters from the previous ğ‘–âˆ’ 1 layers, the derivative ğœ•ğ‘“/ğœ•ğœƒ is not sparse.\nTo cope with this, a natural approach is to treat the dynamics in a â€œrollingâ€ fashion and apply the rank-one approximation at each layer in turn. Formally, this amounts to defining the following model\nâ„Ìƒ(1)(ğ‘›ğ‘¡ + 1) = ğ‘“ (1)(?Ìƒ?(ğ‘›ğ‘¡), â„Ìƒ(1)(ğ‘›ğ‘¡), ğœƒ1) (43) â„Ìƒ(2)(ğ‘›ğ‘¡ + 2) = ğ‘“ (2)(?Ìƒ?(ğ‘›ğ‘¡ + 1), â„Ìƒ(2)(ğ‘›ğ‘¡ + 1), ğœƒ2) (44) ... (45) â„Ìƒ(ğ‘›)(ğ‘›ğ‘¡ + ğ‘›) = ğ‘“ (ğ‘›)(?Ìƒ?(ğ‘›ğ‘¡ + ğ‘›âˆ’ 1), â„Ìƒ(ğ‘›)(ğ‘›ğ‘¡ + ğ‘›âˆ’ 1), ğœƒğ‘›) (46)\nwith ?Ìƒ?(ğ‘¡) := ğ‘¥(âŒŠğ‘¡/ğ‘›âŒ‹), and where states not explicitly appearing in these equations stay unchanged (â„(ğ‘–)(ğ‘›ğ‘¡ + ğ‘—) = â„(ğ‘–)(ğ‘›ğ‘¡ + ğ‘— âˆ’ 1) for ğ‘– Ì¸= ğ‘—). Thus, the transition function explicitly depends on time (more precisely, on time modulo the number of layers), and is sparse at each step. Indeed, at each step, applying the transition function amounts to applying one of the ğ‘“ (ğ‘–) to the corresponding layer, and leaving the other layers unchanged. Thus the derivative of ğ‘“ (ğ‘–) with respect to any ğœƒğ‘— , ğ‘— Ì¸= ğ‘–, is zero; this leaves only the gradient of ğ‘“ (ğ‘–) wrt ğœƒğ‘– to be dealt with, and Algorithm 1 or 2 can be applied at little cost."
        },
        {
            "heading": "1.4 Extensions",
            "text": "Rank-ğ¾ reductions. A first obvious extension is to use higher-rank reductions. The simplest way to achieve this is to take several independent random rank-one ğ‘£ğ‘˜?Ì„?âŠ¤ğ‘˜ reductions in (7) and average them. Note that ğ‘¤ğ‘– (Algorithm 1) has to be evaluated only once in this case. It might be slightly more efficient to first split the parameter components into ğ¾ blocks (e.g., at random) so that the ğ‘˜-th term ?Ì„?âŠ¤ğ‘˜ only involves parameters from the ğ‘˜-th block: indeed, applying the evolution equation for ğº preserves this structure so this requires less memory for storage of the ?Ì„?ğ‘˜.\nAlgorithms similar to RTRL. Other algorithms have been proposed that have the same structure and shortcomings as real-time recurrent learning, for instance, the online EM algorithm for hidden Markov models from [Cap11]. In principle, the approach presented here can be extended to such settings.\nContinuous-time systems. Another extension concerns continuous-time dynamical systems\ndâ„(ğ‘¡) dğ‘¡ = ğ¹ (â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ) (47)\nwhich can be discretized as â„(ğ‘¡ + ğ›¿ğ‘¡) = â„(ğ‘¡) + ğ›¿ğ‘¡ğ¹ (â„(ğ‘¡), ğ‘¥(ğ‘¡), ğœƒ). Thus this is analogous to the discrete-time case via ğ‘“ = Id +ğ›¿ğ‘¡ğ¹ , and Algorithm 1 may be applied to this discretization.\nWhen performing the rank-one reduction (7), the scaling by ğœŒğ‘– = âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘£ğ‘–â€–\nis important in this case: it ensures that both ğ‘£ and ?Ì„? change by ğ‘‚( âˆš\nğ›¿ğ‘¡) times a random quantity at each step. This is the expected correct scaling for a continuous-time stochastic evolution equation, corresponding to the increment of a Wiener process during a time interval ğ›¿ğ‘¡. (Without scaling by ğœŒğ‘–, there will be no well-defined limit as ğ›¿ğ‘¡ â†’ 0, because ğ‘£ would change by ğ‘‚(1) at each step ğ‘¡â† ğ‘¡ + ğ›¿ğ‘¡, while ?Ì„? would evolve by ğ›¿ğ‘¡ times a centered random quantity so that it would be constant in the limit.) Further work is needed to study this continuous-time limit."
        },
        {
            "heading": "2 Experiments",
            "text": "We report here a series of small-scale experiments on text prediction tasks. The experiments focus on two questions: First, does learning using the rank-one approximation ?Ìƒ? accurately reflect learning based on the actual gradient ğº computed exactly via RTRL, or is the noise introduced in this method detrimental to learning? Second, how does this approach compare to truncated backpropagation through time?\nWe used the RNN or leaky RNN models described above to predict a sequence of characters ğ‘¦(ğ‘¡) in a finite alphabet ğ’œ, given the past observations ğ‘¥(ğ‘ ) = ğ‘¦(ğ‘ ) for 1 6 ğ‘  6 ğ‘¡ âˆ’ 1. At each time, the network outputs a probability distribution on the next character ğ‘§; explicitly, the output at time ğ‘¡ is ğ‘¦(ğ‘¡) âˆˆ Rğ’œ defined by\nğ‘¦(ğ‘¡)ğ‘§ := ğœ™ğ‘§ + âˆ‘ï¸\nğ‘–\nğœ™ğ‘–ğ‘§ğ‘ğ‘–(ğ‘¡) (48)\nfor each ğ‘§ âˆˆ ğ’œ, with parameters ğœ™ = (ğœ™ğ‘§, ğœ™ğ‘–ğ‘§)ğ‘–,ğ‘§. The output ğ‘¦ = (ğ‘¦ğ‘¦)ğ‘¦âˆˆğ’œ defines a probability distribution on ğ’œ via a softmax ğ‘ğ‘¦(ğ‘¦) := ğ‘’ ğ‘¦ğ‘¦âˆ‘ï¸€ ğ‘§âˆˆğ´ğ‘™ ğ‘’ ğ‘¦ğ‘§ , and the loss function is the log-loss on prediction of the next character, â„“ğ‘¡ := âˆ’ log2 ğ‘ğ‘¦(ğ‘¡)(ğ‘¦(ğ‘¡)). The internal and output parameters ğœƒ and ğœ™ are trained according to Algorithms 1 and 2.\nWe used three datasets. The first is a â€œtextâ€ representing synthetic music notation with several syntactic, rhythmic and harmonic constraints (Example 3 from [Oll15b]). The data was a file of length â‰ˆ 105 characters, after which the signal cycled over the same file. The second dataset is the classical ğ‘ğ‘›ğ‘ğ‘› example, synthesized by repeatedly picking an integer ğ‘› at random in some interval, then outputting a series of ğ‘› ğ‘â€™s followed by a line break, then ğ‘› ğ‘â€™s and another line break. This model tests the ability of a learning algorithm to learn precise timing and time dependencies. The\nthird example is the full set of Shakespeareâ€™s works, obtained from Project Gutenberg.12 The file is roughly 5.106 characters long.\nThe benchmarks included are gzip, a standard non-online compression algorithm, and context tree weighting (CTW) [BEYY04], a more advanced online text compression algorithm, as well as the actual entropy rate of the generative model for synthetic music and ğ‘ğ‘›ğ‘ğ‘›.\nThe code used in the experiments is available at http://www.yann-ollivier. org/rech/code/nobacktrack/code_nobacktrack_exp.tar.gz\nEuclidean NoBackTrack. We first study whether the low rank approximation in the Euclidean version of NoBackTrack impacts the gradient descent. For this first set of experiments, we use a fully connected RNN with 20 units, as described above, on the synthetic music example. We compared RTRL, Euclidean rank-one NoBackTrack, and Euclidean NoBackTrack using ranktwo and rank-ten reductions (obtained by averaging two or ten independent rank-one reductions, as discussion in Section 1.4).\nThe results are summed up in Figure 1 and Figure 2. All the models were trained using the same learning rate ğœ‚ğ‘¡ = 1/ âˆš ğ‘¡ for Figure 1 and ğœ‚ğ‘¡ = 0.03/ âˆš ğ‘¡ for Figure 2. The various algorithms were run for the same amount of time. This is reflected in the different curve lengths for the different algorithms; in particular, the curve for RTRL is much shorter, reflecting its higher computational cost. (Note the log scale on the ğ‘¡ axis: RTRL is roughly 20 times slower with 20 units.)\nThe impact of stochasticity of the low-rank approximation when using large learning rates is highlighted on Figure 1: Euclidean NoBackTrack with a large learning rate displays instabilities, even when increasing the rank of the approximation.\nSmaller learning rates allow the algorithm to cope with this, as the noise in the gradients is averaged out over longer time spans. This is illustrated in Figure 2, in which the trajectories of Euclidean NoBackTrack track those of RTRL closely even with a rank-two approximation.\nKalman NoBackTrack. Next, we report the results of the Kalman version of NoBackTrack on the same experimental setup. A quasi-diagonal outer product (QDOP) approximation [Oll15a] of the full Kalman inverse covariance matrix is used, to keep complexity low.\nWe compare the low-rank approximations to RTRL. To make the comparison clear, for RTRL we also use a quasi-diagonal (QDOP) approximation of the Kalman filtering algorithm on top of the exact gradient computed by RTRL.\n12www.gutenberg.org\nLearning rates were set to 1 and all algorithms were run for the same amount of time.\nThe use of the QDOP-approximated Kalman inverse covariance appears to fully fix the unstable behaviour. Overall, low-rank approximations appear to be roughly on par with QDOP RTRL. There is no obvious gain, on this particular example, in using higher-rank approximations.\nStill, on this particular task and with this particular network size, none of the RNN algorithms (including BPTT reported below) match the performance of Context Tree Weighting. RNNs beat CTW on this task if trained using a non-online, Riemannian gradient descent [Oll15b] (analogous to using the Kalman inverse covariance). So this is arguably an effect of imperfect online RNN training.\nKalman NoBackTrack and truncated BPTT. Our next set of experiments aims at comparing Kalman NoBackTrack to truncated BPTT, with truncation13 parameter ğ‘‡ = 15. As BPTT truncates the full gradient by\n13In the version of BPTT used here, the algorithm does not backtrack by ğ‘‡ steps at every time step ğ‘¡; rather, it waits for ğ‘‡ steps between ğ‘¡ and ğ‘¡ + ğ‘‡ , then backtracks by ğ‘‡ steps and collects all gradients in this interval. Otherwise, truncated BPTT would be ğ‘‡ times slower, which was unacceptable for our experiments.\nremoving dependencies at distances longer than the truncation parameter, we expect Kalman NoBackTrack to learn better models on datasets presenting long term correlations.\nThe two algorithms are first compared on the synthetic music dataset, with the same experimental setup as above, for the same amount of time, with a learning rate ğœ‚ğ‘¡ = 1/ âˆš ğ‘¡ for truncated BPTT and ğ›¾ğ‘¡ = 1/ âˆš ğ‘¡ for Kalman NoBackTrack.14 The results are shown in Figure 4. On this example, truncated BPTT perfoms better than Kalman NoBackTrack, even though the two algorithms display broadly comparable performance. Noticeably, RTRL and truncated BPTT are roughly on par here, with truncated BPTT slightly outperforming RTRL in the end: apparently, maintaining long term dependencies in gradient calculations does not improve learning in this synthetic music example.\nNext, to compare NoBackTrack and truncated BPTT on their specific ability to learn precise middle and long term dependencies, we present experiments on the ğ‘ğ‘›ğ‘ğ‘› example. This will clearly illustrate the biased nature of the gradients computed by truncated BPTT.\n14These learning rates have different meanings for Kalman NoBackTrack and truncated BPTT, and are not directly comparable.\nThe ğ‘ğ‘›ğ‘ğ‘›[ğ‘˜;ğ‘™] dataset is synthesized by sequentially picking a number ğ‘› between ğ‘˜ and ğ‘™ uniformly at random, then outputting a series of ğ‘› ğ‘â€™s followed by a line break, then ğ‘› ğ‘â€™s and another line break. The true entropy rate is log2(ğ‘™âˆ’ğ‘˜+1)ğ‘™+ğ‘˜+2 in this example.\n15 A roughly 106 character long input sequence was synthesized, using [ğ‘˜; ğ‘™] = [1; 32].\nAs standard RNN models do not seem to be able to deal with this example, whatever the training algorithm, we used a leaky RNN16 as presented in Section 1.3, again with 20 fully connected units. All the algorithms used a learning rate of 1/ âˆš ğ‘¡. The results are reported on Figure 5, which also includes the entropy rate of the exact ğ‘ğ‘›ğ‘ğ‘› model and the (twice larger) entropy rate of an ğ‘ğ‘›ğ‘ğ‘ model with independent ğ‘› and ğ‘.\nKalman NoBackTrack clearly outperforms truncated BPTT on this dataset. This was to be expected, as the typical time range of the temporal dependencies exceeds the truncation range for BPTT, so that the\n15Indeed, log2(ğ‘™ âˆ’ ğ‘˜ + 1) bits are needed to encode the value of ğ‘› in each ğ‘ğ‘›ğ‘ğ‘› block (this is the entropy of a uniform distribution on {ğ‘˜, . . . , ğ‘™}), and the average value of ğ‘› is (ğ‘˜ + ğ‘™)/2 so that the average length of an ğ‘ğ‘›ğ‘ğ‘› block, including the two newline symbols, is 2Ã— (ğ‘™ + ğ‘˜)/2 + 2.\n16The parameter ğ›¼ of the LRNN can be learned, but this sometimes produces numerical instabilities unless cumbersome changes of variables are introduced. We just initialized ğ›¼ to a random value separately for each unit and kept it fixed.\napproximated gradients computed by truncated BPTT are significantly biased.\nKeeping track of the long term dependencies is key here, and RTRL outperforms all the algorithms epochwise, though it is still penalized by its high complexity. Truncated BPTT is unable to learn the full dependencies between ğ‘â€™s and ğ‘â€™s, and ends up closer to the entropy of an ğ‘ğ‘›ğ‘ğ‘ model with independent values of ğ‘› and ğ‘ (presumably, it still manages to learn the ğ‘ğ‘›ğ‘ğ‘› blocks where ğ‘› is short). At some point the learning curve of truncated BPTT appears not to decrease anymore and even goes slightly up, which is consistent with a biased gradient estimate.\nOn the other hand, Kalman NoBackTrack seems to be mostly successful in learning the dependencies. This is confirmed by visual inspection of the output of the learned model. The small remaining gap between the true model and the learned model could be related to incomplete training, or to an imperfect modelling of the exact uniform law for ğ‘› âˆˆ [ğ‘˜; ğ‘™].\nFinally, we report performance of truncated BPTT and Kalman NoBackTrack on Shakespeareâ€™s works. The same 20-unit RNN model is used, again with all algorithms run for the same amount of time using the same learning rate 1/ âˆš ğ‘¡. The curves obtained are displayed in Figure 6.\nOn this example, RTRL, truncated BPTT, and Kalman NoBackTrack\nwith various ranks all have a similar performance; it is not clear whether the differences on Figure 6 are statistically significant. This proves, once more, that the stochasticity and rank reduction inherent to NoBackTrack are not detrimental to learning, and allow it to keep up with exact gradient algorithms.\nAll RNN algorithms have a significantly worse performance than CTW on this example, thus proving that a 20-unit RNN does not accurately model Shakespeareâ€™s works.\nConclusion. We have introduced an algorithm that computes a stochastic, provably unbiased estimate of the derivative of the current state of a dynamical system with respect to its parameters, in a fully online fashion. For recurrent neural networks, the computational cost of this algorithm is comparable to that of running the network itself. Previously known algorithms were either not fully online or had a significantly higher computational cost.\nIn our experiments, this algorithm appears as a practical alternative to truncated backpropagation through time, especially in its Kalman version, while the Euclidean version requires smaller learning rates. The (unbiased) noise and rank reduction introduced in the gradient approximation do not appear to prevent learning. The interest of NoBackTrack with respect to truncated BPTT depends on the situation at hand, especially on the scale of time dependencies in the data (which results in biased gradient estimates for BPTT), and on whether the storage of past states and past data required by truncated BPTT is acceptable or not.\nAcknowledgments. The authors would like to thank Hugo Larochelle for his helpful questions that resulted in several clarifications of the text.\nA Variance of the rank-one trick Keep the notation of Proposition 1 and let â€–Â·â€– be a Euclidean norm on the vector space in which the ğ‘£ğ‘– and ğ‘¤ğ‘– live.\nTo measure the variance of ğ´ we use the Hilbertâ€“Schmidt norm âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2\nHS := Tr(ğ´âŠ¤ğ´). This norm satisfies âƒ¦âƒ¦ ğ‘£ğ‘¤âŠ¤âƒ¦âƒ¦ HS = â€–ğ‘£â€– â€–ğ‘¤â€–, and âŸ¨ï¸€ ğ‘£1ğ‘¤ âŠ¤ 1 | ğ‘£2ğ‘¤âŠ¤2 âŸ©ï¸€ HS = âŸ¨ ğ‘£1 | ğ‘£2 âŸ© âŸ¨ğ‘¤1 | ğ‘¤2 âŸ© for the associated scalar product. Let us evaluate the variance of ğ´ in this norm. Since Var ğ´ = E âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2 HSâˆ’ âƒ¦âƒ¦ Eğ´ âƒ¦âƒ¦2\nHS and Eğ´ = ğ´ is fixed, it is enough to evaluate the second moment E âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2\nHS. We claim that\nE âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2 HS = ( âˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€–2)( âˆ‘ï¸\nğ‘—\nâ€–ğ‘¤ğ‘—â€–2) + 2 âˆ‘ï¸\nğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ© (49)\nIndeed, ğ´ = âˆ‘ï¸€\nğ‘–ğ‘— ğœ€ğ‘–ğœ€ğ‘—ğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘— so, by bilinearity of the Hilbertâ€“Schmidt scalar product,\nE âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2 HS = E âŸ¨ï¸€ ğ´ | ğ´ âŸ©ï¸€ HS = E âˆ‘ï¸ ğ‘–ğ‘—ğ‘˜ğ‘™ ğœ€ğ‘–ğœ€ğ‘—ğœ€ğ‘˜ğœ€ğ‘™ âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘˜ | ğ‘¤ğ‘™ âŸ© (50)\nSince Eğœ€ğ‘– = 0 and E(ğœ€ğ‘–ğœ€ğ‘—) = 0 for ğ‘– Ì¸= ğ‘—, the only cases to consider are: 1. ğ‘– = ğ‘— and ğ‘˜ = ğ‘™ and ğ‘– Ì¸= ğ‘˜: contribution âˆ‘ï¸€\nğ‘– âˆ‘ï¸€ ğ‘˜ Ì¸=ğ‘– â€–ğ‘£ğ‘–â€– 2 â€–ğ‘¤ğ‘˜â€–2\n2. ğ‘– = ğ‘˜ and ğ‘— = ğ‘™ and ğ‘– Ì¸= ğ‘—: contribution âˆ‘ï¸€\nğ‘– âˆ‘ï¸€ ğ‘— Ì¸=ğ‘– âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ©\n3. ğ‘– = ğ‘™ and ğ‘— = ğ‘˜ and ğ‘– Ì¸= ğ‘—: same contribution as the previous one 4. ğ‘– = ğ‘— = ğ‘˜ = ğ‘™: contribution âˆ‘ï¸€\nğ‘– â€–ğ‘£ğ‘–â€– 2 â€–ğ‘¤ğ‘–â€–2\n5. all other cases contribute 0. The first and fourth contributions add up to ( âˆ‘ï¸€ ğ‘– â€–ğ‘£ğ‘–â€– 2)( âˆ‘ï¸€ ğ‘˜ â€–ğ‘¤ğ‘˜â€– 2). This proves (49). Let us minimize variance over the degrees of freedom given by ğ‘£ğ‘–ğ‘¤âŠ¤ğ‘– = (ğœŒğ‘–ğ‘£ğ‘–)(ğ‘¤ğ‘–/ğœŒğ‘–)âŠ¤.\nğœŒğ‘– does not change the last contribution to E âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2\nHS in (49), neither does it change the expectation Eğ´ = ğ´, so to minimize the variance we only have to minimize the first term ( âˆ‘ï¸€ ğ‘– â€–ğ‘£ğ‘–â€– 2)( âˆ‘ï¸€ ğ‘˜ â€–ğ‘¤ğ‘˜â€– 2). Applying the scaling, this term becomes\n( âˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€–2 ğœŒ2ğ‘– )( âˆ‘ï¸\nğ‘˜\nâ€–ğ‘¤ğ‘˜â€–2 /ğœŒ2ğ‘˜) (51)\nand, by differentiation with respect to a single ğœŒğ‘–, one checks that this is minimal for ğœŒğ‘– âˆ âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘£ğ‘–â€– (52)\n(mutliplying all ğœŒğ‘–â€™s by a common factor does not change the result). So, after optimal scaling,\nğ´ = (ï¸ƒâˆ‘ï¸\nğ‘–\nğœ€ğ‘–ğ‘£ğ‘– âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘£ğ‘–â€– )ï¸ƒ âŠ— (ï¸ƒâˆ‘ï¸ ğ‘– ğœ€ğ‘–ğ‘¤ğ‘– âˆšï¸€ â€–ğ‘£ğ‘–â€– / â€–ğ‘¤ğ‘–â€– )ï¸ƒ (53)\nConsequently, after scaling, the first term in the variance of ğ´ in (49) becomes ( âˆ‘ï¸€\nğ‘– â€–ğ‘£ğ‘–â€– â€–ğ‘¤ğ‘–â€–)2. The second term in (49) does not change. Thus, after optimal scaling we find\nE âƒ¦âƒ¦ ğ´ âƒ¦âƒ¦2 HS = (ï¸ƒâˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€– â€–ğ‘¤ğ‘–â€– )ï¸ƒ2 + 2\nâˆ‘ï¸ ğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ© (54)\nTo obtain the variance of ğ´, we just subtract the square norm of Eğ´ = ğ´, which is\nâ€–ğ´â€–2HS = âƒ¦âƒ¦âƒ¦âƒ¦ âƒ¦âˆ‘ï¸\nğ‘–\nğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘– âƒ¦âƒ¦âƒ¦âƒ¦ âƒ¦ 2\nHS\n= âˆ‘ï¸\nğ‘–\nâƒ¦âƒ¦ ğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘– âƒ¦âƒ¦2 HS + âˆ‘ï¸ ğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– âŸ¨ï¸€ ğ‘£ğ‘–ğ‘¤ âŠ¤ ğ‘– | ğ‘£ğ‘—ğ‘¤âŠ¤ğ‘— âŸ©ï¸€ HS (55)\n(by bilinearity of the Hilbertâ€“Schmidt scalar product)\n= âˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€–2 â€–ğ‘¤ğ‘–â€–2 + âˆ‘ï¸\nğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ© (56)\nThis yields, after optimal scaling,\nVar ğ´ = (ï¸ƒâˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€– â€–ğ‘¤ğ‘–â€– )ï¸ƒ2 âˆ’ âˆ‘ï¸\nğ‘–\nâ€–ğ‘£ğ‘–â€–2 â€–ğ‘¤ğ‘–â€–2 + âˆ‘ï¸\nğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ© (57)\n= âˆ‘ï¸\nğ‘– âˆ‘ï¸ ğ‘— Ì¸=ğ‘– â€–ğ‘£ğ‘–â€– â€–ğ‘£ğ‘—â€– â€–ğ‘¤ğ‘–â€– â€–ğ‘¤ğ‘—â€–+ âŸ¨ ğ‘£ğ‘– | ğ‘£ğ‘— âŸ© âŸ¨ğ‘¤ğ‘– | ğ‘¤ğ‘— âŸ© (58)\nB Invariant norms derived from the Kalman covariance\nAlgorithm 2 is built to offer invariance properties (a Kalman filter over a variable ğœƒ is invariant by affine reparameterization of ğœƒ, for instance). However, this only holds if the norms â€–ğ‘£â€–, â€–?Ì„?â€–, â€–ğ‘£ğ‘–â€–, â€–ğ‘¤ğ‘–â€–, used to compute the scaling factors ğœŒ = âˆšï¸€ â€–?Ì„?â€– / â€–ğ‘£â€–\nand ğœŒğ‘– = âˆšï¸€ â€–ğ‘¤ğ‘–â€– / â€–ğ‘’ğ‘–â€–, are themselves reparameterization-invariant.\nThis can be achieved if we decide to choose the scalings ğœŒ as to minimize the variance of ?Ìƒ? computed in the (Mahalanobis) norm defined by the covariance matrix of ğœƒ and of â„ appearing in the Kalman filter.\nLet ğ¶ğœƒ be the covariance matrix of ğœƒ obtained in the Kalman filter; in Algorithm 2, ğ¶ğœƒ is approximated by ğ¶ğœƒ â‰ˆ ğ½âˆ’1ğœƒ .\nAny linear form on ğœƒ, such as ?Ì„? and ğ‘¤ğ‘–, can be given a norm by\nâ€–?Ì„?â€–2 := ?Ì„?âŠ¤ğ¶ğœƒ?Ì„? â‰ˆ ?Ì„?âŠ¤ğ½âˆ’1ğœƒ ?Ì„? (59)\nand likewise for ğ‘¤ğ‘–. This norm is invariant under ğœƒ-reparameterization. Given the covariance ğ¶ğœƒ of ğœƒ and the dependency ğº = ğœ•â„ğœ•ğœƒ of â„ with respect to ğœƒ, the covariance of â„ is ğ¶â„ := ğºğ¶ğœƒğºâŠ¤ (60) and its inverse ğ½â„ := ğ¶âˆ’1â„ can be used to define a norm for a tangent vector ğ‘£ at state â„ via â€–ğ‘£â€–2 := ğ‘£âŠ¤ğ½â„ğ‘£ (61) which is also reparametrization-invariant. (We use ğ½âˆ’1ğœƒ for the norm of ğ‘¤ and ğ½â„ for the norm of ğ‘£ because ğ‘£ is a tangent vector (covariant) at point â„, while ğ‘¤ is a linear form (contravariant) at point ğœƒ.)\nHowever, handling of full covariance matrices would be too costly. In Algorithm 2, the inverse covariance ğ½ğœƒ of ğœƒ is already an approximation (diagonal, quasi-diagonal...) via MatrixReduce. Moreover, here we only have access to an approximation ?Ìƒ? of ğº. Thus, we simply replace ğº with ?Ìƒ? in the definition of ğ¶â„, and use a diagonal reduction. This leads to ğ¶â„ â‰ˆ Diag(?Ìƒ?ğ½âˆ’1ğœƒ ?Ìƒ?âŠ¤) and\nğ½â„ â‰ˆ (ï¸€ Diag(?Ìƒ?ğ½âˆ’1ğœƒ ?Ìƒ? âŠ¤) )ï¸€âˆ’1 (62)\nwhere as usual ?Ìƒ? is the gradient approximation given by (9). The diagonal reduction is necessary if ?Ìƒ? is low-rank, since ?Ìƒ?ğ½âˆ’1ğœƒ ?Ìƒ?âŠ¤ will be low-rank as well, and thus non-invertible. Then the scaling factors ğœŒ and ğœŒğ‘– can finally be computed as\nğœŒ = âˆšï¸ƒ â€–?Ì„?â€– â€–ğ‘£â€– = (?Ì„?âŠ¤ğ½âˆ’1ğœƒ ?Ì„?)1/4(ï¸€âˆ‘ï¸€\nğ‘–(?Ìƒ?ğ½ âˆ’1 ğœƒ ?Ìƒ? âŠ¤)âˆ’1ğ‘–ğ‘– ğ‘£2ğ‘– )ï¸€1/4 (63)\nand\nğœŒğ‘– = âˆšï¸ƒ â€–ğ‘¤ğ‘–â€– â€–ğ‘’ğ‘–â€– = (ğ‘¤âŠ¤ğ‘–ğ½âˆ’1ğœƒ ğ‘¤ğ‘–)1/4(ï¸€\n(?Ìƒ?ğ½âˆ’1ğœƒ ?Ìƒ?âŠ¤) âˆ’1 ğ‘–ğ‘– )ï¸€1/4 (64) The particular structure of ğ½ğœƒ (if approximated by, e.g., a block-diagonal matrix) and of ?Ìƒ? = ğ‘£?Ì„?âŠ¤+ âˆ‘ï¸€ ğ‘– ğ‘’ğ‘–ğ‘¤ âŠ¤ ğ‘– make these computations efficient.\nNote that even with the approximations above, ?Ìƒ? is still an unbiased estimate of ğº. Indeed, any choice of ğœŒ has this property; we are simply approximating the optimal ğœŒ which minimizes the variance of ?Ìƒ?.\nIn practice, small regularization terms are included in the denominator of every division and inversion to avoid numerical overflow."
        }
    ],
    "title": "Training recurrent networks online without backtracking",
    "year": 2015
}