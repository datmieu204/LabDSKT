{
    "abstractText": "We introduce the “NoBackTrack” algorithm to train the parameters of dynamical systems such as recurrent neural networks. This algorithm works in an online, memoryless setting, thus requiring no backpropagation through time, and is scalable, avoiding the large computational and memory cost of maintaining the full gradient of the current state with respect to the parameters. The algorithm essentially maintains, at each time, a single search direction in parameter space. The evolution of this search direction is partly stochastic and is constructed in such a way to provide, at every time, an unbiased random estimate of the gradient of the loss function with respect to the parameters. Because the gradient estimate is unbiased, on average over time the parameter is updated as it should. The resulting gradient estimate can then be fed to a lightweight Kalman-like filter to yield an improved algorithm. For recurrent neural networks, the resulting algorithms scale linearly with the number of parameters. Small-scale experiments confirm the suitability of the approach, showing that the stochastic approximation of the gradient introduced in the algorithm is not detrimental to learning. In particular, the Kalman-like version of NoBackTrack is superior to backpropagation through time (BPTT) when the time span of dependencies in the data is longer than the truncation span for BPTT. Consider the problem of training the parameters θ of a dynamical system over a variable h ∈ Rn subjected to the evolution equation h(t + 1) = f(h(t), x(t), θ) (1) where f is a fixed function of h and of an input signal x(t), depending on parameters θ. The goal is online minimization of a loss function ∑︀ t lt(y(t), y(t)) between a desired output y(t) at time t and a prediction1 y(t) = Y (h(t), φ) (2) 1The prediction y may not live in the same set as y. Often, y encodes a probability distribution over the possible values of y, and the loss is the logarithmic loss l = − log py(y). 1 ar X iv :1 50 7. 07 68 0v 2 [ cs .N E ] 2 0 N ov 2 01 5 computed from h(t) and additional parameters φ. A typical example we have in mind is a recurrent neural network, with activities ai(t) := sigm(hi(t)) and evolution equation hi(t + 1) = bi + ∑︀ k rkixk(t) + ∑︀ j Wjiaj(t), with parameter θ = (bi, rki, Wji)i,j,k. If the full target sequence y(t)t∈[0;T ] is known in advance, one strategy is to use the backpropagation through time algorithm (BPTT, see e.g. [Jae02]) to compute the gradient of the total loss LT := ∑︀T t=0 lt with respect to the parameters θ and φ, and use gradient descent on θ and φ. However, if the data y(t + 1) arrive one at a time in a streaming fashion, backpropagation through time would require making a full backward computation from time t + 1 to time 0 after each new data point becomes available. This results in an Ω(t2) complexity and in the necessity to store past states, inputs, and outputs. A possible strategy is to only backtrack by a finite number of time steps [Jae02] rather than going back all the way to t = 0. But this provides biased gradient estimates and may impair detection of time dependencies with a longer range than the backtracking time range. By contrast, methods which are fully online are typically not scalable. One strategy, known as real-time recurrent learning (RTRL) in the recurrent network community,2 maintains the full gradient of the current state with respect to the parameters: G(t) := ∂h(t) ∂θ (3) which satisfies the evolution equation G(t + 1) = ∂f(h(t), x(t), θ) ∂h G(t) + ∂f(h(t), x(t), θ) ∂θ (4) (by differentiating (1)). Knowing G(t) allows to minimize the loss via a stochastic gradient descent on the parameters θ, namely,3 θ ← θ − ηt ∂lt ∂θ ⊤ (5) with learning rate ηt. Indeed, the latter quantity can be computed from Gt and from the way the predictions depend on h(t), via the chain rule ∂lt ∂θ = ∂lt(Y (h(t), φ), y(t)) ∂h G(t) (6) However, the full gradient G(t) is an object of dimension dim h × dim θ. This prevents computing or even storing G(t) for moderately largedimensional dynamical systems, such as recurrent neural networks. 2This amounts to applying forward automatic differentiation. 3We use the standard convention for Jacobian matrices, namely, ∂x/∂y is the matrix with entries ∂xi/∂yj . Then the chain rule writes ∂x ∂y ∂y ∂z = ∂x ∂z . This makes the derivatives ∂lt/∂θ into row vectors so that gradient descent is θ ← θ − (∂lt/∂θ).",
    "authors": [
        {
            "affiliations": [],
            "name": "Yann Ollivier"
        },
        {
            "affiliations": [],
            "name": "Corentin Tallec"
        },
        {
            "affiliations": [],
            "name": "Guillaume Charpiat"
        }
    ],
    "id": "SP:04af117cc4a19a7e5ad3d26abe7c7f5c2bed2678",
    "references": [
        {
            "authors": [
                "Ron Begleiter",
                "Ran El-Yaniv",
                "Golan Yona"
            ],
            "title": "On prediction using variable order markov models",
            "venue": "Journal of Artificial Intelligence Research,",
            "year": 2004
        },
        {
            "authors": [
                "Olivier Cappé"
            ],
            "title": "Online EM algorithm for hidden Markov models",
            "venue": "J. Comput. Graph. Statist.,",
            "year": 2011
        },
        {
            "authors": [
                "Simon Haykin"
            ],
            "title": "Kalman filtering and neural networks",
            "year": 2004
        },
        {
            "authors": [
                "Herbert Jaeger"
            ],
            "title": "Tutorial on training recurrent neural networks, covering BPTT, RTRL, EKF and the ‘‘echo state network’",
            "venue": "Technical Report 159,",
            "year": 2002
        },
        {
            "authors": [
                "Yann Ollivier"
            ],
            "title": "Riemannian metrics for neural networks I: feedforward networks",
            "venue": "Information and Inference,",
            "year": 2015
        },
        {
            "authors": [
                "Yann Ollivier"
            ],
            "title": "Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences",
            "venue": "Information and Inference,",
            "year": 2015
        }
    ],
    "sections": [
        {
            "text": "The algorithm essentially maintains, at each time, a single search direction in parameter space. The evolution of this search direction is partly stochastic and is constructed in such a way to provide, at every time, an unbiased random estimate of the gradient of the loss function with respect to the parameters. Because the gradient estimate is unbiased, on average over time the parameter is updated as it should.\nThe resulting gradient estimate can then be fed to a lightweight Kalman-like filter to yield an improved algorithm. For recurrent neural networks, the resulting algorithms scale linearly with the number of parameters.\nSmall-scale experiments confirm the suitability of the approach, showing that the stochastic approximation of the gradient introduced in the algorithm is not detrimental to learning. In particular, the Kalman-like version of NoBackTrack is superior to backpropagation through time (BPTT) when the time span of dependencies in the data is longer than the truncation span for BPTT.\nConsider the problem of training the parameters 𝜃 of a dynamical system over a variable ℎ ∈ R𝑛 subjected to the evolution equation\nℎ(𝑡 + 1) = 𝑓(ℎ(𝑡), 𝑥(𝑡), 𝜃) (1)\nwhere 𝑓 is a fixed function of ℎ and of an input signal 𝑥(𝑡), depending on parameters 𝜃. The goal is online minimization of a loss function ∑︀ 𝑡 ℓ𝑡(𝑦(𝑡), 𝑦(𝑡)) between a desired output 𝑦(𝑡) at time 𝑡 and a prediction1\n𝑦(𝑡) = 𝑌 (ℎ(𝑡), 𝜙) (2) 1The prediction 𝑦 may not live in the same set as 𝑦. Often, 𝑦 encodes a probability distribution over the possible values of 𝑦, and the loss is the logarithmic loss ℓ = − log 𝑝𝑦(𝑦).\nar X\niv :1\n50 7.\n07 68\n0v 2\n[ cs\n.N E\n] 2\n0 N\nov 2\n01 5\ncomputed from ℎ(𝑡) and additional parameters 𝜙. A typical example we have in mind is a recurrent neural network, with activities 𝑎𝑖(𝑡) := sigm(ℎ𝑖(𝑡)) and evolution equation ℎ𝑖(𝑡 + 1) = 𝑏𝑖 + ∑︀ 𝑘 𝑟𝑘𝑖𝑥𝑘(𝑡) + ∑︀ 𝑗 𝑊𝑗𝑖𝑎𝑗(𝑡), with parameter 𝜃 = (𝑏𝑖, 𝑟𝑘𝑖, 𝑊𝑗𝑖)𝑖,𝑗,𝑘.\nIf the full target sequence 𝑦(𝑡)𝑡∈[0;𝑇 ] is known in advance, one strategy is to use the backpropagation through time algorithm (BPTT, see e.g. [Jae02]) to compute the gradient of the total loss 𝐿𝑇 := ∑︀𝑇 𝑡=0 ℓ𝑡 with respect to the parameters 𝜃 and 𝜙, and use gradient descent on 𝜃 and 𝜙. However, if the data 𝑦(𝑡 + 1) arrive one at a time in a streaming fashion, backpropagation through time would require making a full backward computation from time 𝑡 + 1 to time 0 after each new data point becomes available. This results in an Ω(𝑡2) complexity and in the necessity to store past states, inputs, and outputs. A possible strategy is to only backtrack by a finite number of time steps [Jae02] rather than going back all the way to 𝑡 = 0. But this provides biased gradient estimates and may impair detection of time dependencies with a longer range than the backtracking time range.\nBy contrast, methods which are fully online are typically not scalable. One strategy, known as real-time recurrent learning (RTRL) in the recurrent network community,2 maintains the full gradient of the current state with respect to the parameters:\n𝐺(𝑡) := 𝜕ℎ(𝑡) 𝜕𝜃\n(3)\nwhich satisfies the evolution equation\n𝐺(𝑡 + 1) = 𝜕𝑓(ℎ(𝑡), 𝑥(𝑡), 𝜃) 𝜕ℎ 𝐺(𝑡) + 𝜕𝑓(ℎ(𝑡), 𝑥(𝑡), 𝜃) 𝜕𝜃\n(4)\n(by differentiating (1)). Knowing 𝐺(𝑡) allows to minimize the loss via a stochastic gradient descent on the parameters 𝜃, namely,3\n𝜃 ← 𝜃 − 𝜂𝑡 𝜕ℓ𝑡 𝜕𝜃\n⊤ (5)\nwith learning rate 𝜂𝑡. Indeed, the latter quantity can be computed from 𝐺𝑡 and from the way the predictions depend on ℎ(𝑡), via the chain rule\n𝜕ℓ𝑡 𝜕𝜃 = 𝜕ℓ𝑡(𝑌 (ℎ(𝑡), 𝜙), 𝑦(𝑡)) 𝜕ℎ 𝐺(𝑡) (6)\nHowever, the full gradient 𝐺(𝑡) is an object of dimension dim ℎ × dim 𝜃. This prevents computing or even storing 𝐺(𝑡) for moderately largedimensional dynamical systems, such as recurrent neural networks.\n2This amounts to applying forward automatic differentiation. 3We use the standard convention for Jacobian matrices, namely, 𝜕𝑥/𝜕𝑦 is the matrix\nwith entries 𝜕𝑥𝑖/𝜕𝑦𝑗 . Then the chain rule writes 𝜕𝑥𝜕𝑦 𝜕𝑦 𝜕𝑧 = 𝜕𝑥 𝜕𝑧 . This makes the derivatives 𝜕ℓ𝑡/𝜕𝜃 into row vectors so that gradient descent is 𝜃 ← 𝜃 − (𝜕ℓ𝑡/𝜕𝜃)⊤.\nAlgorithms using a Kalman filter on 𝜃 also4 rely on this derivative 𝜕ℓ𝑡𝜕𝜃 (see [Hay04, Jae02] for the case of recurrent networks). So any efficient way of estimating this derivative can be fed, in turn, to a Kalman-type algorithm.\nAlgorithms suggested to train hidden Markov models online (e.g., [Cap11], based on expectation-maximization instead of gradient descent) share the same algebraic structure and suffer from the same problem."
        },
        {
            "heading": "1 The NoBackTrack algorithm",
            "text": ""
        },
        {
            "heading": "1.1 The rank-one trick: an expectation-preserving reduction",
            "text": "We propose to build an approximation ?̃?(𝑡) of 𝐺(𝑡) with a more sustainable algorithmic cost; ?̃?(𝑡) will be random with the property E?̃?(𝑡) = 𝐺(𝑡) for all 𝑡. Then the stochastic gradient (5) based on ?̃?(𝑡) will introduce noise, but no bias, on the learning of 𝜃: the average change in 𝜃 after a large number of time steps will reflect the true gradient direction. (This is true only if the noises on ?̃?(𝑡) at different times 𝑡 are sufficiently decorrelated. This is the case if the dynamical system (1) is sufficiently ergodic.) Such unbiasedness does not hold, for instance, if the gradient estimate is simply projected onto the nearest small-rank or diagonal plus small-rank approximation.5\nThe construction of an unbiased ?̃? is based on the following “rank-one trick”.\nProposition 1 (Rank-one trick). Given a decomposition of a matrix 𝐴 as a sum of rank-one outer products, 𝐴 = ∑︀ 𝑖 𝑣𝑖𝑤 ⊤ 𝑖 , and independent uniform random signs 𝜀𝑖 ∈ {−1, 1}, then\n𝐴 := ( ∑︀ 𝑖𝜀𝑖𝑣𝑖) (︁∑︀ 𝑗𝜀𝑗𝑤𝑗 )︁⊤\n(7)\nsatisfies E𝐴 = ∑︁ 𝑖 𝑣𝑖𝑤 ⊤ 𝑖 = 𝐴 (8)\nthat is, 𝐴 is an expectation-preserving rank-one approximation of 𝐴. Moreover, one can minimize the variance of 𝐴 by taking advantage of additional degrees of freedom in this decomposition, namely, one may first replace 𝑣𝑖 and 𝑤𝑖 with 𝜌𝑖𝑣𝑖 and 𝑤𝑖/𝜌𝑖 for any 𝜌𝑖 ∈ R*. The choice of 𝜌𝑖 which yields minimal variance of 𝐴 is when the norms of 𝑣𝑖 and 𝑤𝑖 become equal, namely, 𝜌𝑖 = √︀ ‖𝑤𝑖‖ / ‖𝑣𝑖‖.\n4One may use Kalman filtering either on 𝜃 alone or on the pair (𝜃, ℎ). In the first case, 𝜕ℓ𝑡 𝜕𝜃\nis explicitly needed. In the second case, all the information about how 𝜃 influences the current state ℎ(𝑡) is contained in the covariance between 𝜃 and ℎ, which the algorithm must maintain, and which is as costly as maintaining 𝐺(𝑡) above.\n5We tried such methods first, with less satisfying results. In practice, consecutive projections tend to interact badly and reduce too much the older contributions to the gradient.\nThe proof of the first statement is immediate. The statement about minimizing variance is proven in Appendix A. Minimizing variance thanks to 𝜌𝑖 is quite important in practice, see Section 1.3. The rank-one trick also extends to tensors of arbitrary order; this may be useful in more complex situations.6 The rank-one reduction 𝐴 depends, not only on the value of 𝐴, but also on the way 𝐴 is decomposed as a sum of rank-one terms. In the applications to recurrent networks below, there is a natural such choice.7\nWe use this reduction operation at each step of the dynamical system, to build an approximation ?̃? of 𝐺. A key property is that the evolution equation (4) satisfied by 𝐺 is affine, so that if ?̃?(𝑡) is an unbiased estimate of 𝐺(𝑡), then 𝜕𝑓(ℎ(𝑡),𝑥(𝑡),𝜃)𝜕ℎ ?̃?(𝑡) + 𝜕𝑓(ℎ(𝑡),𝑥(𝑡),𝜃) 𝜕𝜃 is an unbiased estimate of 𝐺(𝑡 + 1).\nThis leads to the NoBackTrack algorithm (Euclidean version) described in Algorithm 1. At each step, this algorithm maintains an approximation of 𝐺 as\n?̃? = 𝑣?̄?⊤+ ∑︁\n𝑖\n𝑒𝑖𝑤 ⊤ 𝑖 (9)\nwhere 𝑒𝑖 is the 𝑖-th basis vector in space ℎ, and 𝑤𝑖 := 𝜕𝑓𝑖𝜕𝜃 ⊤ are sparse vectors.\nTo understand this structure, say that ?̃?(𝑡 − 1) = 𝑣?̄?⊤ is a rank-one unbiased approximation of 𝐺(𝑡− 1). Then the evolution equation (4) for 𝐺 yields (︁ 𝜕𝑓 𝜕ℎ )︁ (︁ 𝑣?̄?⊤ )︁ + 𝜕𝑓𝜕𝜃 = (︁ 𝜕𝑓 𝜕ℎ𝑣 )︁ ?̄?⊤+ ∑︀ 𝑖 𝑒𝑖 𝜕𝑓𝑖 𝜕𝜃 as an approximation of ?̃?(𝑡). This new approximation is not rank-one any more, but it can be used to perform a gradient step on 𝜃, and then reduced to a rank-one approximation before the next time step.\nNote that handling 𝜕𝑓𝑖𝜕𝜃 is usually cheap: in many situations, only a small subset of the parameter 𝜃 directly influences each component ℎ𝑖(𝑡 + 1) given ℎ(𝑡), so that for each component 𝑖 of the state space, 𝜕𝑓𝑖𝜕𝜃 has few non-zero components. For instance, for a recurrent neural network with activities\n6The most symmetric way to do this is to use complex roots of unity, for instance, ∑︀\n𝑖 𝑢𝑖⊗ 𝑣𝑖 ⊗ 𝑤𝑖 = ERe (︁ ( ∑︀\n𝑖 𝜁𝑖𝑢𝑖)( ∑︀ 𝑗 𝜁𝑗𝑣𝑗)( ∑︀ 𝑘 𝜁𝑘𝑤𝑘) )︁ where each 𝜁𝑖 is taken independently at\nrandom among {1, e±2𝑖𝜋/3}. This involves complex numbers but there is no need to complexify the original dynamical system (1). Another, complex-free possibility is to apply the rank-one trick recursively to tensors of smaller order, for instance, ∑︀ 𝑖 𝑢𝑖⊗𝑣𝑖⊗𝑤𝑖⊗𝑥𝑖 =∑︀\n𝑖 (𝑢𝑖 ⊗ 𝑣𝑖)⊗ (𝑤𝑖 ⊗ 𝑥𝑖) = E\n[︁ ( ∑︀\n𝑖 𝜀𝑖𝑢𝑖 ⊗ 𝑣𝑖)( ∑︀ 𝑗 𝜀𝑗𝑤𝑗 ⊗ 𝑥𝑗) ]︁\nand then apply independent rank-one decompositions in turn to ∑︀ 𝑖 𝜀𝑖𝑢𝑖 ⊗ 𝑣𝑖 and to ∑︀ 𝑗\n𝜀𝑗𝑤𝑗 ⊗ 𝑥𝑗 . 7The rank-one trick may also be performed using random Gaussian vectors, namely 𝐴 = E[𝜉(𝜉⊤Σ−1𝐴)] with 𝜉 = 𝒩 (0, Σ). This version does not depend on a chosen decomposition of 𝐴, but depends on a choice of Σ. Variance can be much larger in this case: for instance, if 𝐴 = 𝑣𝑤⊤ is actually rank-one, then (𝜀𝑣)(𝜀𝑤⊤) = 𝑣𝑤⊤ so that the rank-one trick with random signs is exact, whereas the Gaussian version yields (𝜉𝜉⊤Σ−1)𝑣𝑤⊤ which is correct only in expectation. This case is particularly relevant because we are going to apply a reduction at each time step, thus working on objects that stay close to rank-one. The generalization to tensors is also more cumbersome in the Gaussian case.\n𝑎𝑖(𝑡) := sigm(ℎ𝑖(𝑡)) and evolution equation ℎ𝑖(𝑡 + 1) = 𝑏𝑖 + ∑︀\n𝑘 𝑟𝑖𝑘𝑥𝑘(𝑡) +∑︀ 𝑗 𝑊𝑗𝑖𝑎𝑗(𝑡), the derivative of ℎ𝑖(𝑡 + 1) with respect to the parameter 𝜃 = (𝑏, 𝑟, 𝑊 ) only involves the parameters 𝑏𝑖, 𝑟𝑖𝑘, 𝑊𝑗𝑖 of unit 𝑖. In such situations, the total cost of computing and storing all the 𝑤𝑖’s is of the same order as the cost of computing ℎ(𝑡 + 1) itself. See Section 1.3 for details on this example.\nAfter the reduction step of Algorithm 1, ?̄? may be interpreted as a “search direction” in parameter space 𝜃, while 𝑣 is an estimate of the effect on the current state ℎ(𝑡) of changing 𝜃 in the direction ?̄?. The search direction ?̄? evolves stochastically, but not fully at random, over time, so that on average 𝑣?̄?⊤ is a fair estimate of the actual influence of the parameter 𝜃.\nNote that in Algorithm 1, the non-recurrent output parameters 𝜙 are trained according to their exact gradient. The rank-one trick is used only for the recurrent part of the system.\nBy construction, at each step of Algorithm 1, the quantity ?̃?𝑡 := 𝑣?̄?⊤+∑︀ 𝑖 𝑒𝑖𝑤 ⊤ 𝑖 satisfies E?̃?𝑡 = 𝜕ℎ(𝑡) 𝜕𝜃 . However, since the value of 𝜃 changes along the algorithm, we must be careful about the meaning of this statement. Intuitively, this derivative with respect to 𝜃 is taken along the actual trajectory of parameters 𝜃𝑡 realized by the algorithm.\nMore formally, let 𝜃 = (𝜃0, . . . , 𝜃𝑡, . . .) be any sequence of parameters. Let 𝑓 be any function depending on this sequence 𝜃, such as the state of the system at time 𝑡 (all functions considered below will depend only on a finite initial segment of 𝜃). Define 𝜃 + 𝜀 := (𝜃0 + 𝜀, . . . , 𝜃𝑡 + 𝜀, . . .) and say that 𝑓 has derivative 𝜕𝑓𝜕𝜃 with respect to 𝜃 if 𝑓(𝜃 + 𝜀) = 𝑓(𝜃) + 𝜀 𝜕𝑓 𝜕𝜃 + 𝑂(𝜀\n2) for small 𝜀.\nThanks to this convention, the evolution equation (4) for the evolution of 𝐺(𝑡) holds for any sequence of parameters 𝜃, with 𝐺(𝑡) defined as 𝜕ℎ(𝑡)𝜕𝜃 . The following statement is then easily proved by induction.\nProposition 2 (Unbiased rank-one gradient estimate for dynamical systems). At each time step 𝑡, the quantity ?̃?𝑡 := 𝑣?̄?⊤ +∑︀\n𝑖 𝑒𝑖𝑤 ⊤ 𝑖 from Algorithm 1 is an unbiased estimate of the gradient of the state\nof the system with respect to the parameter:\nE?̃?𝑡 = 𝜕ℎ(𝑡)\n𝜕𝜃 (19)\nwhere 𝜃 is the sequence of parameters produced by the algorithm.\nIn particular, for learning rates 𝜂 tending to 0, the parameter evolves slowly so that the derivative 𝜕ℎ(𝑡)𝜕𝜃 is close to a derivative with respect to the current value 𝜃𝑡 of the parameter. Thus, in this regime, 𝜕ℎ(𝑡)𝜕𝜃 tends to 𝜕ℎ(𝑡) 𝜕𝜃𝑡\n, and since ?̃?𝑡 is an unbiased estimate of 𝐺𝑡, the situation gets closer and closer to an ordinary stochastic gradient descent if 𝜂 is small. Presumably\nParameters: ℎ(0) (initial state), 𝜃0, 𝜙0 (initial value of the internal and output parameters), 𝜂𝑡 (learning rate scheme); Data: 𝑥(𝑡) (input signal), 𝑦(𝑡) (output signal); Maintains: ℎ(𝑡) (current state), 𝜃, 𝜙 (internal and output parameters), 𝑣 (column vector of size dim ℎ), ?̄? (column vector of size dim 𝜃), 𝑤𝑖 (sparse column vectors of size dim 𝜃) for 𝑖 = 1, . . . , dim ℎ. Initialization: 𝜃 ← 𝜃0, 𝜙← 𝜙0, 𝑣 ← 0, ?̄? ← 0, 𝑤𝑖 ← 0; for 𝑡 = 0 to end-of-time do\nObservation step: Compute prediction 𝑦(𝑡) = 𝑌 (ℎ(𝑡), 𝜙) from current state ℎ(𝑡). Observe 𝑦(𝑡) and incur loss ℓ𝑡(𝑦(𝑡), 𝑦(𝑡)). Update step: Compute derivative of loss with respect to output parameters, 𝜕ℓ𝑡𝜕𝜙 = 𝜕ℓ𝑡(𝑌 (ℎ(𝑡),𝜙),𝑦(𝑡)) 𝜕𝜙 , and update output parameters:\n𝜙← 𝜙− 𝜂𝑡 𝜕ℓ𝑡 𝜕𝜙\n⊤ (10)\nCompute derivative of loss with respect to current state,\n𝐻 ← 𝜕ℓ𝑡 (𝑌 (ℎ(𝑡), 𝜙), 𝑦(𝑡)) 𝜕ℎ\n(11)\nUpdate internal parameters 𝜃:\n𝜃 ← 𝜃 − 𝜂𝑡 (𝐻𝑣)?̄? − 𝜂𝑡 ∑︀ 𝑖𝐻𝑖𝑤𝑖 (12)\n(this is a gradient step 𝜃 ← 𝜃 − 𝜂𝑡(𝐻?̃?)⊤ using the current gradient estimate ?̃? from (9)). Reduction step: Draw independent uniform random signs 𝜀𝑖 = ±1. Let 𝑒𝑖 be the 𝑖-th basis vector in state space. Compute 𝜌 := √︀ ‖?̄?‖ / ‖𝑣‖ and 𝜌𝑖 := √︀ ‖𝑤𝑖‖ / ‖𝑒𝑖‖ for each 𝑖. Update\n𝑣 ← 𝜌𝑣 + ∑︀\n𝑖𝜀𝑖𝜌𝑖𝑒𝑖 (13) ?̄? ← ?̄?/𝜌 + ∑︀ 𝑖𝜀𝑖𝑤𝑖/𝜌𝑖 (14) 𝑤𝑖 ← 0 (15)\nTransition step: Observe new value of input signal 𝑥(𝑡) and compute next state ℎ(𝑡 + 1) = 𝑓(ℎ(𝑡), 𝑥(𝑡), 𝜃). Update estimate ?̃?:\n𝑣 ← 𝜕𝑓(ℎ(𝑡), 𝑥(𝑡), 𝜃) 𝜕ℎ 𝑣 (16)\n𝑤𝑖 ← 𝜕𝑓𝑖(ℎ(𝑡), 𝑥(𝑡), 𝜃)\n𝜕𝜃\n⊤ (17)\n𝑡← 𝑡 + 1 (18)\nend Algorithm 1: NoBackTrack algorithm, Euclidean version.\nthis happens whenever the learning rate is small enough for 𝜃 not to change too much within a time range corresponding to a “forgetting time” of the dynamical system, although more work is needed here.\n1.2 Feeding the gradient estimate to an extended Kalman filter\nThe Euclidean version of the NoBackTrack algorithm presented in Algorithm 1 is not enough to obtain good performance fast. Online estimation often yields best results when using filters from the Kalman family. We refer to [Hay04, Jae02] for a discussion of Kalman filtering applied to recurrent neural networks.\nKalman-based approaches rely on a covariance matrix estimate 𝑃 (𝑡) on 𝜃. After observing 𝑦(𝑡), the parameter 𝜃 gets adjusted via8\n𝜃 ← 𝜃 − 𝑃 (𝑡)𝜕ℓ𝑡 𝜕𝜃\n⊤ (20)\nwhere the derivative of the loss with respect to 𝜃 is computed, as above, via the product of the derivative of the loss with respect to the current state ℎ(𝑡), and the derivative 𝐺(𝑡) = 𝜕ℎ(𝑡)𝜕𝜃 .\nMaintaining a full covariance matrix on 𝜃 is usually too costly. However, having a good approximation of 𝑃 (𝑡) is not as critical as having a good approximation of 𝜕ℓ𝑡𝜕𝜃 . Indeed, given an unbiased approximation of 𝜕ℓ𝑡 𝜕𝜃 , any symmetric positive definite matrix 𝑃 (𝑡) which changes slowly enough in time will yield an unbiased trajectory for 𝜃.\nThus, we will use more aggressive matrix reduction techniques on 𝑃 (𝑡), such as block-diagonal (as in [Hay04]) or quasi-diagonal [Oll15a] approximations. In our setting, the main point of using the covariance matrix is to get both a sensible scaling of the learning rate for each component of 𝜃, and reparametrization-invariance properties [Oll15a].\nIn Kalman filtering, in the case when the “true” underlying parameter 𝜃 in the extended Kalman filter is constant, it is better to work with the inverse covariance matrix 𝐽(𝑡) := 𝑃 (𝑡)−1, and the extended Kalman filter on 𝜃 can be rewritten as\n𝐽(𝑡)← 𝐽(𝑡− 1) + 𝜕𝑦𝑡 𝜕𝜃\n⊤ 𝐼𝑡\n𝜕𝑦𝑡 𝜕𝜃\n(21)\n𝜃 ← 𝜃 − 𝐽(𝑡)−1 𝜕ℓ𝑡 𝜕𝜃\n⊤ (22)\nwhere 𝑦𝑡 is the prediction at time 𝑡, where both 𝜕𝑦𝑡𝜕𝜃 and 𝜕ℓ𝑡 𝜕𝜃 can be computed from ℎ(𝑡) via the chain rule if 𝐺(𝑡) = 𝜕ℎ(𝑡)𝜕𝜃 is known, and where 𝐼𝑡 is the 8Indeed, in standard Kalman filter notation, one has 𝐾𝑡𝑅 = 𝑃𝑡𝐻⊤𝑡 , so that for the quadratic loss ℓ = 12 (𝑦 − 𝑦) ⊤𝑅−1(𝑦 − 𝑦) (log-loss of a Gaussian model with coraviance matrix 𝑅), the Kalman update for 𝜃 is equivalent to 𝜃 ← 𝜃 − 𝑃 (𝑡) 𝜕ℓ𝑡 𝜕𝜃 ⊤.\nFisher information matrix of 𝑦𝑡 as a probability distribution on 𝑦𝑡. (For exponential families this is just the Hessian −𝜕2ℓ𝑡\n𝜕𝑦2𝑡 of the loss with respect\nto the prediction). This is the so-called information filter, because 𝐽(𝑡) approximates the Fisher information matrix on 𝜃 given the observations up to time 𝑡. This is basically a natural gradient descent on 𝜃.\nThis approach is summarized in Algorithm 2, which we describe more loosely since matrix approximation schemes may depend on the application.\nAlgorithm 2 uses a decay factor (1−𝛾𝑡) on the inverse covariance matrices to limit the influence of old computations made with outdated values of 𝜃. The factor 𝛾𝑡 also controls the effective learning rate of the algorithm, since, in line with Kalman filtering, we have not included a learning rate for the update of 𝜃 (namely, 𝜂𝑡 = 1): the step size is adapted via the magnitude of 𝐽 . For 𝛾𝑡 = 0, 𝐽 grows linearly so that step size is 𝑂(1/𝑡).\nMoreover, we have included a regularization term Λ for matrix inversion; in the Bayesian interpretation of Kalman filtering this corresponds to having a Gaussian prior on the parameters with inverse covariance matrix Λ. This is important to avoid fast divergence in the very first steps.\nIn practice we have used 𝛾𝑡 = 𝑂(1/ √\n𝑡) and Λ = (dim ℎ). Id. The simplest and fastest way to approximate the Fisher matrix in Algorithm 2 is the outer product approximation (see discussion in [Oll15a]), which we have used in the experiments below. Namely, we simply use 𝐼𝑡 ← 𝜕ℓ𝑡𝜕𝑦𝑡 ⊤𝜕ℓ𝑡 𝜕𝑦𝑡 so that the updates to 𝐽𝜙 and 𝐽𝜃 simplify and become rank-one outer product updates using the gradient of the loss, namely, 𝐽𝜃 ← (1− 𝛾𝑡)𝐽𝜃 + 𝜕ℓ𝑡𝜕𝜃 ⊤𝜕ℓ𝑡 𝜕𝜃 and likewise for 𝜙. Here the derivative 𝜕ℓ𝑡𝜕𝜃 is estimated from the current gradient estimate ?̃?.\nFor the matrix reductions, we have used a block-wise quasi-diagonal reduction as in [Oll15a]. This makes the cost of handling the various matrices linear in the number of parameters."
        },
        {
            "heading": "1.3 Examples",
            "text": "Let us show how Algorithm 1 works out on explicit examples.\nThe importance of norm rescaling. Let us first consider a simple dynamical system which illustrates the importance of rescaling the norms by 𝜌 and 𝜌𝑖. Let 0 < 𝛼 < 1 and consider the system\nℎ(𝑡 + 1) = (1− 𝛼)ℎ(𝑡) + 𝜃 (28)\nwith both ℎ and 𝜃 in R𝑛. This quickly converges towards 𝜃/𝛼. We have 𝜕𝑓/𝜕ℎ = (1 − 𝛼) Id and 𝜕𝑓/𝜕𝜃 = Id and so 𝜕𝑓𝑖/𝜕𝜃⊤ = 𝑒𝑖, the 𝑖-th basis vector. Then the reduction and transition steps in Algorithm 1, if the scalings\nParameters: ℎ(0) (initial state), 𝜃0, 𝜙0 (initial value of the parameters), 0 6 𝛾𝑡 < 1 (covariance decay parameter scheme), Λ𝜙 and Λ𝜃 (inverse covariance matrix of the prior on the parameters); Maintains: Same as Algorithm 1, plus a representation of matrices 𝐽𝜃 and 𝐽𝜙 allowing for efficient inversion; Subroutines: A matrix reduction method MatrixReduce(𝑀) which only evaluates a small number of entries of its argument 𝑀 and returns an approximation of 𝑀 that can be inverted efficiently; A routine FisherApprox(𝑦𝑡, 𝑦𝑡) which returns either a positive definite approximation of the Fisher information matrix of 𝑦𝑡 as a probability distribution on 𝑦𝑡, or a positive definite approximation of the Hessian −𝜕2ℓ𝑡\n𝜕𝑦2𝑡 of the loss with respect to the prediction.\nInitialization: as in Algorithm 1, and 𝐽𝜃 ← 0, 𝐽𝜙 ← 0; for 𝑡 = 0 to end-of-time do\nObservation step: as in Algorithm 1. Update step: Compute approximate Fisher information matrix w.r.t. 𝑦𝑡:\n𝐼𝑡 ← FisherApprox(𝑦𝑡, 𝑦𝑡) (23)\nCompute derivative of prediction and of loss with respect to output parameters, 𝜕𝑦𝑡𝜕𝜙 and 𝜕ℓ𝑡 𝜕𝜙 . Update inverse covariance matrix of output parameters 𝜙:\n𝐽𝜙 ← (1− 𝛾𝑡)𝐽𝜙 + MatrixReduce (︃\n𝜕𝑦𝑡 𝜕𝜙\n⊤ 𝐼𝑡\n𝜕𝑦𝑡 𝜕𝜙\n)︃ (24)\nand update output parameters:\n𝜙← 𝜙− (𝐽𝜙 + Λ𝜙)−1 𝜕ℓ𝑡 𝜕𝜙\n⊤ (25)\nCompute derivative 𝜕𝑦𝑡𝜕ℎ of prediction with respect to current state ℎ(𝑡). Update inverse covariance matrix of internal parameters 𝜃:\n𝐽𝜃 ← (1− 𝛾𝑡)𝐽𝜃 + MatrixReduce (︃\n?̃?⊤ 𝜕𝑦𝑡 𝜕ℎ\n⊤ 𝐼𝑡\n𝜕𝑦𝑡 𝜕ℎ ?̃?\n)︃ (26)\nand update internal parameters 𝜃:\n𝜃 ← 𝜃 − (𝐽𝜃 + Λ𝜃)−1𝛿𝜃 (27)\nwhere 𝛿𝜃 := (𝐻𝑣)?̄? − ∑︀\n𝑖𝐻𝑖𝑤𝑖 is the update of 𝜃 from Algorithm 1. Reduction step: Same as in Algorithm 1, but the norms used to compute 𝜌 and 𝜌𝑖 are derived from 𝐽−1𝜃 (cf. Appendix B). Transition step: Same as in Algorithm 1.\nend Algorithm 2: NoBackTrack algorithm, Kalman version.\n𝜌 are not used, amount to\n𝑣𝑡+1 = (1− 𝛼) (𝑣𝑡 + ∑︀\n𝑖𝜀𝑖(𝑡)𝑒𝑖) (29) ?̄?𝑡+1 = ?̄?𝑡 + ∑︀ 𝑖𝜀𝑖(𝑡)𝑒𝑖 (30)\nwith the 𝜀𝑖(𝑡) independent at each step 𝑡. The resulting estimate of 𝜕ℎ(𝑡)/𝜕𝜃 is unbiased, but its variance grows linearly with time. Indeed, the dynamics of 𝑣𝑡 is stationary thanks to the factor (1 − 𝛼), but the dynamics of ?̄?𝑡 is purely additive so that 𝑤𝑡 is just a 𝑑-dimensional random walk. On the other hand, if rescaling by 𝜌 is used, then both 𝑣 and ?̄? get rescaled by √ 1− 𝛼 at each step,9 so that their dynamics becomes stationary and variance does not grow.\nRecurrent neural networks. The next example is a standard recurrent neural network (RNN). The state of the system is the set of pre-activation values ℎ𝑖(𝑡), and the activities are 𝑎𝑖(𝑡) := 𝜎(ℎ𝑖(𝑡)) where 𝜎 is some activation function such as tanh or sigmoid. The recurrent dynamics of ℎ is\nℎ𝑖(𝑡 + 1) = ∑︁ 𝑗→𝑖 𝑊𝑗𝑖 𝜎(ℎ𝑗(𝑡)) + ∑︁ 𝑙 𝑟𝑙𝑖𝑥𝑙(𝑡) (31)\nin which ℎ(𝑡), ℎ(𝑡+1) ∈ R𝑛, (𝑊𝑗𝑖)𝑗→𝑖 are a set of weights defining a graph on 𝑛 nodes, and (𝑟𝑙𝑖)(𝑖,𝑙) are the input weights.10 The parameter is 𝜃 = (𝑊, 𝑟). We hereby omit the output part of the network,11 as it is of no use to analyze the estimation of 𝜕ℎ(𝑡)/𝜕𝜃.\n(We have chosen the pre-activation values ℎ, rather than the activities 𝑎 = 𝜎(ℎ), as the state of the system. This results in simpler expressions, especially for the input weights 𝑟.)\nThus, the function 𝑓 defining the dynamical system for the variable ℎ is (31). The derivatives of 𝑓 are immediately computed as 𝜕𝑓𝑖/𝜕𝑊𝑗𝑖 = 𝜎(ℎ𝑗), 𝜕𝑓𝑖/𝜕𝑟𝑙𝑖 = 𝑥𝑙, 𝜕𝑓𝑖/𝜕ℎ𝑗 = 𝑊𝑗𝑖 𝜎′(ℎ𝑗), and all other derivatives are 0.\nAlgorithm 1 maintains, after the reduction step, an approximation 𝜕ℎ(𝑡)𝜕𝜃 ≈ 𝑣(𝑡)?̄?(𝑡)⊤. We can decompose ?̄?(𝑡) = (?̄? (𝑡), 𝑟(𝑡)) into the components corresponding to the internal and input weights of the parameter 𝜃 = (𝑊, 𝑟), so that\n𝜕ℎ𝑖(𝑡) 𝜕𝑊𝑘𝑗 ≈ 𝑣𝑖(𝑡)?̄?𝑘𝑗(𝑡) (32) 𝜕ℎ𝑖(𝑡) 𝜕𝑟𝑙𝑗 ≈ 𝑣𝑖(𝑡)𝑟𝑙𝑗(𝑡). (33)\n9Proof: By induction one has 𝑣 = ?̄? after the reduction step and 𝑣 = (1− 𝛼)?̄? after the transition step, and 𝜌 = 1/ √ 1− 𝛼.\n10Biases are omitted; they can be treated by the inclusion of an always-activated united 𝑖0 with 𝑎𝑖0 (𝑡) ≡ 1.\n11The experiments below use a softmax output with output parameters 𝜙, see Section 2.\nBy plugging the values of the partial derivatives of 𝑓 into Algorithm 1, we find the following update equations for the value of 𝑣, ?̄? and 𝑟 right after the reduction step:\n𝑣𝑖(𝑡 + 1) = 𝜌 ∑︁ 𝑗→𝑖 𝑊𝑗𝑖 𝜎 ′(ℎ𝑗(𝑡)) 𝑣𝑗(𝑡) + 𝜀𝑖𝜌𝑖 (34)\n?̄?𝑘𝑗(𝑡 + 0) = ?̄?𝑘𝑗(𝑡)\n𝜌 + 𝜀𝑗 𝜎(ℎ𝑘(𝑡)) 𝜌𝑗\n(35)\n𝑟𝑙𝑗(𝑡 + 1) = 𝑟𝑙𝑗(𝑡)\n𝜌 + 𝜀𝑗 𝑥𝑙(𝑡) 𝜌𝑗\n(36)\nwhere the 𝜀𝑗 are independent symmetric binary random variables, taking values ±1 with probability 12 . Any non-zero choice of 𝜌𝑗 leads to an unbiased estimation, though the values are to be optimized as mentioned above.\nApplying this update has the same algorithmic cost as implementing one step (31) of the recurrent network itself.\nLeaky recurrent neural networks. To capture long-term dependencies, in the experiments below we also use a leaky RNN, obtained via the addition of a direct feedback term:\nℎ𝑖(𝑡 + 1) = 𝛼𝑖ℎ𝑖(𝑡) + ∑︁\n𝑙\n𝑟𝑙𝑖𝑥𝑙(𝑡) + ∑︁\n𝑗\n𝑊𝑗𝑖𝑎𝑗(𝑡) 𝑎𝑗(𝑡) := 𝜎(ℎ𝑗(𝑡)) (37)\nwith 𝛼𝑖 ∈ [0; 1] for all 𝑖. (See [Jae02] for similar models.) This feedback term reduces the impact of the vanishing gradient issue and keeps a longer memory of past inputs.\nThis only changes the derivative of 𝑓𝑖 with respect to ℎ𝑗 , which becomes 𝜕𝑓𝑖/𝜕ℎ𝑗 = 𝑊𝑗𝑖𝜎′(ℎ𝑗) + 𝛼𝑖𝛿𝑖𝑗 . Consequently the update rules (35)–(36) for ?̄? and 𝑟 are unchanged, while the update of 𝑣 becomes\n𝑣𝑖(𝑡 + 1) = 𝜌𝛼𝑖𝑣𝑖(𝑡) + 𝜌 ∑︁ 𝑗→𝑖 𝑊𝑗𝑖 𝜎 ′(ℎ𝑗(𝑡)) 𝑣𝑗(𝑡) + 𝜀𝑖𝜌𝑖 (38)\nMultilayer recurrent neural networks. Let us now treat the case of a multilayer recurrent neural network with dynamics\nℎ(1)(𝑡 + 1) = 𝑓 (1)(𝑥(𝑡), ℎ(1)(𝑡), 𝜃1) (39) ℎ(2)(𝑡 + 1) = 𝑓 (2)(𝑥(𝑡), ℎ(1)(𝑡 + 1), ℎ(2)(𝑡), 𝜃2) (40) ... (41) ℎ(𝑛)(𝑡 + 1) = 𝑓 (𝑛)(𝑥(𝑡), ℎ(𝑛−1)(𝑡 + 1), ℎ(𝑛)(𝑡), 𝜃𝑛) (42)\nwhere each layer ℎ(𝑖) and 𝑓 (𝑖) define an RNN as in (31) above. Directly applying the rank-one approximation to the function 𝑓 = (𝑓 (1), 𝑓 (2), . . . , 𝑓 (𝑛))\nwould be cumbersome: since the activity of a neuron of the 𝑖-th layer at time 𝑡 + 1 depends on all parameters from the previous 𝑖− 1 layers, the derivative 𝜕𝑓/𝜕𝜃 is not sparse.\nTo cope with this, a natural approach is to treat the dynamics in a “rolling” fashion and apply the rank-one approximation at each layer in turn. Formally, this amounts to defining the following model\nℎ̃(1)(𝑛𝑡 + 1) = 𝑓 (1)(?̃?(𝑛𝑡), ℎ̃(1)(𝑛𝑡), 𝜃1) (43) ℎ̃(2)(𝑛𝑡 + 2) = 𝑓 (2)(?̃?(𝑛𝑡 + 1), ℎ̃(2)(𝑛𝑡 + 1), 𝜃2) (44) ... (45) ℎ̃(𝑛)(𝑛𝑡 + 𝑛) = 𝑓 (𝑛)(?̃?(𝑛𝑡 + 𝑛− 1), ℎ̃(𝑛)(𝑛𝑡 + 𝑛− 1), 𝜃𝑛) (46)\nwith ?̃?(𝑡) := 𝑥(⌊𝑡/𝑛⌋), and where states not explicitly appearing in these equations stay unchanged (ℎ(𝑖)(𝑛𝑡 + 𝑗) = ℎ(𝑖)(𝑛𝑡 + 𝑗 − 1) for 𝑖 ̸= 𝑗). Thus, the transition function explicitly depends on time (more precisely, on time modulo the number of layers), and is sparse at each step. Indeed, at each step, applying the transition function amounts to applying one of the 𝑓 (𝑖) to the corresponding layer, and leaving the other layers unchanged. Thus the derivative of 𝑓 (𝑖) with respect to any 𝜃𝑗 , 𝑗 ̸= 𝑖, is zero; this leaves only the gradient of 𝑓 (𝑖) wrt 𝜃𝑖 to be dealt with, and Algorithm 1 or 2 can be applied at little cost."
        },
        {
            "heading": "1.4 Extensions",
            "text": "Rank-𝐾 reductions. A first obvious extension is to use higher-rank reductions. The simplest way to achieve this is to take several independent random rank-one 𝑣𝑘?̄?⊤𝑘 reductions in (7) and average them. Note that 𝑤𝑖 (Algorithm 1) has to be evaluated only once in this case. It might be slightly more efficient to first split the parameter components into 𝐾 blocks (e.g., at random) so that the 𝑘-th term ?̄?⊤𝑘 only involves parameters from the 𝑘-th block: indeed, applying the evolution equation for 𝐺 preserves this structure so this requires less memory for storage of the ?̄?𝑘.\nAlgorithms similar to RTRL. Other algorithms have been proposed that have the same structure and shortcomings as real-time recurrent learning, for instance, the online EM algorithm for hidden Markov models from [Cap11]. In principle, the approach presented here can be extended to such settings.\nContinuous-time systems. Another extension concerns continuous-time dynamical systems\ndℎ(𝑡) d𝑡 = 𝐹 (ℎ(𝑡), 𝑥(𝑡), 𝜃) (47)\nwhich can be discretized as ℎ(𝑡 + 𝛿𝑡) = ℎ(𝑡) + 𝛿𝑡𝐹 (ℎ(𝑡), 𝑥(𝑡), 𝜃). Thus this is analogous to the discrete-time case via 𝑓 = Id +𝛿𝑡𝐹 , and Algorithm 1 may be applied to this discretization.\nWhen performing the rank-one reduction (7), the scaling by 𝜌𝑖 = √︀ ‖𝑤𝑖‖ / ‖𝑣𝑖‖\nis important in this case: it ensures that both 𝑣 and ?̄? change by 𝑂( √\n𝛿𝑡) times a random quantity at each step. This is the expected correct scaling for a continuous-time stochastic evolution equation, corresponding to the increment of a Wiener process during a time interval 𝛿𝑡. (Without scaling by 𝜌𝑖, there will be no well-defined limit as 𝛿𝑡 → 0, because 𝑣 would change by 𝑂(1) at each step 𝑡← 𝑡 + 𝛿𝑡, while ?̄? would evolve by 𝛿𝑡 times a centered random quantity so that it would be constant in the limit.) Further work is needed to study this continuous-time limit."
        },
        {
            "heading": "2 Experiments",
            "text": "We report here a series of small-scale experiments on text prediction tasks. The experiments focus on two questions: First, does learning using the rank-one approximation ?̃? accurately reflect learning based on the actual gradient 𝐺 computed exactly via RTRL, or is the noise introduced in this method detrimental to learning? Second, how does this approach compare to truncated backpropagation through time?\nWe used the RNN or leaky RNN models described above to predict a sequence of characters 𝑦(𝑡) in a finite alphabet 𝒜, given the past observations 𝑥(𝑠) = 𝑦(𝑠) for 1 6 𝑠 6 𝑡 − 1. At each time, the network outputs a probability distribution on the next character 𝑧; explicitly, the output at time 𝑡 is 𝑦(𝑡) ∈ R𝒜 defined by\n𝑦(𝑡)𝑧 := 𝜙𝑧 + ∑︁\n𝑖\n𝜙𝑖𝑧𝑎𝑖(𝑡) (48)\nfor each 𝑧 ∈ 𝒜, with parameters 𝜙 = (𝜙𝑧, 𝜙𝑖𝑧)𝑖,𝑧. The output 𝑦 = (𝑦𝑦)𝑦∈𝒜 defines a probability distribution on 𝒜 via a softmax 𝑝𝑦(𝑦) := 𝑒 𝑦𝑦∑︀ 𝑧∈𝐴𝑙 𝑒 𝑦𝑧 , and the loss function is the log-loss on prediction of the next character, ℓ𝑡 := − log2 𝑝𝑦(𝑡)(𝑦(𝑡)). The internal and output parameters 𝜃 and 𝜙 are trained according to Algorithms 1 and 2.\nWe used three datasets. The first is a “text” representing synthetic music notation with several syntactic, rhythmic and harmonic constraints (Example 3 from [Oll15b]). The data was a file of length ≈ 105 characters, after which the signal cycled over the same file. The second dataset is the classical 𝑎𝑛𝑏𝑛 example, synthesized by repeatedly picking an integer 𝑛 at random in some interval, then outputting a series of 𝑛 𝑎’s followed by a line break, then 𝑛 𝑏’s and another line break. This model tests the ability of a learning algorithm to learn precise timing and time dependencies. The\nthird example is the full set of Shakespeare’s works, obtained from Project Gutenberg.12 The file is roughly 5.106 characters long.\nThe benchmarks included are gzip, a standard non-online compression algorithm, and context tree weighting (CTW) [BEYY04], a more advanced online text compression algorithm, as well as the actual entropy rate of the generative model for synthetic music and 𝑎𝑛𝑏𝑛.\nThe code used in the experiments is available at http://www.yann-ollivier. org/rech/code/nobacktrack/code_nobacktrack_exp.tar.gz\nEuclidean NoBackTrack. We first study whether the low rank approximation in the Euclidean version of NoBackTrack impacts the gradient descent. For this first set of experiments, we use a fully connected RNN with 20 units, as described above, on the synthetic music example. We compared RTRL, Euclidean rank-one NoBackTrack, and Euclidean NoBackTrack using ranktwo and rank-ten reductions (obtained by averaging two or ten independent rank-one reductions, as discussion in Section 1.4).\nThe results are summed up in Figure 1 and Figure 2. All the models were trained using the same learning rate 𝜂𝑡 = 1/ √ 𝑡 for Figure 1 and 𝜂𝑡 = 0.03/ √ 𝑡 for Figure 2. The various algorithms were run for the same amount of time. This is reflected in the different curve lengths for the different algorithms; in particular, the curve for RTRL is much shorter, reflecting its higher computational cost. (Note the log scale on the 𝑡 axis: RTRL is roughly 20 times slower with 20 units.)\nThe impact of stochasticity of the low-rank approximation when using large learning rates is highlighted on Figure 1: Euclidean NoBackTrack with a large learning rate displays instabilities, even when increasing the rank of the approximation.\nSmaller learning rates allow the algorithm to cope with this, as the noise in the gradients is averaged out over longer time spans. This is illustrated in Figure 2, in which the trajectories of Euclidean NoBackTrack track those of RTRL closely even with a rank-two approximation.\nKalman NoBackTrack. Next, we report the results of the Kalman version of NoBackTrack on the same experimental setup. A quasi-diagonal outer product (QDOP) approximation [Oll15a] of the full Kalman inverse covariance matrix is used, to keep complexity low.\nWe compare the low-rank approximations to RTRL. To make the comparison clear, for RTRL we also use a quasi-diagonal (QDOP) approximation of the Kalman filtering algorithm on top of the exact gradient computed by RTRL.\n12www.gutenberg.org\nLearning rates were set to 1 and all algorithms were run for the same amount of time.\nThe use of the QDOP-approximated Kalman inverse covariance appears to fully fix the unstable behaviour. Overall, low-rank approximations appear to be roughly on par with QDOP RTRL. There is no obvious gain, on this particular example, in using higher-rank approximations.\nStill, on this particular task and with this particular network size, none of the RNN algorithms (including BPTT reported below) match the performance of Context Tree Weighting. RNNs beat CTW on this task if trained using a non-online, Riemannian gradient descent [Oll15b] (analogous to using the Kalman inverse covariance). So this is arguably an effect of imperfect online RNN training.\nKalman NoBackTrack and truncated BPTT. Our next set of experiments aims at comparing Kalman NoBackTrack to truncated BPTT, with truncation13 parameter 𝑇 = 15. As BPTT truncates the full gradient by\n13In the version of BPTT used here, the algorithm does not backtrack by 𝑇 steps at every time step 𝑡; rather, it waits for 𝑇 steps between 𝑡 and 𝑡 + 𝑇 , then backtracks by 𝑇 steps and collects all gradients in this interval. Otherwise, truncated BPTT would be 𝑇 times slower, which was unacceptable for our experiments.\nremoving dependencies at distances longer than the truncation parameter, we expect Kalman NoBackTrack to learn better models on datasets presenting long term correlations.\nThe two algorithms are first compared on the synthetic music dataset, with the same experimental setup as above, for the same amount of time, with a learning rate 𝜂𝑡 = 1/ √ 𝑡 for truncated BPTT and 𝛾𝑡 = 1/ √ 𝑡 for Kalman NoBackTrack.14 The results are shown in Figure 4. On this example, truncated BPTT perfoms better than Kalman NoBackTrack, even though the two algorithms display broadly comparable performance. Noticeably, RTRL and truncated BPTT are roughly on par here, with truncated BPTT slightly outperforming RTRL in the end: apparently, maintaining long term dependencies in gradient calculations does not improve learning in this synthetic music example.\nNext, to compare NoBackTrack and truncated BPTT on their specific ability to learn precise middle and long term dependencies, we present experiments on the 𝑎𝑛𝑏𝑛 example. This will clearly illustrate the biased nature of the gradients computed by truncated BPTT.\n14These learning rates have different meanings for Kalman NoBackTrack and truncated BPTT, and are not directly comparable.\nThe 𝑎𝑛𝑏𝑛[𝑘;𝑙] dataset is synthesized by sequentially picking a number 𝑛 between 𝑘 and 𝑙 uniformly at random, then outputting a series of 𝑛 𝑎’s followed by a line break, then 𝑛 𝑏’s and another line break. The true entropy rate is log2(𝑙−𝑘+1)𝑙+𝑘+2 in this example.\n15 A roughly 106 character long input sequence was synthesized, using [𝑘; 𝑙] = [1; 32].\nAs standard RNN models do not seem to be able to deal with this example, whatever the training algorithm, we used a leaky RNN16 as presented in Section 1.3, again with 20 fully connected units. All the algorithms used a learning rate of 1/ √ 𝑡. The results are reported on Figure 5, which also includes the entropy rate of the exact 𝑎𝑛𝑏𝑛 model and the (twice larger) entropy rate of an 𝑎𝑛𝑏𝑝 model with independent 𝑛 and 𝑝.\nKalman NoBackTrack clearly outperforms truncated BPTT on this dataset. This was to be expected, as the typical time range of the temporal dependencies exceeds the truncation range for BPTT, so that the\n15Indeed, log2(𝑙 − 𝑘 + 1) bits are needed to encode the value of 𝑛 in each 𝑎𝑛𝑏𝑛 block (this is the entropy of a uniform distribution on {𝑘, . . . , 𝑙}), and the average value of 𝑛 is (𝑘 + 𝑙)/2 so that the average length of an 𝑎𝑛𝑏𝑛 block, including the two newline symbols, is 2× (𝑙 + 𝑘)/2 + 2.\n16The parameter 𝛼 of the LRNN can be learned, but this sometimes produces numerical instabilities unless cumbersome changes of variables are introduced. We just initialized 𝛼 to a random value separately for each unit and kept it fixed.\napproximated gradients computed by truncated BPTT are significantly biased.\nKeeping track of the long term dependencies is key here, and RTRL outperforms all the algorithms epochwise, though it is still penalized by its high complexity. Truncated BPTT is unable to learn the full dependencies between 𝑎’s and 𝑏’s, and ends up closer to the entropy of an 𝑎𝑛𝑏𝑝 model with independent values of 𝑛 and 𝑝 (presumably, it still manages to learn the 𝑎𝑛𝑏𝑛 blocks where 𝑛 is short). At some point the learning curve of truncated BPTT appears not to decrease anymore and even goes slightly up, which is consistent with a biased gradient estimate.\nOn the other hand, Kalman NoBackTrack seems to be mostly successful in learning the dependencies. This is confirmed by visual inspection of the output of the learned model. The small remaining gap between the true model and the learned model could be related to incomplete training, or to an imperfect modelling of the exact uniform law for 𝑛 ∈ [𝑘; 𝑙].\nFinally, we report performance of truncated BPTT and Kalman NoBackTrack on Shakespeare’s works. The same 20-unit RNN model is used, again with all algorithms run for the same amount of time using the same learning rate 1/ √ 𝑡. The curves obtained are displayed in Figure 6.\nOn this example, RTRL, truncated BPTT, and Kalman NoBackTrack\nwith various ranks all have a similar performance; it is not clear whether the differences on Figure 6 are statistically significant. This proves, once more, that the stochasticity and rank reduction inherent to NoBackTrack are not detrimental to learning, and allow it to keep up with exact gradient algorithms.\nAll RNN algorithms have a significantly worse performance than CTW on this example, thus proving that a 20-unit RNN does not accurately model Shakespeare’s works.\nConclusion. We have introduced an algorithm that computes a stochastic, provably unbiased estimate of the derivative of the current state of a dynamical system with respect to its parameters, in a fully online fashion. For recurrent neural networks, the computational cost of this algorithm is comparable to that of running the network itself. Previously known algorithms were either not fully online or had a significantly higher computational cost.\nIn our experiments, this algorithm appears as a practical alternative to truncated backpropagation through time, especially in its Kalman version, while the Euclidean version requires smaller learning rates. The (unbiased) noise and rank reduction introduced in the gradient approximation do not appear to prevent learning. The interest of NoBackTrack with respect to truncated BPTT depends on the situation at hand, especially on the scale of time dependencies in the data (which results in biased gradient estimates for BPTT), and on whether the storage of past states and past data required by truncated BPTT is acceptable or not.\nAcknowledgments. The authors would like to thank Hugo Larochelle for his helpful questions that resulted in several clarifications of the text.\nA Variance of the rank-one trick Keep the notation of Proposition 1 and let ‖·‖ be a Euclidean norm on the vector space in which the 𝑣𝑖 and 𝑤𝑖 live.\nTo measure the variance of 𝐴 we use the Hilbert–Schmidt norm ⃦⃦ 𝐴 ⃦⃦2\nHS := Tr(𝐴⊤𝐴). This norm satisfies ⃦⃦ 𝑣𝑤⊤⃦⃦ HS = ‖𝑣‖ ‖𝑤‖, and ⟨︀ 𝑣1𝑤 ⊤ 1 | 𝑣2𝑤⊤2 ⟩︀ HS = ⟨ 𝑣1 | 𝑣2 ⟩ ⟨𝑤1 | 𝑤2 ⟩ for the associated scalar product. Let us evaluate the variance of 𝐴 in this norm. Since Var 𝐴 = E ⃦⃦ 𝐴 ⃦⃦2 HS− ⃦⃦ E𝐴 ⃦⃦2\nHS and E𝐴 = 𝐴 is fixed, it is enough to evaluate the second moment E ⃦⃦ 𝐴 ⃦⃦2\nHS. We claim that\nE ⃦⃦ 𝐴 ⃦⃦2 HS = ( ∑︁\n𝑖\n‖𝑣𝑖‖2)( ∑︁\n𝑗\n‖𝑤𝑗‖2) + 2 ∑︁\n𝑖 ∑︁ 𝑗 ̸=𝑖 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩ (49)\nIndeed, 𝐴 = ∑︀\n𝑖𝑗 𝜀𝑖𝜀𝑗𝑣𝑖𝑤 ⊤ 𝑗 so, by bilinearity of the Hilbert–Schmidt scalar product,\nE ⃦⃦ 𝐴 ⃦⃦2 HS = E ⟨︀ 𝐴 | 𝐴 ⟩︀ HS = E ∑︁ 𝑖𝑗𝑘𝑙 𝜀𝑖𝜀𝑗𝜀𝑘𝜀𝑙 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑘 | 𝑤𝑙 ⟩ (50)\nSince E𝜀𝑖 = 0 and E(𝜀𝑖𝜀𝑗) = 0 for 𝑖 ̸= 𝑗, the only cases to consider are: 1. 𝑖 = 𝑗 and 𝑘 = 𝑙 and 𝑖 ̸= 𝑘: contribution ∑︀\n𝑖 ∑︀ 𝑘 ̸=𝑖 ‖𝑣𝑖‖ 2 ‖𝑤𝑘‖2\n2. 𝑖 = 𝑘 and 𝑗 = 𝑙 and 𝑖 ̸= 𝑗: contribution ∑︀\n𝑖 ∑︀ 𝑗 ̸=𝑖 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩\n3. 𝑖 = 𝑙 and 𝑗 = 𝑘 and 𝑖 ̸= 𝑗: same contribution as the previous one 4. 𝑖 = 𝑗 = 𝑘 = 𝑙: contribution ∑︀\n𝑖 ‖𝑣𝑖‖ 2 ‖𝑤𝑖‖2\n5. all other cases contribute 0. The first and fourth contributions add up to ( ∑︀ 𝑖 ‖𝑣𝑖‖ 2)( ∑︀ 𝑘 ‖𝑤𝑘‖ 2). This proves (49). Let us minimize variance over the degrees of freedom given by 𝑣𝑖𝑤⊤𝑖 = (𝜌𝑖𝑣𝑖)(𝑤𝑖/𝜌𝑖)⊤.\n𝜌𝑖 does not change the last contribution to E ⃦⃦ 𝐴 ⃦⃦2\nHS in (49), neither does it change the expectation E𝐴 = 𝐴, so to minimize the variance we only have to minimize the first term ( ∑︀ 𝑖 ‖𝑣𝑖‖ 2)( ∑︀ 𝑘 ‖𝑤𝑘‖ 2). Applying the scaling, this term becomes\n( ∑︁\n𝑖\n‖𝑣𝑖‖2 𝜌2𝑖 )( ∑︁\n𝑘\n‖𝑤𝑘‖2 /𝜌2𝑘) (51)\nand, by differentiation with respect to a single 𝜌𝑖, one checks that this is minimal for 𝜌𝑖 ∝ √︀ ‖𝑤𝑖‖ / ‖𝑣𝑖‖ (52)\n(mutliplying all 𝜌𝑖’s by a common factor does not change the result). So, after optimal scaling,\n𝐴 = (︃∑︁\n𝑖\n𝜀𝑖𝑣𝑖 √︀ ‖𝑤𝑖‖ / ‖𝑣𝑖‖ )︃ ⊗ (︃∑︁ 𝑖 𝜀𝑖𝑤𝑖 √︀ ‖𝑣𝑖‖ / ‖𝑤𝑖‖ )︃ (53)\nConsequently, after scaling, the first term in the variance of 𝐴 in (49) becomes ( ∑︀\n𝑖 ‖𝑣𝑖‖ ‖𝑤𝑖‖)2. The second term in (49) does not change. Thus, after optimal scaling we find\nE ⃦⃦ 𝐴 ⃦⃦2 HS = (︃∑︁\n𝑖\n‖𝑣𝑖‖ ‖𝑤𝑖‖ )︃2 + 2\n∑︁ 𝑖 ∑︁ 𝑗 ̸=𝑖 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩ (54)\nTo obtain the variance of 𝐴, we just subtract the square norm of E𝐴 = 𝐴, which is\n‖𝐴‖2HS = ⃦⃦⃦⃦ ⃦∑︁\n𝑖\n𝑣𝑖𝑤 ⊤ 𝑖 ⃦⃦⃦⃦ ⃦ 2\nHS\n= ∑︁\n𝑖\n⃦⃦ 𝑣𝑖𝑤 ⊤ 𝑖 ⃦⃦2 HS + ∑︁ 𝑖 ∑︁ 𝑗 ̸=𝑖 ⟨︀ 𝑣𝑖𝑤 ⊤ 𝑖 | 𝑣𝑗𝑤⊤𝑗 ⟩︀ HS (55)\n(by bilinearity of the Hilbert–Schmidt scalar product)\n= ∑︁\n𝑖\n‖𝑣𝑖‖2 ‖𝑤𝑖‖2 + ∑︁\n𝑖 ∑︁ 𝑗 ̸=𝑖 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩ (56)\nThis yields, after optimal scaling,\nVar 𝐴 = (︃∑︁\n𝑖\n‖𝑣𝑖‖ ‖𝑤𝑖‖ )︃2 − ∑︁\n𝑖\n‖𝑣𝑖‖2 ‖𝑤𝑖‖2 + ∑︁\n𝑖 ∑︁ 𝑗 ̸=𝑖 ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩ (57)\n= ∑︁\n𝑖 ∑︁ 𝑗 ̸=𝑖 ‖𝑣𝑖‖ ‖𝑣𝑗‖ ‖𝑤𝑖‖ ‖𝑤𝑗‖+ ⟨ 𝑣𝑖 | 𝑣𝑗 ⟩ ⟨𝑤𝑖 | 𝑤𝑗 ⟩ (58)\nB Invariant norms derived from the Kalman covariance\nAlgorithm 2 is built to offer invariance properties (a Kalman filter over a variable 𝜃 is invariant by affine reparameterization of 𝜃, for instance). However, this only holds if the norms ‖𝑣‖, ‖?̄?‖, ‖𝑣𝑖‖, ‖𝑤𝑖‖, used to compute the scaling factors 𝜌 = √︀ ‖?̄?‖ / ‖𝑣‖\nand 𝜌𝑖 = √︀ ‖𝑤𝑖‖ / ‖𝑒𝑖‖, are themselves reparameterization-invariant.\nThis can be achieved if we decide to choose the scalings 𝜌 as to minimize the variance of ?̃? computed in the (Mahalanobis) norm defined by the covariance matrix of 𝜃 and of ℎ appearing in the Kalman filter.\nLet 𝐶𝜃 be the covariance matrix of 𝜃 obtained in the Kalman filter; in Algorithm 2, 𝐶𝜃 is approximated by 𝐶𝜃 ≈ 𝐽−1𝜃 .\nAny linear form on 𝜃, such as ?̄? and 𝑤𝑖, can be given a norm by\n‖?̄?‖2 := ?̄?⊤𝐶𝜃?̄? ≈ ?̄?⊤𝐽−1𝜃 ?̄? (59)\nand likewise for 𝑤𝑖. This norm is invariant under 𝜃-reparameterization. Given the covariance 𝐶𝜃 of 𝜃 and the dependency 𝐺 = 𝜕ℎ𝜕𝜃 of ℎ with respect to 𝜃, the covariance of ℎ is 𝐶ℎ := 𝐺𝐶𝜃𝐺⊤ (60) and its inverse 𝐽ℎ := 𝐶−1ℎ can be used to define a norm for a tangent vector 𝑣 at state ℎ via ‖𝑣‖2 := 𝑣⊤𝐽ℎ𝑣 (61) which is also reparametrization-invariant. (We use 𝐽−1𝜃 for the norm of 𝑤 and 𝐽ℎ for the norm of 𝑣 because 𝑣 is a tangent vector (covariant) at point ℎ, while 𝑤 is a linear form (contravariant) at point 𝜃.)\nHowever, handling of full covariance matrices would be too costly. In Algorithm 2, the inverse covariance 𝐽𝜃 of 𝜃 is already an approximation (diagonal, quasi-diagonal...) via MatrixReduce. Moreover, here we only have access to an approximation ?̃? of 𝐺. Thus, we simply replace 𝐺 with ?̃? in the definition of 𝐶ℎ, and use a diagonal reduction. This leads to 𝐶ℎ ≈ Diag(?̃?𝐽−1𝜃 ?̃?⊤) and\n𝐽ℎ ≈ (︀ Diag(?̃?𝐽−1𝜃 ?̃? ⊤) )︀−1 (62)\nwhere as usual ?̃? is the gradient approximation given by (9). The diagonal reduction is necessary if ?̃? is low-rank, since ?̃?𝐽−1𝜃 ?̃?⊤ will be low-rank as well, and thus non-invertible. Then the scaling factors 𝜌 and 𝜌𝑖 can finally be computed as\n𝜌 = √︃ ‖?̄?‖ ‖𝑣‖ = (?̄?⊤𝐽−1𝜃 ?̄?)1/4(︀∑︀\n𝑖(?̃?𝐽 −1 𝜃 ?̃? ⊤)−1𝑖𝑖 𝑣2𝑖 )︀1/4 (63)\nand\n𝜌𝑖 = √︃ ‖𝑤𝑖‖ ‖𝑒𝑖‖ = (𝑤⊤𝑖𝐽−1𝜃 𝑤𝑖)1/4(︀\n(?̃?𝐽−1𝜃 ?̃?⊤) −1 𝑖𝑖 )︀1/4 (64) The particular structure of 𝐽𝜃 (if approximated by, e.g., a block-diagonal matrix) and of ?̃? = 𝑣?̄?⊤+ ∑︀ 𝑖 𝑒𝑖𝑤 ⊤ 𝑖 make these computations efficient.\nNote that even with the approximations above, ?̃? is still an unbiased estimate of 𝐺. Indeed, any choice of 𝜌 has this property; we are simply approximating the optimal 𝜌 which minimizes the variance of ?̃?.\nIn practice, small regularization terms are included in the denominator of every division and inversion to avoid numerical overflow."
        }
    ],
    "title": "Training recurrent networks online without backtracking",
    "year": 2015
}