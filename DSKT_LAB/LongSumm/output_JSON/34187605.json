{
    "abstractText": "The practical performance of online stochastic gradient descent algorithms is highly dependent on the chosen step size, which must be tediously hand-tuned in many applications. The same is true for more advanced variants of stochastic gradients, such as SAGA, SVRG, or AdaGrad. Here we propose to adapt the step size by performing a gradient descent on the step size itself, viewing the whole performance of the learning trajectory as a function of step size. Importantly, this adaptation can be computed online at little cost, without having to iterate backward passes over the full data. Introduction This work aims at improving gradient ascent procedures for use in machine learning contexts, by adapting the step size of the descent as it goes along. Let l0, l1, . . . , lt, . . . be functions to be maximised over some parameter space Θ. At each time t, we wish to compute or approximate the parameter θ∗ t ∈ Θ that maximizes the sum Lt(θ) := ∑ s≤t ls(θ). (1) In the experiments below, as in many applications, lt(θ) writes l(xt, θ) for some data x0, x1, . . . , xt, . . . A common strategy, especially with large data size or dimensionality [Bot10], is the online stochastic gradient ascent (SG) θt+1 = θt + η ∂θlt(θt) (2) with step size η, where ∂θlt stands for the Euclidean gradient of lt with respect to θ. Such an approach has become a mainstay of both the optimisation and machine learning communities [Bot10]. Various conditions for convergence exist, starting with the celebrated article of Robbins and Monro [RM51], or later [KC78]. Other types of results are proved in convex settings, Several variants have since been introduced, in part to improve the convergence of the algorithm, which is much slower in stochastic than than in 1 deterministic settings. For instance, algorithms such as SAGA, Stochastic Variance Reduced Gradient (SVRG) or Stochastic Average Gradient (SAG) [DBLJ14, JZ13, SLRB13], perform iterations using a comparison between the latest gradient and an average of past gradients. This reduces the variance of the resulting estimates and allows for nice convergence theorems [DBLJ14, SLRB13], provided a reasonable step size η is used. Influence of the step size. The ascent requires a parameter, the step size η, usually called “learning rate” in the machine learning community. Empirical evidence highligting the sensitivity of the ascent to its actual numerical value exists aplenty; see for instance the graphs in Section 3.2.1. Slow and tedious hand-tuning is therefore mandatory in most applications. Moreover, admittable values of η depend on the parameterisation retained—except for descents described in terms of Riemannian metrics [Ama98], which provide some degree of parameterisation-invariance. Automated procedures for setting reasonable value of η are therefore of much value. For instance, AdaGrad [DHS11] divides the derivative ∂θlt by a root mean square average of the magnitude of its recent values, so that the steps are of size approximately 1; but this still requires a “master step size” η. Shaul, Zhang and LeCun in [SZL13] study a simple separable quadratic loss model and compute the value of η which minimises the expected loss after each parameter update. This value can be expressed in terms of computable quantities depending on the trajectory of the descent. These quantities still make sense for non-quadratic models, making this idea amenable to practical use. More recently, Maclaurin, Douglas and Duvenaud [MDA15] propose to directly conduct a gradient ascent on the hyperparameters (such as the learning rate η) of any algorithm. The gradients with respect to the hyperparameters are computed exactly by “chaining derivatives backwards through the entire training procedure” [MDA15]. Consequently, this approach is extremely impractical in an online setting, as it optimizes the learning rate by performing several passes, each of which goes backwards from time t to time 0. Finding the best step size. The ideal value of the step size η would be the one that maximizes the cumulated objective function (1). Write θt(η) for the parameter value obtained after t iterations of the gradient step (2) using a given value η, and consider the sum",
    "authors": [
        {
            "affiliations": [],
            "name": "Pierre-Yves Massé"
        },
        {
            "affiliations": [],
            "name": "Yann Ollivier"
        }
    ],
    "id": "SP:2179168549f23f0fe0e883000865fad6386dd1c4",
    "references": [
        {
            "authors": [
                "Shun-ichi Amari"
            ],
            "title": "Natural gradient works efficiently in learning",
            "venue": "Neural Comput.,",
            "year": 1998
        },
        {
            "authors": [
                "Léon Bottou"
            ],
            "title": "Large-scale machine learning with stochastic gradient descent",
            "venue": "In Proceedings of COMPSTAT’2010,",
            "year": 2010
        },
        {
            "authors": [
                "John Duchi",
                "Elad Hazan",
                "Yoram Singer"
            ],
            "title": "Adaptive subgradient methods for online learning and stochastic optimization",
            "venue": "The Journal of Machine Learning Research,",
            "year": 2011
        },
        {
            "authors": [
                "Rie Johnson",
                "Tong Zhang"
            ],
            "title": "Accelerating Stochastic Gradient Descent using Predictive Variance Reduction",
            "venue": "Advances in Neural Information Processing Systems",
            "year": 2013
        },
        {
            "authors": [
                "Harold J. Kushner",
                "Dean S. Clark"
            ],
            "title": "Stochastic Approximation Methods for Constrained and Unconstrained Systems, volume 26 of Applied Mathematical Sciences",
            "year": 1978
        },
        {
            "authors": [
                "Douglas Maclaurin",
                "David Duvenaud",
                "Ryan Adams"
            ],
            "title": "Gradient-based hypermarameter optimization through reversible learning",
            "venue": "Proceedings of The 32nd International Conference on Machine Learning,",
            "year": 2015
        },
        {
            "authors": [
                "Herbert Robbins",
                "Sutton Monro"
            ],
            "title": "A stochastic approximation method",
            "venue": "The Annals of Mathematical Statistics,",
            "year": 1951
        },
        {
            "authors": [
                "Mark Schmidt",
                "Nicolas Le Roux",
                "Francis Bach"
            ],
            "title": "Minimizing finite sums with the stochastic average gradient",
            "venue": "Technical Report 00860051,",
            "year": 2013
        },
        {
            "authors": [
                "Tom Schaul",
                "Sixin Zhang",
                "Yann LeCun"
            ],
            "title": "No More Pesky Learning Rates",
            "venue": "Proceedings of The 30th International Conference on Machine Learning,",
            "year": 2013
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :1\n51 1.\n02 54\n0v 1\n[ m\nat h.\nO C\n] 8\nN ov\n2 01\nIntroduction\nThis work aims at improving gradient ascent procedures for use in machine learning contexts, by adapting the step size of the descent as it goes along.\nLet ℓ0, ℓ1, . . . , ℓt, . . . be functions to be maximised over some parameter space Θ. At each time t, we wish to compute or approximate the parameter θ∗t ∈ Θ that maximizes the sum\nLt(θ) := ∑\ns≤t ℓs(θ). (1)\nIn the experiments below, as in many applications, ℓt(θ) writes ℓ(xt, θ) for some data x0, x1, . . . , xt, . . .\nA common strategy, especially with large data size or dimensionality [Bot10], is the online stochastic gradient ascent (SG)\nθt+1 = θt + η ∂θℓt(θt) (2)\nwith step size η, where ∂θℓt stands for the Euclidean gradient of ℓt with respect to θ.\nSuch an approach has become a mainstay of both the optimisation and machine learning communities [Bot10]. Various conditions for convergence exist, starting with the celebrated article of Robbins and Monro [RM51], or later [KC78]. Other types of results are proved in convex settings,\nSeveral variants have since been introduced, in part to improve the convergence of the algorithm, which is much slower in stochastic than than in\ndeterministic settings. For instance, algorithms such as SAGA, Stochastic Variance Reduced Gradient (SVRG) or Stochastic Average Gradient (SAG) [DBLJ14, JZ13, SLRB13], perform iterations using a comparison between the latest gradient and an average of past gradients. This reduces the variance of the resulting estimates and allows for nice convergence theorems [DBLJ14, SLRB13], provided a reasonable step size η is used.\nInfluence of the step size. The ascent requires a parameter, the step size η, usually called “learning rate” in the machine learning community. Empirical evidence highligting the sensitivity of the ascent to its actual numerical value exists aplenty; see for instance the graphs in Section 3.2.1. Slow and tedious hand-tuning is therefore mandatory in most applications. Moreover, admittable values of η depend on the parameterisation retained—except for descents described in terms of Riemannian metrics [Ama98], which provide some degree of parameterisation-invariance.\nAutomated procedures for setting reasonable value of η are therefore of much value. For instance, AdaGrad [DHS11] divides the derivative ∂θℓt by a root mean square average of the magnitude of its recent values, so that the steps are of size approximately 1; but this still requires a “master step size” η.\nShaul, Zhang and LeCun in [SZL13] study a simple separable quadratic loss model and compute the value of η which minimises the expected loss after each parameter update. This value can be expressed in terms of computable quantities depending on the trajectory of the descent. These quantities still make sense for non-quadratic models, making this idea amenable to practical use.\nMore recently, Maclaurin, Douglas and Duvenaud [MDA15] propose to directly conduct a gradient ascent on the hyperparameters (such as the learning rate η) of any algorithm. The gradients with respect to the hyperparameters are computed exactly by “chaining derivatives backwards through the entire training procedure” [MDA15]. Consequently, this approach is extremely impractical in an online setting, as it optimizes the learning rate by performing several passes, each of which goes backwards from time t to time 0.\nFinding the best step size. The ideal value of the step size η would be the one that maximizes the cumulated objective function (1). Write θt(η) for the parameter value obtained after t iterations of the gradient step (2) using a given value η, and consider the sum\n∑ s≤t ℓs(θs(η)). (3)\nOur goal is to find an online way to approximate the value of η that provides the best value of this sum. This can be viewed as an ascent on the space of\nstochastic ascent algorithms. We suggest to update η through a stochastic gradient ascent on this sum:\nη ← η + α ∂ ∂η ℓt(θt(η)) (4)\nand then to use, at each time, the resulting value of η for the next gradient step (2).\nThe ascent (4) on η depends, in turn, on a step size α. Hopefully, the dependance on α of the whole procedure is somewhat lower than that of the original stochastic gradient scheme on its step size η.\nThis approach immediately extends to other stochastic gradient algorithms; in what follows we apply it both to the standard SG ascent and to the SVRG algorithm.\nThe main point in this approach is to find efficient ways to compute or approximate the derivatives ∂\n∂η ℓt(θt(η)). Indeed, the value θt(η) after t steps\ndepends on the whole trajectory of the algorithm, and so does its derivative with respect to η.\nAfter reviewing the setting for gradient ascents in Section 1, in Section 2.1 we provide an exact but impractical way of computing the derivatives ∂\n∂η ℓt(θt(η)). Sections 2.2–2.3 contain the main contribution: SG/SG\nand SG/AG, practical algorithms to adjust η based on two approximations with respect to these exact derivatives.\nSection 2.4 extends this to other base algorithms such as SVRG. In Section 4 one of the approximations is justified by showing that it computes a derivative, not with respect to a fixed value of η as in (4), but with respect to the sequences of values of η effectively used along the way. This also suggests improved algorithms.\nSection 3 provides experimental comparisons of gradient ascents using traditional algorithms with various values of η, and the same algorithms where η is self-adjusted according to our scheme. The comparisons are done on three sets of synthetic data: a one-dimensional Gaussian model, a one-dimensional Bernoulli model and a 50-dimensional linear regression model: these simple models already exemplify the strong dependence of the traditional algorithms on the value of η.\nTerminology. We say that an algorithm is of type “LLR” for “Learning the Learning Rate” when it updates its step size hyperparameter η as it unfolds. We refer to LLR algorithms by a compound abbreviation: “SVRG/SG”, for instance, for an algorithm which updates its parameter θ through SVRG and its hyperparameter η through an SG algorithm on η."
        },
        {
            "heading": "1 The Stochastic Gradient algorithm",
            "text": "To fix ideas, we define the Stochastic Gradient (SG) algorithm as follows. In all that follows, Θ = Rn for some n.1 The functions ℓt are assumed to be smooth. In all our algorithms, the index t starts at 0.\nAlgorithm 1 (Stochastic Gradient). We maintain θt ∈ Θ (current parameter), initialised at some arbitrary θ0 ∈ Θ. We fix η ∈ R. At each time t, we fix a rate f(t) ∈ R. The update equation reads:\nθt+1 = θt + η\nf(t) ∂θℓt(θt). (5)\nThe chosen rate f(t) usually satisfies the well-known Robbins–Monro conditions [RM51]:\n∑ t≥0 f(t)−1 =∞,\n∑ t≥0 f(t)−2 <∞. (6)\nThe divergence of the sum of the rates allows the ascent to go anywhere in parameter space, while the convergence of the sum of the squares ensures that variance remains finite. Though custom had it that small such rates should be chosen, such as f(t) = 1/t, recently the trend bucked towards the use of large ones, to allow for quick exploration of the parameter space. Throughout the article and experiments we use one such rate:\nf(t) = √ t+ 2 log(t+ 3). (7)"
        },
        {
            "heading": "2 Learning the learning rate on a stochastic gra-",
            "text": "dient algorithm"
        },
        {
            "heading": "2.1 The loss as a function of step size",
            "text": "To formalise what we said in the introduction, let us define, for each η ∈ R, the sequence\n(θ0, θ1, θ2, . . .) (8)\nobtained by iterating (5) from some initial value θ0. Since they depend on η, we introduce, for each t > 0, the operator\nTt : η ∈ R 7→ Tt(η) ∈ Θ, (9)\nwhich maps any η ∈ R to the parameter θt obtained after t iterations of (5). T0 maps every η to θ0. For each t ≥ 0, the map Tt is a regular function of\n1Θ may also be any Riemannian manifold, a natural setting when dealing with gradi-\nents. Most of the text is written in this spirit.\nη. As explained in the introduction, we want to optimise η according to the function:\nLt(η) := ∑\ns≤t ℓs(Ts(η)), (10)\nby conducting an online stochastic gradient ascent on it. We therefore need to compute the derivative in (4):\n∂\n∂η ℓt(Tt(η)). (11)\nTo act more decisively on the order of magnitude of η, we perform an ascent on its logarithm, so that we actually need to compute2:\n∂\n∂ log η ℓt(Tt(η)). (12)\nNow, the derivative of the loss at time t with respect to η can be computed as the product of the derivative of ℓt with respect to θ (the usual input of SG) and the derivative of θt with respect to η:\n∂\n∂ log η ℓt(Tt(η)) = ∂θℓt(Tt(η)) · At(η) (13)\nwhere\nAt(η) := ∂Tt(η)\n∂ log η . (14)\nComputation of the quantity At and its approximation ht to be introduced later, are the main focus of this text.\nLemma 1. The derivative At(η) may be computed through the following recursion equation. A0(η) = 0 and, for t ≥ 0,\nAt+1(η) = At(η) + η\nf(t) ∂θℓt(Tt(η)) +\nη\nf(t) ∂2θ ℓt(Tt(η)) ·At(η). (15)\nThe proof lies in Section C.1. This update of A involves the Hessian of the loss function with respect to θ, evaluated in the direction of At. Often this quantity is unavailable or too costly. Therefore we will use a finite difference approximation instead:\n∂2θ ℓt(Tt(η)) ·At(η) ≈ ∂θℓt (Tt(η) +At(η))− ∂θℓt(Tt(η)). (16)\nThis design ensures that the resulting update on At(η) uses the gradient of ℓt only once:\nAt+1(η) ≈ At(η) + η\nf(t) ∂θℓt (Tt(η) +At(η)) . (17)\nAn alternative approach would be to compute the Hessian in the direction At by numerical differentiation.\n2 This is an abuse of notation as Tt is not a function of log η but of η. Formally, we would need to replace Tt with Tt ◦ exp, which we refrain from doing to avoid burdensome notation."
        },
        {
            "heading": "2.2 LLR on SG: preliminary version with simplified expressions (SG/SG)",
            "text": "Even with the approximation above, computing the quantities At would have a quadratic cost in t: each time we update η thanks to (4), we would need to compute anew all the As(η), s ≤ t, as well as the whole trajectory θt = Tt(η), at each iteration t. We therefore replace the At(η)’s by online approximations, the quantities ht, which implement the same evolution equation (17) as At, disregarding the fact that η may have changed in the meantime. These quantities will be interpreted more properly in Section 4 as derivatives taken along the effective trajectory of the ascent. This yields the SG/SG algorithm.\nAlgorithm 2 (SG/SG). We maintain θt ∈ Θ (current parameter), ηt ∈ R (current step size) and ht ∈ TθtΘ (approximation of the derivative of θt with respect to log(η)).\nThe first two are initialised arbitrarily, and h0 is set to 0. The update equations read:\n\n     \n     \nlog ηt+1 = log ηt + 1\nµt ∂θℓt(θt) · ht\nht+1 = ht + ηt+1 f(t) ∂θℓt (θt + ht) θt+1 = θt + ηt+1 f(t) ∂θℓt(θt) ,\n(18)\nwhere µt is some learning rate on log η, such as µt = √ t+ 2 log(t+ 3)."
        },
        {
            "heading": "2.3 LLR on SG: efficient version (SG/AG)",
            "text": "To obtain better performances, we actually use an adagrad-inspired scheme to update the logarithm of the step size.\nAlgorithm 3 (SG/AG). We maintain θt ∈ Θ (current parameter), ηt ∈ R (current step size), ht ∈ TθtΘ (approximation of the derivative of θt with respect to log(η)), nt ∈ R (average of the squared norms of ∂ℓt ◦ Tt/∂ log η), and dt ∈ R (renormalising factor for the computation of nt).\nθ et η are initially set to θ0 and η0, the other variables are set to 0. At each time t, we compute µt ∈ R (a rate used in several updates), and\nλt ∈ R (the approximate derivative of ℓt ◦ θt with respect to log(η) at ηt).\nThe update equations read:\n\n                    \n                    \nµt = √ t+ 2 log(t+ 3) λt = l(θt) · ht\ndt+1 =\n(\n1− 1 µt\n)\ndt + 1\nµt\nn2t+1 =\n((\n1− 1 µt\n)\nn2t + 1\nµt λ2t\n)\nd−1t+1\nlog ηt+1 = log ηt + 1\nµt λt nt+1\nht+1 = ht + ηt+1 f(t) ∂θℓt (θt + ht) θt+1 = θt + ηt+1 f(t) ∂θℓt(θt).\n(19)"
        },
        {
            "heading": "2.4 LLR on other Stochastic Gradient algorithms",
            "text": "The LLR procedure may be applied to any stochastic gradient algorithm of the form\nθt+1 = F (θt, ηt) (20)\nwhere θt may store all the information maintained by the algorithm, not necessarily just a parameter value. Appendix B presents the algorithm in this case. Appendix A presents SVRG/AG, which is the particular case of this procedure applied to SVRG with an AdaGrad scheme for the update of ηt."
        },
        {
            "heading": "3 Experiments on SG and SVRG",
            "text": "We now present the experiments conducted to test our procedure. We first describe the experimental set up, then discuss the results."
        },
        {
            "heading": "3.1 Presentation of the experiments",
            "text": "We conducted ascents on synthetic data generated by three different probabilistic models: a one-dimensional Gaussian model, a Bernoulli model and a 50-dimensional linear regression model. Each model has two components: a generative distribution, and a set of distributions used to approximate the former.\nOne Dimensional Gaussian Model. The mean and value of the Gaussian generative distribution were set to 5 and 2 respectively. Let us note\npθ the density of a standard Gaussian random variable. The function to maximise we used is:\nℓt(θ) = log pθ(xt) = − 1\n2 (xt − θ)2. (21)\nBernoulli model. The parameter in the standard parameterisation for the Bernoulli model was set to p = 0.3, but we worked with a logit parameterisation θ = log(p/(1 − p)) for both the generative distribution and the discriminative function. The latter is then:\nℓt(θ) = θ · xt − log ( 1 + eθ ) . (22)\nFifty-dimensional Linear Regression model. In the last model, we compute a fixed random matrix M . We then draw samples Z from a standard 50-dimensional Gaussian distribution. We then useM to make random linear combinations X = MZ of the coordinates of the Z vectors. Then we observe X and try to recover first coordinate of the sample Z. The solution θ∗ is the first row of the inverse of M . Note Y the first coordinate of Z so that the regression pair is (X,Y ). We want to maximise:\nℓt(θ) = − 1\n2 (yt − θ · xt)2 , (23)\nFor each model, we drew 2500 samples from the data (7500 for the 50-\ndimensional model), then conducted ascents on those with on the one hand the SG and SVRG algorithms, and on the other hand their LLR counterparts, SG/SG and SVRG/SG, respectively."
        },
        {
            "heading": "3.2 Description and analysis of the results",
            "text": "For each model, we present four different types of results. We start with the trajectories of the ascents for several initial values of η (in the 50-dimensional case, we plot the first entry of θT · M). Then we present the cumulated regrets. Next we show the evolution of the logarithm of ηt along the ascents for the LLR algorithms. Finally, we compare this to trajectories of the nonadaptive algorithms with good initial values of η. Each time, we present three figures, one for each model.\nEach figure of Figures 1 to 3 is made of four graphs: the upper ones are those of SG and SVRG, the lower ones are those of SG/SG and SVRG/SG. Figures 1 to 3 present the trajectories of the ascents for several orders of magnitude of η0, while Figures 4 to 6 present the cumulated regrets for the same η0’s. The trajectory of the running maximum likelihood (ML) is displayed in red in each plot."
        },
        {
            "heading": "3.2.1 Trajectories of θ",
            "text": "Each figure for the ascent looks the same: there are several well distinguishable trajectories in the graphs of the standard algorithms, the upper ones, while trajectories are much closer to each other in those of the LLR algorithms, the lower ones.\nIndeed, for many values of η, the standard algorithms will perform poorly. For instance, low values of η will result in dramatically low convergence towards the ML, as may be seen in some trajectories of the SG graphs. The SVRG algorithm performs noticeably better, but may start to oscillate, as in Figures 2 and 3.\nThese inconveniences are significantly improved by the use of LLR procedures. Indeed, in each model, almost every trajectory gets close to that of the ML in the SG/AG graphs. In the SVRG/AG graphs, the oscillations are overwhelmingly damped. Improvements for SG, though significant, are not as decisive in the linear regression model as in the other two, probably due to its greater complexity."
        },
        {
            "heading": "3.2.2 Cumulated regrets",
            "text": "Each curve of Figures 4 to 6 represents the difference between the cumulated regret of the algorithm used and that of the ML, for the η0 chosen. The curves of SG and SVRG all go upwards, which means that the difference increases with time, whereas those of SG/AG and SVRG/SG tend to stagnate strikingly quickly. Actually, the trajectories for the linear regression model do not stagnate, but they are still significantly better for the LLR algorithms than for the original ones. The stagnation means that the values of the parameter found by these algorithms are very quickly as good as the Maximum Likelihood for the prediction task. Arguably, the fluctuations of the ascents around the later are therefore not a defect of the model: the cumulated regret graphs show that they are irrelevant for the minimisation at hand."
        },
        {
            "heading": "3.2.3 Evolution of the step size of the LLR algorithms during the ascents",
            "text": "Figures 7 to 9 show the evolution of the value of the logarithm of ηt in the LLR procedures for the three models, in regard of the trajectories of the corresponding ascents. For the Gaussian and Bernoulli models, in Figures 7\nand 8, log(ηt) tends to stagnate quite quickly. This may seem a desirable behaviour : the algorithms have reached good values for ηt, and the ascent may accordingly proceed with those. However, this analysis may seem somewhat unsatisfactory due to the 1/f(t) dampening term in the parameter update, which remains unaltered by our procedure. For the linear regression model, in Figure 9, the convergence takes longer in the SG/SG case, and even in the SVRG/SG one, which may be explained again by the complexity of the model."
        },
        {
            "heading": "3.2.4 LLR versus hand-crafted learning rates",
            "text": "Figures 10 to 12 show the trajectories of the ascents for LLR algorithms with poor initial values of the step size, compared to the trajectories of the original algorithms with hand-crafted optimal values of η. The trajectories of the original algorithms appear in red. They possess only two graphs each, where all the trajectories are pretty much undistinguishable from another. This shows that the LLR algorithms show acceptable behaviour even with poor initial values of η, proving the procedure is able to rescue very badly initialised algorithms. However, one caveat is that the LLR procedure encounters difficulties dealing with too large values of η0, and is much more efficient at dealing with small values of η0. We have no satisfying explana-\ntion of this phenomenon yet. We thus suggest, in practice, to underestimate rather than overestimate the initial value η0."
        },
        {
            "heading": "3.3 ηt in a quadratic model",
            "text": "In a quadratic deterministic one-dimensional model, where we want to maximise:\nf(θ) = −αx 2\n2 , (24)\nSG is numerically stable if, and only if, ∣\n∣ ∣ ∣ 1− αη f(t)\n∣ ∣ ∣ ∣ < 1, (25)\nthat is η\n2f(t) < α−1. (26)\nEach graph of Figure 13 has two curves, one for the original algorithm, the other for its LLR version. The curve of the LLR version goes down quickly, then much more slowly, while the other curve goes down slowly all the time. This shows that, for α = 108, the ratio above converges quickly towards\nα−1 for SG/AG and SVRG/AG, showing the ascent on η is indeed efficient. Then, the algorithm has converged, and ηt stays nearly constant, so much so that the LLR curve behaves like the other one. However, the convergence of ηt happens too slowly: θt takes very large values before ηt reaches this value, and even though it eventually converges to 0, such behaviour is unacceptable in practise."
        },
        {
            "heading": "4 A pathwise interpretation of the derivatives",
            "text": "Until now, we have tried to optimise the step size for a stochastic gradient ascent. This may be interpreted as conducting a gradient ascent on the subspace of the ascent algorithms which gathers the stochastic gradient algorithms, parametrised by η ∈ R. However, we had to replace the At(η)’s by the ht’s because computing the former gave our algorithm a quadratic complexity in time. Indeed, adhesion to Equation 1 entails using A0(η1) to compute A1(η1), for instance. Likewise, A0(η2) and A1(η2) would be necessary to compute A2(η2), and this scheme would repeat itself for every iteration.\nWe now introduce a formalism which shows the approximations we use are actually derivatives taken alongside the effective trajectory of the ascent.\nIt will also allow us to devise a new algorithm. It will, however, not account for the approximation of the Hessian.\nTo this avail, let us parameterise stochastic gradient algorithms by a sequence of step sizes\nη = (η0, η1, . . .) (27)\nsuch that at iteration t, the update equation for θt becomes:\nθt+1 = θt + ηt+1 f(t) ∂θℓt(θt). (28)"
        },
        {
            "heading": "4.1 The loss as a function of step size: extension of the formalism",
            "text": "Consider the space S of infinite real sequences\nη = (η0, η1, η2, . . .) (29)\nWe expand the Tt operators defined in Section 2 to similar ones defined on S, with the same notation. Namely, define T0(η) = θ0 and, for t > 0,\nTt : η ∈ S 7→ Tt(η) ∈ R (30)\nwhere θt has been obtained thanks to t iterations of (28). Tt is a regular function of η, as the computations only involve\nη0, η1, . . . , ηt, (31)\nand so take place in finite-dimensional spaces. This will apply in all the computations below. As before, we work on a space we call log(S), the image of S by the mapping\nη = (ηt)t≥0 ∈ S 7→ log(η) = (log ηt)t≥0, (32)\nbut we do not change notation for the functions η 7→ Tt(η), as in Section 2."
        },
        {
            "heading": "4.2 The update of the step size in the SG/SG algorithm as a gradient ascent",
            "text": "We now prove that in SG/SG, when the Hessian is used without approximations, the step size ηt indeed follows a gradient ascent scheme.\nProposition 1. Let (θt)t≥0 , η = (ηt)t≥0 (33)\nbe the sequences of parameters and step-sizes obtained with the SG/SG algorithm, where the Hessian is not approximated: this is Algorithm 2 where the update on ht is replaced with\nht+1 = ht + η\nµt ∂θℓt(θt) +\nη\nµt ∂2θ ℓt(θt) · ht. (34)\nDefine e in the tangent plane of log(S) at log(η) by\net = 1, t ≥ 0. (35)\nThen, for all t ≥ 0,\nlog ηt+1 = log ηt + 1\nµt\n∂\n∂e ℓt(Tt(η)). (36)\nThe proof lies in Appendix C.2.1."
        },
        {
            "heading": "4.3 A new algorithm, using a notion of “memory” borrowed from [SZL13]",
            "text": "We would now like to compute the change in η implied by a small modification of all previous coordinates ηs for s less than the current time t, but to\ncompute the modification differently according to whether the coordinate s is “outdated” or not. To do it, we use the quantity τt defined in Section 4.2 of [SZL13] as the “number of samples in recent memory”. We want to discard the old η’s and keep the recent ones. Therefore, at each time t, we\n−10\n−9\n−8\n−7\n−6\n−5\n−4\n−3\n−2\n−1\n0 500 1000 1500 2000 2500\nlo g 1 0\n(\nη t\n2 √ t+\n2 lo g (t + 3 )\n)\nnumber of iterations\nConvergence towards the inverse of the eigenvalue for SG/AG\nSG, η=10−1 SG/AG, η0=10 −1\n−11 −10 −9 −8 −7 −6 −5 −4 −3 −2 −1\n0 500 1000 1500 2000 2500\nlo g 1 0\n(\nη t\n2 √ t+\n2 lo g (t + 3 )\n)\nnumber of iterations\nConvergence towards the inverse of the eigenvalue for SVRG/AG\nSVRG, η=10−1 SVRG/AG, η0=10 −1\nFigure 13: Evolution of log10 (\nηt 2 √ t+2 log(t+3)\n)\nfor a quadratic deterministic\none-dimensional model for SG, SVRG and their LLR versions\ncompute γt = exp(−1/τt). (37)\nChoose η ∈ log(S), and consider the vector in the tangent plane to log(S) at η:\nejt =\n\n  \n  \nt ∏\nk=j\nγj, j ≤ t\n0, j ≥ t+ 1.\n(38)\nTo run an algorithm using the et’s instead of e as before, all we need to compute again is the formula for the update of the derivative below:\nHt := ∂\n∂et Tt(η). (39)\nHt may indeed be computed, thanks to the following result.\nProposition 2. The update equation of Ht is:\nHt+1 = γt+1Ht + γt+1 ηt+1 f(t) ∂θℓt(Tt(η t)) + γt+1 ηt+1 f(t) ∂2T ℓt(Tt(η)) · Ht. (40)\nThe proof lies in Section C.2.2."
        },
        {
            "heading": "Acknowledgements",
            "text": "The first author would like to thank Gaetan Marceau-Caron for his advice on programming, and Jérémy Bensadon for crucial help with LATEX."
        },
        {
            "heading": "A LLR applied to the Stochastic Variance Reduced",
            "text": "Gradient\nThe Stochastic Variance Reduced Gradient (SVRG) was introduced by Johnson and Zhang in [JZ13]. We define here a version intended for online use.\nAlgorithm 4 (SVRG online). We maintain θt, θ b ∈ Θ (current parameter and base parameter) and sbt ∈ T≃θtΘ (sum of the gradients of the ℓs computed at θs up to time t).\nθ is set to θ0 and θ b along sb to 0. The update equations read: \n  \n  \nsbt+1 = s b t + ∂θℓt(θ b)\nθt+1 = θt + η\n(\n∂θℓt(θt)− ∂θℓt(θb) + sbt+1 t+ 1\n)\n. (41)\nWe now present the LLR version, obtained by updating the η of SVRG thanks to an SG ascent. We call this algorithm “SVRG/SG”.\nAlgorithm 5 (SVRG/AG). We maintain θt, θ b ∈ Θ (current parameter and base parameter), ηt ∈ R (current step size), sbt ∈ T≃θtΘ (sum of the gradients of the ℓs computed at θs up to time t), ht ∈ TθtΘ (approximation of the derivative of Tt with respect to log(η) at ηt) and the real numbers nt (average of the squared norms of the λs defined below) and dt (renormalising factor for the computation of nt).\nθ is set to θ0, the other variables are set to 0. At each time t, we compute µt ∈ R (a rate used in several updates), and\nλt ∈ R (the approximate derivative of ℓt ◦ θt with respect to log(η) at ηt). The update equations read:\n\n                          \n                          \nµt = √ t+ 2 log(t+ 3) λt = ∂θℓt(θt) · ht\ndt+1 =\n(\n1− 1 µt\n)\ndt + 1\nµt\nn2t+1 =\n((\n1− 1 µt\n)\nn2t + 1\nµt λ2t\n)\nd−1t+1\nηt+1 = ηt exp\n(\n1\nµt λt nt+1\n)\nsbt+1 = s b t + ∂θℓt(θ b)\nht+1 = ht + ηt+1\n(\n∂θℓt(θt + ht)− ∂θℓt(θb) + sbt+1 t+ 1\n)\nθt+1 = θt + ηt+1\n(\n∂θℓt(θt)− ∂θℓt(θb) + sbt+1 t+ 1\n)\n.\n(42)"
        },
        {
            "heading": "B LLR applied to a general stochastic gradient al-",
            "text": "gorithm\nLet Θ and H be two spaces. Θ is the space of parameters, H is that of hyperparameters. In this section, a parameter potentially means a tuple of parameters in the sense of other sections. For instance, in SVRG/SG online, we would call a parameter the couple\n( θt, θ b ) . (43)\nLikewise, in the same algorithm, we would call a hyperparameter the couple\n(ηt, ht) . (44)\nLet F : Θ×H → Θ\n(θ, η) 7→ F (θ, η). (45)\nbe differentiable with respect to both variables. We consider the algorithm:\nθt+1 = F (θt, ηt). (46)\nLet us present its LLR version. We call it GEN/SG, GEN standing for “general”.\nAlgorithm 6 (GEN/SG). We maintain θt ∈ Θ (current parameter), ηt ∈ H (current hyperparameter), ht ∈ TθtΘ (approximation of the derivative of Tt in the direction of e ∈ TηtH).\nθ and η are set to user-defined values. The update equations read:\n\n   \n   \nηt+1 = ηt + α∂θℓt(θt) · ht ht+1 = ∂θF (θt, ηt) · ht + ∂ηF (θt, ηt) · ∂\n∂e ηt\nθt+1 = F (θt, ηt+1) .\n(47)"
        },
        {
            "heading": "C Computations",
            "text": "C.1 Computations for Section 2: proof of Fact 1\nProof. θ0 is fixed, so A0(η) = 0. Let t ≥ 0. We differentiate (5) with respect to log(η), to obtain:\n∂\n∂log η Tt+1(η) =\n∂\n∂log η Tt(η) +\nη\nf(t) ∂θℓt(θt) +\nη\nf(t) ∂2θ ℓt(θt(η)) ·\n∂\n∂log η Tt(η),\n(48) which concludes the proof.\nC.2 Computations for Section 4\nC.2.1 Computations for Section 4.2: proof of Proposition 1\nTo prove Proposition 1, we use the following three lemmas. The first two are technical, and are used in the proof of the third one, which provides an update formula for the derivative appearing in the statement of the proposition. We may have proceeded without these, as in the proof of Fact 1, but they allow the approach to be more generic.\nLemma 2. Let\nFt : Θ× R → Θ (θ, η) 7→ Ft(θ, η) = θ + ηf(t)∂θℓt(θ).\n(49)\nThen, ∂\n∂θ Ft(θ, η) = Id+\nη\nf(t) ∂2θ ℓt(θ) (50)\nand ∂\n∂η Ft(θ, η) =\n1\nf(t) ∂θℓt(θ). (51)"
        },
        {
            "heading": "Id is the identity on the tangent plane to Θ in θ.",
            "text": "Lemma 3. Let\nVt : S → Θ× R η 7→ Vt(η) = (θt(η), ηt+1).\n(52)\nConsider log(η) ∈ log(S), and any vector e tangent to log(S) at this point. Then the directional derivative of\nFt ◦ Vt : S → Θ η 7→ Ft(Vt(η)) = Tt(η) + ηt+1f(t) ∂θℓt(Tt(η))\n(53)\nat the point log(η) and in the direction e is\n∂\n∂e Ft ◦ Vt(η) =\n∂\n∂e Tt(η) +\n∂\n∂e ηt+1\n1\nf(t) ∂θℓt(Tt(η)) + ηt+1 f(t) ∂2θ ℓt(Tt(η)) · ∂ ∂e Tt(η).\n(54)\nWe may then prove the following lemma.\nLemma 4. Define\nHt = ∂\n∂e Tt(η). (55)\nThen for all t ≥ 0,\nHt+1 = Ht + ηt+1 f(t) ∂θℓt(Tt(η)) + ηt+1 f(t) ∂2θ ℓt(Tt(η)) · Ht. (56)\nProof. The update equation of Tt(η), (28), is such that:\nTt+1(η) = Tt(η) + ηt+1 f(t) ∂θℓt(Tt(η)) = Ft ◦ Vt(η). (57)\nFrom the above and Lemma 3,\n∂\n∂e Tt+1(η) =\n∂\n∂e Tt(η)+\n∂\n∂e ηt+1\n1\nf(t) ∂θℓt(Tt(η))+ ηt+1 f(t) ∂2θ ℓt(Tt(η)) · ∂ ∂e Tt(η).\n(58) Now,\n∂\n∂e ηt+1 = ηt+1, (59)\nwhich concludes the proof.\nFinally, we prove Proposition 1.\nProof of Proposition 1. It is sufficient to prove that, for all t ≥ 0,\n∂\n∂e ℓt(Tt(η)) = ∂θℓt(θt) · ht, (60)\nthat is, ∂θℓt(Tt(η)) · Ht = ∂θℓt(θt) · ht. (61)\nTherefore, it is sufficient to prove that, for all t ≥ 0, Tt(η) = θt and Ht = ht. T0(η) = θ0 by construction and, since θ0 does not depend on η, H0 = 0 = h0. Assuming the results hold up to iteration t, it is straighforward that Tt+1(η) = θt+1, since for all s ≤ t, Ts(η) = θs. Therefore, thanks to Lemma 4, Ht and ht have the same update, so that Ht+1 = ht+1, which concludes the proof.\nC.2.2 Computations for Section 4.3: proof of Proposition 2\nProof. Thanks to (58) in Lemma 3,\n∂\n∂et+1 Tt+1(η) =\n∂\n∂et+1 Tt(η) +\n∂\n∂et+1 ηt+1\n1\nf(t) ∂θℓt(Tt(η))\n+ ηt+1 f(t) ∂2θℓt(Tt(η)) · ∂ ∂et+1 Tt(η),\n(62)\nthat is:\nHt+1 = ∂\n∂et+1 Tt(η)+\n∂\n∂et+1 ηt+1\n1\nf(t) ∂θℓt(Tt(η))+ ηt+1 f(t) ∂2θℓt(Tt(η))· ∂ ∂et+1 Tt(η).\n(63) We first prove:\n∂\n∂et+1 Tt(η) = γt+1\n∂\n∂et Tt(η). (64)\nDefine (fj)j≥0 the canonical basis of the tangent plane to log(S) at η. Then,\net+1 = γt+1(et + ft+1). (65)\nTherefore, ∂\n∂et+1 Tt(η) =\n∂\n∂et+1 Tt(η)\n= γt+1 ∂\n∂et Tt(η\nt) + ∂\n∂ft+1 Tt(η\nt)\n= γt+1 ∂\n∂et Tt(η\nt)\n(66)\nbecause the last term is 0. Therefore,\n∂\n∂et+1 Tt(η) = γt+1Ht. (67)\nThen, thanks to (58), ∂\n∂et+1 ηt+1 = γt+1ηt+1, (68)\nwhich is true since\n∂\n∂et+1 ηt+1 = γt+1\n∂\n∂ft+1 ηt+1 = γt+1ηt+1, (69)\nand concludes the proof."
        }
    ],
    "title": "Speed learning on the fly",
    "year": 2015
}