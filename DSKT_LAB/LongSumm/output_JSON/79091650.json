{
    "abstractText": "We present a new family of subgradient methods that dynamica lly incorporate knowledge of the geometry of the data observed in earlier iterations to perfo rm more informative gradient-based learning. Metaphorically, the adaptation allows us to find n eedles in haystacks in the form of very predictive but rarely seen features. Our paradigm stems fro m recent advances in stochastic optimization and online learning which employ proximal funct ions to control the gradient steps of the algorithm. We describe and analyze an apparatus for adap tively modifying the proximal function, which significantly simplifies setting a learning rate nd results in regret guarantees that are provably as good as the best proximal function that can be cho sen in hindsight. We give several efficient algorithms for empirical risk minimization probl ems with common and important regularization functions and domain constraints. We experimen tally study our theoretical analysis and show that adaptive subgradient methods outperform state-o f-the-art, yet non-adaptive, subgradient algorithms.",
    "authors": [
        {
            "affiliations": [],
            "name": "John Duchi"
        },
        {
            "affiliations": [],
            "name": "Elad Hazan"
        },
        {
            "affiliations": [],
            "name": "Tong Zhang"
        },
        {
            "affiliations": [],
            "name": "Yoram Singer"
        },
        {
            "affiliations": [],
            "name": "DUCHI"
        },
        {
            "affiliations": [],
            "name": "HAZAN"
        }
    ],
    "id": "SP:d97d41a4aa3672aa40395178c0e1769c8234ab86",
    "references": [
        {
            "authors": [
                "T. Ando"
            ],
            "title": "Concavity of certain maps on positive definite matrices and applicatio",
            "year": 2008
        },
        {
            "authors": [
                "N. Cesa-Bianchi",
                "A. Conconi",
                "C. Gentile"
            ],
            "title": "A second-order perce",
            "year": 2004
        }
    ],
    "sections": [
        {
            "text": "Keywords: subgradient methods, adaptivity, online learning, stochastic convex optimization"
        },
        {
            "heading": "1. Introduction",
            "text": "In many applications of online and stochastic learning, the input instances are of very high dimension, yet within any particular instance only a few features are non-zer . It is often the case, however, that infrequently occurring features are highly informative and discriminative. The informativeness of rare features has led practitioners to craft domain-specific f ature weightings, such as TF-IDF (Salton and Buckley, 1988), which pre-emphasize infrequentlyoccurring features. We use this old idea as a motivation for applying modern learning-theoretic techniquesto the problem of online and stochastic learning, focusing concretely on (sub)gradient methods.\n∗. A preliminary version of this work was published in COLT 2010.\nc©2011 John Duchi, Elad Hazan and Yoram Singer.\nStandard stochastic subgradient methods largely follow a predetermined procedu al scheme that is oblivious to the characteristics of the data being observed. In contrast,our algorithms dynamically incorporate knowledge of the geometry of the data observed in earlier iterations to perform more informative gradient-based learning. Informally, our procedures give frequently occurring features very low learning rates and infrequent features high learning rates, where t e intuition is that each time an infrequent feature is seen, the learner should “take notice.” Thus, the adaptation facilitates finding and identifying very predictive but comparatively rare features."
        },
        {
            "heading": "1.1 The Adaptive Gradient Algorithm",
            "text": "Before introducing our adaptive gradient algorithm, which we term ADAGRAD, we establish notation. Vectors and scalars are lower case italic letters, such asx ∈ X . We denote a sequence of vectors by subscripts, that is,xt ,xt+1, . . ., and entries of each vector by an additional subscript, for example,xt, j . The subdifferential set of a functionf evaluated atx is denoted∂ f (x), and a particular vector in the subdifferential set is denoted byf ′(x) ∈ ∂ f (x) or gt ∈ ∂ ft(xt). When a function is differentiable, we write∇ f (x). We use〈x,y〉 to denote the inner product betweenx andy. The Bregman divergence associated with a strongly convex and differentiable functionψ is\nBψ(x,y) = ψ(x)−ψ(y)−〈∇ψ(y),x−y〉 .\nWe also make frequent use of the following two matrices. Letg1:t = [g1 · · · gt ] denote the matrix obtained by concatenating the subgradient sequence. We denote theith row of this matrix, which amounts to the concatenation of theith component of each subgradient we observe, byg1:t,i . We also define the outer product matrixGt = ∑tτ=1gτgτ⊤.\nOnline learning and stochastic optimization are closely related and basically interchangeable (Cesa-Bianchi et al., 2004). In order to keep our presentation simple, we confine our discussion and algorithmic descriptions to the online setting with the regret bound model. In onlinelearning, the learner repeatedly predicts a pointxt ∈ X ⊆ Rd, which often represents a weight vector assigning importance values to various features. The learner’s goal is to achieve low r gret with respect to a static predictorx∗ in the (closed) convex setX ⊆ Rd (possiblyX = Rd) on a sequence of functions ft(x), measured as\nR(T) = T\n∑ t=1 ft(xt)− inf x∈X\nT\n∑ t=1 ft(x) .\nAt every timestept, the learner receives the (sub)gradient informationgt ∈ ∂ ft(xt). Standard subgradient algorithms then move the predictorxt in the opposite direction ofgt while maintaining xt+1 ∈ X via the projected gradient update (e.g., Zinkevich, 2003)\nxt+1 = ΠX (xt −ηgt) = argmin x∈X ‖x− (xt −ηgt)‖22 .\nIn contrast, let the Mahalanobis norm‖·‖A = √ 〈·,A·〉 and denote the projection of a pointy ontoX according toA by ΠA\nX (y) = argminx∈X ‖x−y‖A = argminx∈X 〈x−y,A(x−y)〉. Using this notation,\nour generalization of standard gradient descent employs the update\nxt+1 = Π G1/2t X ( xt −ηG−1/2t gt ) .\nThe above algorithm is computationally impractical in high dimensions since it requires computation of the root of the matrixGt , the outer product matrix. Thus we specialize the update to\nxt+1 = Π diag(Gt)1/2\nX\n( xt −ηdiag(Gt)−1/2gt ) . (1)\nBoth the inverse and root of diag(Gt) can be computed in linear time. Moreover, as we discuss later, when the gradient vectors are sparse the update above can often be performed in time proportional to the support of the gradient. We now elaborate and give a more formal discuss on of our setting.\nIn this paper we consider several different online learning algorithms and their stochastic convex optimization counterparts. Formally, we consider online learning with a sequence of composite functionsφt . Each function is of the formφt(x) = ft(x)+ϕ(x) where ft andϕ are (closed) convex functions. In the learning settings we study,ft is either an instantaneous loss or a stochastic estimate of the objective function in an optimization task. The functionϕ serves as a fixed regularization function and is typically used to control the complexity ofx. At each round the algorithm makes a predictionxt ∈ X and then receives the functionft . We define the regret with respect to the fixed (optimal) predictorx∗ as\nRφ(T), T\n∑ t=1\n[φt(xt)−φt(x∗)] = T\n∑ t=1\n[ ft(xt)+ϕ(xt)− ft(x∗)−ϕ(x∗)] . (2)\nOur goal is to devise algorithms which are guaranteed to suffer asymptoticallysub-linear regret, namely,Rφ(T) = o(T).\nOur analysis applies to related, yet different, methods for minimizing the regret (2). The first is Nesterov’s primal-dual subgradient method (2009), and in particular Xi o’s (2010) extension, regularized dual averaging, and the follow-the-regularized-leader (FTRL) family of algorithms (see for instance Kalai and Vempala, 2003; Hazan et al., 2006). In the primal-dual subgradient method the algorithm makes a predictionxt on roundt using the average gradient ¯gt = 1t ∑ t τ=1gτ. The update encompasses a trade-off between a gradient-dependent linear term, theegularizerϕ, and a stronglyconvex termψt for well-conditioned predictions. Hereψt is theproximalterm. The update amounts to solving\nxt+1 = argmin x∈X\n{\nη〈ḡt ,x〉+ηϕ(x)+ 1 t ψt(x) } , (3)\nwhereη is a fixed step-size andx1 = argminx∈X ϕ(x). The second method similarly has numerous names, including proximal gradient, forward-backward splitting, andcomposite mirror descent (Tseng, 2008; Duchi et al., 2010). We use the term composite mirror descent. The composite mirror descent method employs a more immediate trade-off between the current gradientgt , ϕ, and staying close toxt using the proximal functionψ,\nxt+1 = argmin x∈X\n{ η〈gt ,x〉+ηϕ(x)+Bψt (x,xt) } . (4)\nOur work focuses on temporal adaptation of the proximal function in a data driven way, while previous work simply setsψt ≡ ψ, ψt(·) = √ tψ(·), or ψt(·) = tψ(·) for some fixedψ.\nWe provide formal analyses equally applicable to the above two updates andshow how to automatically choose the functionψt so as to achieve asymptotically small regret. We describe and analyze two algorithms. Both algorithms use squared Mahalanobis norms as their proximal functions, settingψt(x) = 〈x,Htx〉 for a symmetric matrixHt 0. The first uses diagonal matrices while\nthe second constructs full dimensional matrices. Concretely, for some smallfixed δ ≥ 0 (specified later, though in practiceδ can be set to 0) we set\nHt = δI +diag(Gt)1/2 (Diagonal) and Ht = δI +G 1/2 t (Full) . (5)\nPlugging the appropriate matrix from the above equation intoψt in (3) or (4) gives rise to our ADAGRAD family of algorithms. Informally, we obtain algorithms which are similar to secondorder gradient descent by constructing approximations to the Hessian ofthe functionsft , though we use roots of the matrices."
        },
        {
            "heading": "1.2 Outline of Results",
            "text": "We now outline our results, deferring formal statements of the theorems to latersections. Recall the definitions ofg1:t as the matrix of concatenated subgradients andGt as the outer product matrix in the prequel. The ADAGRAD algorithm with full matrix divergences entertains bounds of the form\nRφ(T) = O ( ‖x∗‖2 tr(G 1/2 T ) ) and Rφ(T) = O\n(\nmax t≤T\n‖xt −x∗‖2 tr(G 1/2 T )\n)\n.\nWe further show that\ntr ( G1/2T ) = d1/2\n√ √ √ √inf S { T\n∑ t=1\n〈gt ,S−1gt〉 : S 0, tr(S)≤ d } .\nThese results are formally given in Theorem 7 and its corollaries. When our pr ximal function ψt(x) = 〈 x,diag(Gt)1/2x 〉\nwe have bounds attainable in time at most linear in the dimensiond f our problems of the form\nRφ(T) = O\n(\n‖x∗‖∞ d\n∑ i=1 ‖g1:T,i‖2\n)\nand Rφ(T) = O\n(\nmax t≤T\n‖xt −x∗‖∞ d\n∑ i=1 ‖g1:T,i‖2\n)\n.\nSimilar to the above, we will show that\nd\n∑ i=1\n‖g1:T,i‖2 = d1/2 √ √ √\n√inf s\n{\nT\n∑ t=1\n〈gt ,diag(s)−1gt〉 : s 0,〈1,s〉 ≤ d } .\nWe formally state the above two regret bounds in Theorem 5 and its corollaries. Following are a simple example and corollary to Theorem 5 to illustrate one regime inwhich we expect substantial improvements (see also the next subsection). Letϕ ≡ 0 and consider Zinkevich’s online gradient descent algorithm. Given a compact convex setX ⊆ Rd and sequence of convex functionsft , Zinkevich’s algorithm makes the sequence of predictionsx1, . . . ,xT with xt+1 = ΠX (xt − (η/ √ t)gt). If the diameter ofX is bounded, thus supx,y∈X ‖x−y‖2 ≤ D2, then online gradient descent, with the optimal choice inhi dsightfor the stepsizeη (see the bound (7) in Section 1.4), achieves a regret bound of\nT\n∑ t=1 ft(xt)− inf x∈X\nT\n∑ t=1\nft(x)≤ √ 2D2\n√\nT\n∑ t=1 ‖gt‖22 . (6)\nWhenX is bounded via supx,y∈X ‖x−y‖∞ ≤ D∞, the following corollary is a simple consequence of our Theorem 5.\nCorollary 1 Let the sequence{xt} ⊂ Rd be generated by the update (4) and assume that maxt ‖x∗−xt‖∞ ≤ D∞. Using stepsizeη = D∞/ √ 2, for any x∗, the following bound holds.\nRφ(T)≤ √ 2dD∞\n√\ninf s 0,〈1,s〉≤d\nT\n∑ t=1\n‖gt‖2diag(s)−1 = √ 2D∞ d\n∑ i=1 ‖g1:T,i‖2 .\nThe important feature of the bound above is the infimum under the square root, which allows us to perform better than simply using the identity matrix, and the fact that the stepsizeis easy to set a priori. For example, if the setX = {x : ‖x‖∞ ≤ 1}, thenD2 = 2 √ d while D∞ = 2, which suggests that if we are learning a dense predictor over a box, the adaptive method should perform well. Indeed, in this case we are guaranteed that the bound in Corollary 1 is better than (6)s the identity matrix belongs to the set over which we take the infimum.\nTo conclude the outline of results, we would like to point to two relevant reseach papers. First, Zinkevich’s regret bound is tight and cannot be improved in a minimax sense(Ab rnethy et al., 2008). Therefore, improving the regret bound requires further reasonable assumptions on the input space. Second, in a independent work, performed concurrently to theresearch presented in this paper, McMahan and Streeter (2010) studycompetitive ratios, showing guaranteed improvements of the above bounds relative to families of online algorithms."
        },
        {
            "heading": "1.3 Improvements and Motivating Example",
            "text": "As mentioned in the prequel, we expect our adaptive methods to outperformstandard online learning methods when the gradient vectors are sparse. We give empirical evidence supporting the improved performance of the adaptive methods in Section 6. Here we give a few abstract examples that show that for sparse data (input sequences wheregt has many zeros) the adaptive methods herein have better performance than non-adaptive methods. In our examples we use the hinge loss, that is,\nft(x) = [1−yt 〈zt ,x〉]+ ,\nwhereyt is the label of examplet andzt ∈ Rd is the data vector. For our first example, which was also given by McMahan and Streeter (2010), consider the following sparse random data scenario, where the vectorszt ∈ {−1,0,1}d. Assume that at in each roundt, featurei appears with probabilitypi = min{1,ci−α} for someα ∈ (1,∞) and a dimensionindependent constantc. Then taking the expectation of the gradient terms in the bound in Corollary 1, we have\nE\nd\n∑ i=1\n‖g1:T,i‖2 = d\n∑ i=1 E\n[\n√ |{t : |gt,i |= 1}| ] ≤ d\n∑ i=1\n√ E|{t : |gt,i |= 1}|= d\n∑ i=1\n√\npiT\nby Jensen’s inequality. In the rightmost sum, we havec∑di=1 i−α/2 = O(logd) for α ≥ 2, and ∑di=1 i−α/2 =O(d1−α/2) for α ∈ (1,2). If the domainX is a hypercube, sayX = {x : ‖x‖∞ ≤ 1}, then in Corollary 1D∞ = 2, and the regret of ADAGRAD is O(max{logd,d1−α/2} √ T). For contrast, the\nstandard regret bound (6) for online gradient descent hasD2 = 2 √\nd and‖gt‖22 ≥ 1, yielding best case regretO( √ dT). So we see that in this sparse yet heavy tailed feature setting, ADAGRAD’s regret guarantee can be exponentially smaller in the dimensiond than the non-adaptive regret bound. Our remaining examples construct a sparse sequence for which there is ap rfect predictor that the adaptive methods learn afterd iterations, while standard online gradient descent (Zinkevich,\n2003) suffers significantly higher loss. We assume the domainX s compact, so that for online gradient descent we setηt = η/ √ t, which gives the optimalO( √ T) regret (the setting ofη does not matter to the adversary we construct)."
        },
        {
            "heading": "1.3.1 DIAGONAL ADAPTATION",
            "text": "Consider the diagonal version of our proposed update (4) withX = {x : ‖x‖∞ ≤ 1}. Evidently, we can takeD∞ = 2, and this choice simply results in the updatext+1 = xt − √ 2diag(Gt)−1/2gt followed by projection (1) ontoX for ADAGRAD (we use a pseudo-inverse if the inverse does not exist). Letei denote theith unit basis vector, and assume that for eacht, zt = ±ei for somei. Also let yt = sign(〈1,zt〉) so that there exists a perfect classifierx∗ = 1∈ X ⊂ Rd. We initializex1 to be the zero vector. Fix someε > 0, and on rounds roundst = 1, . . . ,η2/ε2, setzt = e1. After these rounds, simply choosezt =±ei for index i ∈ {2, . . . ,d} chosen at random. It is clear that the update to parameterxi at these iterations is different, and amounts to\nxt+1 = xt +ei ADAGRAD xt+1 =\n[\nxt + η√ t\n]\n[−1,1]d (Gradient Descent).\n(Here[·][−1,1]d denotes the truncation of the vector to[−1,1]d). In particular, after sufferingd−1 more losses, ADAGRAD has a perfect classifier. However, on the remaining iterations gradient descent hasη/ √ t ≤ ε and thus evidently suffers loss at leastd/(2ε). Of course, for smallε, we haved/(2ε)≫ d. In short, ADAGRAD achieves constant regret per dimension while online gradient descent can suffer arbitrary loss (for unboundedt). It seems quite silly, then, to use a global learning rate rather than one for each feature. Full Matrix Adaptation. We use a similar construction to the diagonal case to show a situation in which the full matrix update from (5) gives substantially lower regret thanstochastic gradient descent. For full divergences we setX = {x : ‖x‖2 ≤ √ d}. Let V = [v1 . . . vd] ∈ Rd×d be an orthonormal matrix. Instead of havingzt cycle through the unit vectors, we makezt cycle through thevi so thatzt = ±vi . We let the labelyt = sign( 〈 1,V⊤zt 〉 ) = sign ( ∑di=1〈vi ,zt〉 )\n. We provide an elaborated explanation in Appendix A. Intuitively, withψt(x) = 〈x,Htx〉 andHt set to be the full matrix from (5), ADAGRAD again needs to observe each orthonormal vectorvi nly once while stochastic gradient descent’s loss can be madeΩ(d/ε) for anyε > 0."
        },
        {
            "heading": "1.4 Related Work",
            "text": "Many successful algorithms have been developed over the past few years to minimize regret in the online learning setting. A modern view of these algorithms casts the problem as the task of following the (regularized) leader (see Rakhlin, 2009, and the referenc s therein) or FTRL in short. Informally, FTRL methods choose the best decision in hindsight at every iteration. Verbatim usage of the FTRL approach fails to achieve low regret, however, adding a proximal1 term to the past predictions leads to numerous low regret algorithms (Kalai and Vempala, 2003; Hazan and Kale, 2008; Rakhlin, 2009). The proximal term strongly affects the performance of the learning algorithm. Therefore, adapting the proximal function to the characteristics of the problem at hand is desirable.\nOur approach is thus motivated by two goals. The first is to generalize the agnostic online learning paradigm to the meta-task of specializing an algorithm to fit a particular data set. Specifically,\n1. The proximal term is also referred to as regularization in the online learning literature. We use the phrase proximal term in order to avoid confusion with the statistical regularization functionϕ.\nwe change the proximal function to achieve performance guarantees which are ompetitive with the best proximal term found in hindsight. The second, as alluded to earlier, isto automatically adjust the learning rates for online learning and stochastic gradient descent ona per-feature basis. The latter can be very useful when our gradient vectorsgt are sparse, for example, in a classification setting where examples may have only a small number of non-zero features.As we demonstrated in the examples above, it is rather deficient to employ exactly the same learning rate fo a feature seen hundreds of times and for a feature seen only once or twice.\nOur techniques stem from a variety of research directions, and as a byproduct we also extend a few well-known algorithms. In particular, we consider variants of the follow-the-regularized leader (FTRL) algorithms mentioned above, which are kin to Zinkevich’s lazy projection algorithm. We use Xiao’s recently analyzed regularized dual averaging (RDA) algorithm (2010), which builds upon Nesterov’s (2009) primal-dual subgradient method. We also consider forward-backward splitting (FOBOS) (Duchi and Singer, 2009) and its composite mirror-descent (proximal gradient) generalizations (Tseng, 2008; Duchi et al., 2010), which in turn include as special cases projected gradients (Zinkevich, 2003) and mirror descent (Nemirovski and Yudin, 1983; Beck and Teboulle, 2003). Recent work by several authors (Nemirovski et al., 2009; Juditsky et al.,2008; Lan, 2010; Xiao, 2010) considered efficient and robust methods for stochastic optimization, especially in the case when the expected objectivef is smooth. It may be interesting to investigate adaptive metric approaches in smooth stochastic optimization.\nThe idea of adapting first order optimization methods is by no means new and can be traced back at least to the 1970s with the work on space dilation methods of Shor (1972) and variable metric methods, such as the BFGS family of algorithms (e.g., Fletcher, 1970). This prior work often assumed that the function to be minimized was differentiable and, to our knwledge, did not consider stochastic, online, or composite optimization. In her thesis, Nedić (2002) studied variable metric subgradient methods, though it seems difficult to derive explicit ratesof convergence from the results there, and the algorithms apply only when the constraint setX = Rd. More recently, Bordes et al. (2009) proposed a Quasi-Newton stochastic gradient-descent procedure, which is similar in spirit to our methods. However, their convergence results assume a smooth objective with positive definite Hessian bounded away from 0. Our results apply more generally.\nPrior to the analysis presented in this paper for online and stochastic optimization, the strongly convex functionψ in the update equations (3) and (4) either remained intact or was simply multiplied by a time-dependent scalar throughout the run of the algorithm. Zinkevich’s projected gradient, for example, usesψt(x) = ‖x‖22, while RDA (Xiao, 2010) employsψt(x) = √ tψ(x) whereψ is a strongly convex function. The bounds for both types of algorithms are similar, and both rely on the norm‖·‖ (and its associated dual‖·‖∗) with respect to whichψ is strongly convex. Mirror-descent type first order algorithms, such as projected gradient methods, attain regret bounds of the form (Zinkevich, 2003; Bartlett et al., 2007; Duchi et al., 2010)\nRφ(T)≤ 1 η Bψ(x ∗,x1)+ η 2\nT\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ∗ . (7)\nChoosingη ∝ 1/ √ T givesRφ(T) = O( √\nT). WhenBψ(x,x∗) is bounded for allx∈ X , we choose step sizesηt ∝ 1/ √ t which is equivalent to settingψt(x) = √ tψ(x). Therefore, no assumption on the time horizon is necessary. For RDA and follow-the-leader algorithms, thebounds are similar\n(Xiao, 2010, Theorem 3):\nRφ(T)≤ √ Tψ(x∗)+ 1\n2 √ T\nT\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ∗ . (8)\nThe problem of adapting to data and obtaining tighter data-dependent bounds for algorithms such as those above is a natural one and has been studied in the mistake-bound setting for online learning in the past. A framework that is somewhat related to ours is the confidence weighted learning scheme by Crammer et al. (2008) and the adaptive regularization of weights algorithm (AROW) of Crammer et al. (2009). These papers provide mistake-boundanalyses for secondorder algorithms, which in turn are similar in spirit to the second-order Perceptron algorithm (CesaBianchi et al., 2005). The analyses by Crammer and colleagues, however, yield mistake bounds dependent on the runs of the individual algorithms and are thus difficult tocompare with our regret bounds.\nAROW maintains a mean prediction vectorµt ∈ Rd and a covariance matrixΣt ∈ Rd×d overµt as well. At every step of the algorithm, the learner receives a pair(zt ,yt) wherezt ∈ Rd is thetth example andyt ∈ {−1,+1} is the label. Whenever the predictorµt attains a margin value smaller than 1, AROW performs the update\nβt = 1\n〈zt ,Σtzt〉+λ , αt = [1−yt 〈zt ,µt〉]+ ,\nµt+1 = µt +αtΣtytzt , Σt+1 = Σt −βtΣtxtx⊤t Σt . (9)\nIn the above scheme, one can forceΣt to be diagonal, which reduces the run-time and storage requirements of the algorithm but still gives good performance (Crammer etal., 2009). In contrast to AROW, the ADAGRAD algorithm uses theroot of the inverse covariance matrix, a consequence of our formal analysis. Crammer et al.’s algorithm and our algorithms have similar run times, generally linear in the dimensiond, when using diagonal matrices. However, when using full matrices the runtime of AROW algorithm isO(d2), which is faster than ours as it requires computing the root of a matrix.\nIn concurrent work, McMahan and Streeter (2010) propose and analyze an algorithm which is very similar to some of the algorithms presented in this paper. Our analysis buildon recent advances in online learning and stochastic optimization (Duchi et al., 2010; Xiao, 2010), whereas McMahan and Streeter use first-principles to derive their regret bounds. As a consequence of our approach, we are able to apply our analysis to algorithms for composite minimization wi h a known additional objective termϕ. We are also able to generalize and analyze both the mirror descent and dual-averaging family of algorithms. McMahan and Streeter focus on whatthey term thecompetitive ratio, which is the ratio of the worst case regret of the adaptive algorithm to the worst case regret of a non-adaptive algorithm with the best proximal termψ chosen in hindsight. We touch on this issue briefly in the sequel, but refer the interested reader to McMahanand Streeter (2010) for this alternative elegant perspective. We believe that both analyses shedin ights into the problems studied in this paper and complement each other.\nThere are also other lines of work on adaptive gradient methods that arenot directly related to our work but nonetheless relevant. Tighter regret bounds using the variation of the cost functionsft were proposed by Cesa-Bianchi et al. (2007) and derived by Hazan nd Kale (2008). Bartlett et al. (2007) explore another adaptation technique forηt where they adapt the step size to accommodate\nboth strongly and weakly convex functions. Our approach differs from previous approaches as it does not focus on a particular loss function or mistake bound. Instead, we vie the problem of adapting the proximal function as a meta-learning problem. We then obtain a bound c mparable to the bound obtained using the best proximal function chosen in hindsight."
        },
        {
            "heading": "2. Adaptive Proximal Functions",
            "text": "Examining the bounds (7) and (8), we see that most of the regret depends on dual norms of ′t (xt), and the dual norms in turn depend on the choice ofψ. This naturally leads to the question of whether we can modify the proximal termψ along the run of the algorithm in order to lower the contribution of the aforementioned norms. We achieve this goal by keeping second order information about the sequenceft and allowψ to vary on each round of the algorithms.\nWe begin by providing two corollaries based on previous work that give the regret of our base algorithms when the proximal functionψt is allowed to change. These corollaries are used in the sequel in our regret analysis. We assume thatψt is monotonically non-decreasing, that is, ψt+1(x) ≥ ψt(x). We also assume thatψt is 1-strongly convex with respect to a time-dependent semi-norm‖·‖ψt . Formally,ψ is 1-strongly convex with respect to‖·‖ψ if\nψ(y)≥ ψ(x)+ 〈∇ψ(x),y−x〉+ 1 2 ‖x−y‖2ψ .\nStrong convexity is guaranteed if and only ifBψt (x,y)≥ 12 ‖x−y‖ 2 ψt . We also denote the dual norm of ‖·‖ψt by ‖·‖ψ∗t . For completeness, we provide the proofs of following two results in Appendix F, as they build straightforwardly on work by Duchi et al. (2010) and Xiao (2010). For the primal-dual subgradient update, the following bound holds.\nProposition 2 Let the sequence{xt} be defined by the update (3). For any x∗ ∈ X ,\nT\n∑ t=1 ft(xt)+ϕ(xt)− ft(x∗)−ϕ(x∗)≤ 1 η ψT(x∗)+ η 2\nT\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t−1 . (10)\nFor composite mirror descent algorithms a similar result holds.\nProposition 3 Let the sequence{xt} be defined by the update (4). Assume w.l.o.g. thatϕ(x1) = 0. For any x∗ ∈ X ,\nT\n∑ t=1\nft(xt)+ϕ(xt)− ft(x∗)−ϕ(x∗)\n≤ 1 η Bψ1(x ∗,x1)+ 1 η T−1 ∑ t=1 [ Bψt+1(x ∗,xt+1)−Bψt (x∗,xt+1) ] + η 2 T ∑ t=1 ∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t . (11)\nThe above corollaries allow us to prove regret bounds for a family of algorithms that iteratively modify the proximal functionsψt in attempt to lower the regret bounds."
        },
        {
            "heading": "3. Diagonal Matrix Proximal Functions",
            "text": "We begin by restricting ourselves to using diagonal matrices to define matrix proximal functions and (semi)norms. This restriction serves a two-fold purpose. First, the analysis for the general case is somewhat complicated and thus the analysis of the diagonal restriction serves as a proxy for better understanding. Second, in problems with high dimension where we expect this type of modification to help, maintaining more complicated proximal functions is likely to be prohibitively expensive. Whereas earlier analysis requires a learning rate to slow changes between predictorsxt andxt+1, we will instead automatically grow the proximal function we use to achieve asymptotically low regret. To remind the reader,g1:t,i is theith row of the matrix obtained by concatenating the subgradients from iteration 1 throught in the online algorithm.\nTo provide some intuition for the algorithm we show in Algorithm 1, let us examine the problem\nmin s\nT\n∑ t=1\nd\n∑ i=1 g2t,i si s.t. s 0, 〈1,s〉 ≤ c .\nThis problem is solved by settingsi = ‖g1:T,i‖2 and scalings so that〈s,1〉= c. To see this, we can write the Lagrangian of the minimization problem by introducing multipliersλ 0 andθ ≥ 0 to get\nL(s,λ,θ) = d\n∑ i=1 ‖g1:T,i‖22 si −〈λ,s〉+θ(〈1,s〉−c).\nTaking partial derivatives to find the infimum ofL , we see that−‖g1:T,i‖22/s2i −λi +θ= 0, and complementarity conditions onλisi (Boyd and Vandenberghe, 2004) imply thatλi = 0. Thus we have si = θ− 1 2 ‖g1:T,i‖2, and normalizing appropriately usingθ gives thatsi = c‖g1:T,i‖2/∑dj=1 ∥ ∥g1:T, j ∥ ∥ 2.\nAs a final note, we can plugsi into the objective above to see\ninf s\n{\nT\n∑ t=1\nd\n∑ i=1 g2t,i si : s 0,〈1,s〉 ≤ c } = 1 c ( d ∑ i=1 ‖g1:T,i‖2\n)2\n. (12)\nLet diag(v) denote the diagonal matrix with diagonalv. It is natural to suspect that fors achieving the infimum in Equation (12), if we use a proximal function similar toψ(x) = 〈x,diag(s)x〉 with associated squared dual norm‖x‖2ψ∗ = 〈 x,diag(s)−1x 〉\n, we should do well lowering the gradient terms in the regret bounds (10) and (11).\nTo prove a regret bound for our Algorithm 1, we note that both types of updates suffer losses that include a term depending solely on the gradients obtained along their run. The following lemma is applicable to both updates, and was originally proved by Auer and Gentile (2000), though we provide a proof in Appendix C. McMahan and Streeter (2010) also givean identical lemma.\nLemma 4 Let gt = f ′t (xt) and g1:t and st be defined as in Algorithm 1. Then\nT\n∑ t=1\n〈 gt ,diag(st) −1gt 〉 ≤ 2 d\n∑ i=1 ‖g1:T,i‖2 .\nTo obtain a regret bound, we need to consider the terms consisting of the dual-norm of the subgradient in the regret bounds (10) and (11), which is‖ f ′t (xt)‖2ψ∗t . Whenψt(x) = 〈x,(δI +diag(st))x〉, it is easy to see that the associated dual-norm is\n‖g‖2ψ∗t = 〈 g,(δI +diag(st))−1g 〉 .\nFrom the definition ofst in Algorithm 1, we clearly have‖ f ′t (xt)‖2ψ∗t ≤ 〈 gt ,diag(st)−1gt 〉\n. Note that if st,i = 0 thengt,i = 0 by definition ofst,i . Thus, for anyδ ≥ 0, Lemma 4 implies\nT\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t\n≤ 2 d\n∑ i=1 ‖g1:T,i‖2 . (13)\nTo obtain a bound for a primal-dual subgradient method, we setδ ≥ maxt ‖gt‖∞, in which case ‖gt‖2ψ∗t−1 ≤ 〈 gt ,diag(st)−1gt 〉\n, and we follow the same lines of reasoning to achieve the inequality (13).\nIt remains to bound the various Bregman divergence terms for Corollary 3nd the termψT(x∗) for Corollary 2. We focus first on the composite mirror-descent update.Examining the bound (11) and Algorithm 1, we notice that\nBψt+1(x ∗,xt+1)−Bψt (x∗,xt+1) = 1 2 〈x∗−xt+1,diag(st+1−st)(x∗−xt+1)〉\n≤ 1 2 max i (x∗i −xt+1,i)2‖st+1−st‖1 .\nSince‖st+1−st‖1 = 〈st+1−st ,1〉 and〈sT ,1〉= ∑di=1‖g1:T,i‖2, we have T−1 ∑ t=1 Bψt+1(x ∗,xt+1)−Bψt (x∗,xt+1) ≤ 1 2 T−1 ∑ t=1 ‖x∗−xt+1‖2∞ 〈st+1−st ,1〉\n≤ 1 2 max t≤T ‖x∗−xt‖2∞ d ∑ i=1 ‖g1:T,i‖2− 1 2 ‖x∗−x1‖2∞ 〈s1,1〉 . (14)\nWe also have\nψT(x∗) = δ‖x∗‖22+ 〈x∗,diag(sT)x∗〉 ≤ δ‖x∗‖ 2 2+‖x∗‖ 2 ∞\nd\n∑ i=1 ‖g1:T,i‖2 .\nCombining the above arguments with Corollaries 2 and 3, and using (14) with thefact thatBψ1(x ∗,x1)≤ 1 2 ‖x∗−x1‖ 2 ∞ 〈1,s1〉, we have proved the following theorem.\nTheorem 5 Let the sequence{xt} be defined by Algorithm 1. For xt generated using the primaldual subgradient update (3) withδ ≥ maxt ‖gt‖∞, for any x∗ ∈ X ,\nRφ(T)≤ δ η ‖x∗‖22+ 1 η ‖x∗‖2∞\nd\n∑ i=1\n‖g1:T,i‖2+η d\n∑ i=1 ‖g1:T,i‖2 .\nFor xt generated using the composite mirror-descent update (4), for any x∗ ∈ X\nRφ(T)≤ 1\n2η max t≤T\n‖x∗−xt‖2∞ d\n∑ i=1\n‖g1:T,i‖2+η d\n∑ i=1 ‖g1:T,i‖2 .\nThe above theorem is a bit unwieldy. We thus perform a few algebraic simplifications to get the next corollary, which has a more intuitive form. Let us assume thatX is compact and setD∞ = supx∈X ‖x−x∗‖∞. Furthermore, define\nγT , d\n∑ i=1 ‖g1:T,i‖2 = infs\n{\nT\n∑ t=1\n〈 gt ,diag(s) −1gt 〉 : 〈1,s〉 ≤ d\n∑ i=1\n‖g1:T,i‖2 , s 0 } .\nAlso w.l.o.g. let 0∈ X . The following corollary is immediate (this is equivalent to Corollary 1, though we have moved the √ d term in the earlier bound).\nCorollary 6 Assume that D∞ andγT are defined as above. For{xt} generated by Algorithm 1 using the primal-dual subgradient update (3) withη = ‖x∗‖∞, for any x∗ ∈ X we have\nRφ(T)≤ 2‖x∗‖∞ γT +δ ‖x∗‖22 ‖x∗‖∞ ≤ 2‖x∗‖∞ γT +δ‖x∗‖1 .\nUsing the composite mirror descent update (4) to generate{xt} and settingη = D∞/ √ 2, we have\nRφ(T)≤ √ 2D∞ d\n∑ i=1\n‖g1:T,i‖2 = √ 2D∞γT .\nWe now give a short derivation of Corollary 1 from the introduction: useTh orem 5, Corollary 6, and the fact that\ninf s\n{\nT\n∑ t=1\nd\n∑ i=1 g2t,i si : s 0,〈1,s〉 ≤ d } = 1 d ( d ∑ i=1 ‖g1:T,i‖2\n)2\n.\nas in (12) in the beginning of Section 3. Plugging theγT term in from Corollary 6 and multiplying D∞ by √ d completes the proof of the corollary.\nAs discussed in the introduction, Algorithm 1 should have lower regret thannon-adaptive algorithms on sparse data, though this depends on the geometry of the underlyingoptimization space X . For example, suppose that our learning problem is a logistic regression with 0/1-valued features. Then the gradient terms are likewise based on 0/1-valued features and sparse, so the gradient terms in the bound∑di=1‖g1:T,i‖2 should all be much smaller than √ T. If some features appear much more frequently than others, then the infimal representation ofγT and the infimal equality in Corollary 1 show that we have significantly lower regret by using higher learning rates for infrequent features and lower learning rates on commonly appearing features. Further, if the op imal predictor is relatively dense, as is often the case in predictions problems with sparse inputs, then‖x∗‖∞ is the best p-norm we can have in the regret.\nMore precisely, McMahan and Streeter (2010) show that ifX s contained within anℓ∞ ball of radiusR and contains anℓ∞ ball of radiusr, then the bound in the above corollary is within a factor of √ 2R/r of the regret of the best diagonal proximal matrix, chosen in hindsight. So, for example, ifX = {x∈ Rd : ‖x‖p ≤C}, thenR/r = d1/p, which shows that the domainX does effect the guarantees we can give on optimality of ADAGRAD."
        },
        {
            "heading": "4. Full Matrix Proximal Functions",
            "text": "In this section we derive and analyze new updates when we estimate a full matrix for he divergence ψt instead of a diagonal one. In this generalized case, we use the root of the ma rix of outer products of the gradients that we have observed to update our parameters. As in thediagonal case, we build on intuition garnered from an optimization problem, and in particular, we seek amatrix Swhich is the solution to the following minimization problem:\nmin S\nT\n∑ t=1\n〈 gt ,S −1gt 〉 s.t. S 0, tr(S)≤ c . (15)\nThe solution is obtained by definingGt = ∑tτ=1gτgτ⊤ and settingS to be a normalized version of the root ofGT , that is,S= cG 1/2 T / tr(G 1/2 T ). For a proof, see Lemma 15 in Appendix E, which also shows that whenGT is not full rank we can instead use its pseudo-inverse. If we iteratively use divergences of the formψt(x) = 〈 x,G1/2t x 〉 , we might expect as in the diagonal case to attain low regret by collecting gradient information. We achieve our low regret goal by employing a similar doubling lemma to Lemma 4 and bounding the gradient norm terms. The resulting algorithm is given in Algorithm 2, and the next theorem provides a quantitative analysisof the brief motivation above.\nTheorem 7 Let Gt be the outer product matrix defined above and the sequence{xt} be defined by Algorithm 2. For xt generated using the primal-dual subgradient update of (3) andδ ≥ maxt ‖gt‖2, for any x∗ ∈ X\nRφ(T)≤ δ η ‖x∗‖22+ 1 η ‖x∗‖22 tr(G 1/2 T )+η tr(G 1/2 T ).\nFor xt generated with the composite mirror-descent update of (4), if x∗ ∈ X andδ ≥ 0\nRφ(T)≤ δ η ‖x∗‖22+ 1 2η max t≤T ‖x∗−xt‖22 tr(G 1/2 T )+η tr(G 1/2 T ).\nProof To begin, we consider the difference between the divergence terms at timet +1 and timet from the regret (11) in Corollary 3. Letλmax(M) denote the largest eigenvalue of a matrixM. We have\nBψt+1(x ∗,xt+1)−Bψt (x∗,xt+1) = 1 2 〈 x∗−xt+1,(Gt+11/2−Gt1/2)(x∗−xt+1) 〉\n≤ 1 2 ‖x∗−xt+1‖22 λmax(G 1/2 t+1−G 1/2 t ) ≤ 1 2 ‖x∗−xt+1‖22 tr(G 1/2 t+1−G 1/2 t ) .\nFor the last inequality we used the fact that the trace of a matrix is equal to the sum of its eigenvalues along with the propertyGt+11/2−Gt1/2 0 (see Lemma 13 in Appendix B) and therefore tr(G1/2t+1− G1/2t )≥ λmax(G1/2t+1−G 1/2 t ). Thus, we get\nT−1 ∑ t=1 Bψt+1(x ∗,xt+1)−Bψt (x∗,xt+1)≤ 1 2 T−1 ∑ t=1 ‖x∗−xt+1‖22 ( tr(G1/2t+1)− tr(G 1/2 t ) ) .\nNow we use the fact thatG1 is a rank 1 PSD matrix with non-negative trace to see that\nT−1 ∑ t=1 ‖x∗−xt+1‖22 ( tr(G1/2t+1)− tr(G 1/2 t ) )\n≤ max t≤T ‖x∗−xt‖22 tr(GT1/2)−‖x∗−x1‖ 2 2 tr(G 1/2 1 ) . (16)\nIt remains to bound the gradient terms common to all our bounds. We use the following three lemmas, which essentially directly applicable. We prove the first two in AppendixD.\nLemma 8 Let B 0 and B−1/2 denote the root of the inverse of B when B≻ 0 and the root of the pseudo-inverse of B otherwise. For anyν such that B−νgg⊤ 0 the following inequality holds.\n2tr((B−νgg⊤)1/2)≤ 2tr(B1/2)−ν tr(B−1/2gg⊤) .\nLemma 9 Let δ ≥ ‖g‖2 and A 0, then 〈 g,(δI +A1/2)−1g 〉\n≤ 〈 g, ( (A+gg⊤)† )1/2 g 〉 .\nLemma 10 Let St = Gt1/2 be as defined in Algorithm 2 and A† denote the pseudo-inverse of A. Then\nT\n∑ t=1\n〈 gt ,S † t gt 〉 ≤ 2 T\n∑ t=1\n〈 gt ,S † Tgt 〉 = 2tr(GT 1/2) .\nProof We prove the lemma by induction. The base case is immediate, since we have\n〈\ng1,(G † 1) 1/2g1 〉 = 〈g1,g1〉 ‖g1‖2 = ‖g1‖2 ≤ 2‖g1‖2 .\nNow, assume the lemma is true forT −1, so from the inductive assumption we get T\n∑ t=1\n〈 gt ,S † t gt 〉 ≤ 2 T−1 ∑ t=1 〈 gt ,S † T−1gt 〉 + 〈 gT ,S † TgT 〉 .\nSinceST−1 does not depend ont we can rewrite∑T−1t=1 〈 gt ,S † T−1gt 〉 as\ntr\n(\nS†T−1, T−1 ∑ t=1 gtg ⊤ t\n)\n= tr((G†T−1) 1/2GT−1) ,\nwhere the right-most equality follows from the definitions ofSt andGt . Therefore, we get\nT\n∑ t=1\n〈 gt ,S † t gt 〉 ≤ 2tr((G†T−1)1/2GT−1)+ 〈 gT ,(G † T) 1/2gT 〉\n= 2tr(G1/2T−1)+ 〈 gT ,(G † T) 1/2gT 〉 .\nUsing Lemma 8 with the substitutionB= GT , ν = 1, andg= gt lets us exploit the concavity of the function tr(A1/2) to bound the above sum by 2tr(G1/2T ). N\nWe can now finalize our proof of the theorem. As in the diagonal case, we have t at the squared dual norm (seminorm whenδ = 0) associated withψt is\n‖x‖2ψ∗t = 〈 x,(δI +St)−1x 〉 .\nThus it is clear that‖gt‖2ψ∗t ≤ 〈 gt ,S † t gt 〉 . For the dual-averaging algorithms, we use Lemma 9 above show that‖gt‖2ψ∗t−1 ≤ 〈 gt ,S † t gt 〉\nso long asδ ≥ ‖gt‖2. Lemma 10’s doubling inequality then implies that\nT\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t ≤ 2tr(G1/2T ) and T\n∑ t=1\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t−1 ≤ 2tr(G1/2T ) (17)\nfor the mirror-descent and primal-dual subgradient algorithm, respectively. To finish the proof, Note thatBψ1(x ∗,x1)≤ 12 ‖x∗−x1‖ 2 2 tr(G 1/2 1 ) whenδ = 0. By combining this with the first of the bounds (17) and the bound (16) on∑T−1t=1 Bψt+1(x ∗,xt+1)−Bψt (x∗,xt+1), Corollary 3 gives the theorem’s statement for the mirror-descent family of algorithms. Combining the\nfact that∑Tt=1‖ f ′t (xt)‖2ψ∗t−1 ≤ 2tr(G 1/2 T ) and the bound (16) with Corollary 2 gives the desired bound onRφ(T) for the primal-dual subgradient algorithms, which completes the proof of thetheorem.\nAs before, we can give a corollary that simplifies the bound implied by Theorem 7. The infimal equality in the corollary uses Lemma 15 in Appendix B. The corollary underscore that for learning problems in which there is a rotationU of the space for which the gradient vectorsgt have small inner products〈gt ,Ugt〉 (essentially a sparse basis for thegt) then using full-matrix proximal functions can attain significantly lower regret.\nCorollary 11 Assume thatϕ(x1)= 0. Then the regret of the sequence{xt} generated by Algorithm 2 when using the primal-dual subgradient update withη = ‖x∗‖2 is\nRφ(T)≤ 2‖x∗‖2 tr(G 1/2 T )+δ‖x∗‖2 .\nLet X be compact set so thatsupx∈X ‖x−x∗‖2 ≤ D. Takingη = D/ √\n2 and using the composite mirror descent update withδ = 0, we have\nRφ(T)≤ √ 2D tr(G1/2T ) = √ 2dD\n√ √ √ √inf S { T\n∑ t=1\ng⊤t S−1gt : S 0, tr(S)≤ d } ."
        },
        {
            "heading": "5. Derived Algorithms",
            "text": "In this section, we derive updates using concrete regularization functions ϕ and settings of the domainX for the ADAGRAD framework. We focus on showing how to solve Equations (3) and (4) with the diagonal matrix version of the algorithms we have presented. We focus on the diagonal case for two reasons. First, the updates often take closed-form in this case and carry some intuition. Second, the diagonal case is feasible to implement in very high dimensions, whereas the full matrix version is likely to be confined to a few thousand dimensions. We also discusshow to efficiently compute the updates when the gradient vectors are sparse.\nWe begin by noting a simple but useful fact. LetGt denote either the outer product matrix of gradients or its diagonal counterpart and letHt = δI +G 1/2 t , as usual. Simple algebraic manipulations yield that each of the updates (3) and (4) in the prequel can be writtenin he following form (omitting the stepsizeη):\nxt+1 = argmin x∈X\n{\n〈u,x〉+ϕ(x)+ 1 2 〈x,Htx〉\n}\n. (18)\nIn particular, at timet for the RDA update, we haveu= ηtḡt . For the composite gradient update (4),\nη〈gt ,x〉+ 1 2 〈x−xt ,Ht(x−xt)〉= 〈ηgt −Htxt ,x〉+ 1 2 〈x,Htx〉+ 1 2 〈xt ,Htxt〉\nso thatu= ηgt −Htxt . We now derive algorithms for solving the general update (18). Since most of the derivations are known, we generally provide only the closed-form solutions or algorithms for the solutions in the remainder of the subsection, deferring detailed derivations to Appendix G for the interested reader."
        },
        {
            "heading": "5.1 ℓ1-regularization",
            "text": "We begin by considering how to solve the minimization problems necessary for Alg ithm 1 with diagonal matrix divergences andϕ(x) = λ‖x‖1. We consider the two updates we proposed and denote theith diagonal element of the matrixHt = δI +diag(st) from Algorithm 1 byHt,ii = δ+ ‖g1:t,i‖2. For the primal-dual subgradient update, the solution to (3) amounts to the following simple update forxt+1,i :\nxt+1,i = sign(−ḡt,i) ηt\nHt,ii [|ḡt,i |−λ]+ . (19)\nComparing the update (19) to the standard dual averaging update (Xiao, 2010), which is\nxt+1,i = sign(−ḡt,i)η √ t [|ḡt,i |−λ]+ ,\nit is clear that the difference distills to the step size employed for each coordinate. Our generalization of RDA yields a dedicated step size for each coordinate inversely proporti nal to the time-based norm of the coordinate in the sequence of gradients. Due to the normalizationby this term the step size scaleslinearly with t, so whenHt,ii is small, gradient information on coordinatei is quickly incorporated.\nThe composite mirror-descent update (4) has a similar form that essentially amounts to iterative shrinkage and thresholding, where the shrinkage differs per coordinate:\nxt+1,i = sign\n(\nxt,i − η\nHt,ii gt,i\n)[∣\n∣ ∣ ∣ xt,i − η\nHt,ii gt,i\n∣ ∣ ∣ ∣ − λη Ht,ii ]\n+\n.\nWe compare the actual performance of the newly derived algorithms to previously studied versions in the next section.\nFor both updates it is clear that we can perform “lazy” computation when thegradient vectors are sparse, a frequently occurring setting when learning for instance from text corpora. Suppose that from time stept0 throught, the ith component of the gradient is 0. Then we can evaluate the above updates on demand sinceHt,ii remains intact. For composite mirror-descent, at timet when xt,i is needed, we update\nxt,i = sign(xt0,i)\n[\n|xt0,i |− λη\nHt0,ii (t − t0)\n]\n+\n.\nEven simpler just in time evaluation can be performed for the the primal-dual subgradient update. Here we need to keep an unnormalized version of the average ¯gt . Concretely, we keep track of ut = tḡt = ∑tτ=1gτ = ut−1+gt , then use the update (19):\nxt,i = sign(−ut,i) ηt\nHt,ii\n[ |ut,i | t −λ ]\n+\n,\nwhereHt can clearly be updated lazily in a similar fashion."
        },
        {
            "heading": "5.2 ℓ1-ball Projections",
            "text": "We next consider the setting in whichϕ ≡ 0 andX = {x : ‖x‖1 ≤ c}, for which it is straightforward to adapt efficient solutions to continuous quadratic knapsack problems (Brucker, 1984). We\nuse the matrixHt = δI +diag(Gt)1/2 from Algorithm 1. We provide a brief derivation sketch and anO(d logd) algorithm in this section. First, we convert the problem (18) into a projection pr blem onto a scaledℓ1-ball. By making the substitutionsz= H1/2x andA = H−1/2, it is clear that problem (18) is equivalent to\nmin z\n∥ ∥\n∥ z+H−1/2u\n∥ ∥ ∥\n2 2 s.t. ‖Az‖1 ≤ c .\nNow, by appropriate choice ofv = −H−1/2u = −ηtH−1/2t ḡt for the primal-dual update (3) and v= H1/2t xt −ηH−1/2t gt for the mirror-descent update (4), we arrive at the problem\nmin z 1 2 ‖z−v‖22 s.t.\nd\n∑ i=1 ai |zi | ≤ c . (20)\nWe can clearly recoverxt+1 from the solutionz∗ to the projection (20) viaxt+1 = H −1/2 t z ∗. By the symmetry of the objective (20), we can assume without loss of generality th t v 0 and constrainz 0, and a bit of manipulation with the Lagrangian (see Appendix G) for the problem shows that the solutionz∗ has the form\nz∗i =\n{ vi −θ∗ai if vi ≥ θ∗ai 0 otherwise\nfor someθ∗ ≥ 0. The algorithm in Figure 3 constructs the optimalθ and returnsz∗."
        },
        {
            "heading": "5.3 ℓ2 Regularization",
            "text": "We now turn to the case whereϕ(x) = λ‖x‖2 while X = Rd. This type of regularization is useful for zeroing multiple weights in a group, for example in multi-task or multiclass learning (Obozinski et al., 2007). Recalling the general proximal step (18), we must solve\nmin x 〈u,x〉+ 1 2 〈x,Hx〉+λ‖x‖2 . (21)\nThere is no closed form solution for this problem, but we give an efficientbisection-based procedure for solving (21). We start by deriving the dual. Introducing a variablez= x, we get the equivalent problem of minimizing〈u,x〉+ 12 〈x,Hx〉+λ‖z‖2 subject tox= z. With Lagrange multipliersα for the equality constraint, we obtain the Lagrangian\nL(x,z,α) = 〈u,x〉+ 1 2 〈x,Hx〉+λ‖z‖2+ 〈α,x−z〉 .\nTaking the infimum ofL with respect to the primal variablesx andz, we see that the infimum is attained atx=−H−1(u+α). Coupled with the fact that infzλ‖z‖2−〈α,z〉=−∞ unless‖α‖2 ≤ λ, in which case the infimum is 0, we arrive at the dual form\ninf x,z L(x,z,α) =\n{ −12 〈 u+α,H−1(u+α) 〉 if ‖α‖2 ≤ λ −∞ otherwise.\nSettingv= H−1u, we further distill the dual to\nmin α 〈v,α〉+ 1 2 〈 α,H−1α 〉 s.t. ‖α‖2 ≤ λ . (22)\nWe can solve problem (22) efficiently using a bisection search of its equivalent representation in Lagrange form,\nmin α 〈v,α〉+ 1 2 〈 α,H−1α 〉 + θ 2 ‖α‖22 ,\nwhereθ > 0 is an unknown scalar. The solution to the latter as a function ofθ is clearlyα(θ) = −(H−1+θI)−1v=−(H−1+θI)−1H−1u. Since‖α(θ)‖2 is monotonically decreasing inθ (consider the the eigen-decomposition of the positive definiteH−1), we can simply perform a bisection search overθ, checking at each point whether‖α(θ)‖2 ≷ λ.\nTo find initial upper and lower bounds onθ, we note that\n(1/σmax(H)+θ)−1‖v‖2 ≤ ‖α(θ)‖2 ≤ (1/σmin(H)+θ)−1‖v‖2\nwhereσmax(H) denotes the maximum singular value ofH andσmin(H) the minimum. To guarantee ‖α(θmax)‖2 ≤ λ, we thus setθmax= ‖v‖2/λ−1/σmax(H). Similarly, forθmin we see that so long as θ ≥ ‖v‖2/λ−1/σmin(H) we have‖α(θ)‖2 ≥ λ. The fact that∂‖x‖2 = {z : ‖z‖2 ≤ 1} whenx= 0 implies that the solution for the original problem (21) isx= 0 if and only if ‖u‖2 ≤ λ. We provide pseudocode for solving (21) in Algorithm 4."
        },
        {
            "heading": "5.4 ℓ∞ Regularization",
            "text": "We again letX = Rd but now chooseϕ(x) = λ‖x‖∞. This type of update, similarly toℓ2, zeroes groups of variables, which is handy in finding structurally sparse solutions f r multitask or multiclass problems. Solving theℓ∞ regularized problem amounts to\nmin x 〈u,x〉+ 1 2 〈x,Hx〉+λ‖x‖∞ . (23)\nThe dual of this problem is a modifiedℓ1-projection problem. As in the case ofℓ2 regularization, we introduce an equality constrained variablez= x with associated Lagrange multipliersα ∈ Rd to obtain\nL(x,z,α) = 〈u,x〉+ 1 2 〈x,Hx〉+λ‖z‖∞ + 〈α,x−z〉 .\nPerforming identical manipulations to theℓ2 case, we take derivatives and get thatx=−H−1(u+α) and, similarly, unless‖α‖1 ≤ λ, infzL(x,z,α) =−∞. Thus the dual problem for (23) is\nmax α − 1 2 (u+α)H−1(u+α) s.t. ‖α‖1 ≤ λ .\nWhenH is diagonal we can find the optimalα∗ using the generalizedℓ1-projection in Algorithm 3, then reconstruct the optimalx via x=−H−1(u+α∗)."
        },
        {
            "heading": "5.5 Mixed-norm Regularization",
            "text": "Finally, we combine the above results to show how to solve problems with matrix-valued inputs X ∈ Rd×k, whereX = [x1 · · · xd]⊤. We consider mixed-norm regularization, which is very useful for encouraging sparsity across several tasks (Obozinski et al., 2007). Nowϕ is anℓ1/ℓp norm, that is, ϕ(X) = λ∑di=1‖xi‖p. By imposing anℓ1-norm overp-norms of the rows ofX, entire rows are nulled at once.\nWhenp∈ {2,∞} and the proximalH in (18) is diagonal, the previous algorithms can be readily used to solve the mixed norm problems. We simply maintain diagonal matrix informationfor each of the rows ¯xi of X separately, then solve one of the previous updates for each row independently. We use this form of regularization in our experiments with multiclass prediction prblems in the next section."
        },
        {
            "heading": "6. Experiments",
            "text": "We performed experiments with several real world data sets with differentcharacteristics: the ImageNet image database (Deng et al., 2009), the Reuters RCV1 text classifiation data set (Lewis et al., 2004), the MNIST multiclass digit recognition problem, and the census income data set from the UCI repository (Asuncion and Newman, 2007). For uniformity acrossexperiments, we focus on the completely online (fully stochastic) optimization setting, in which at each iterationthe learning algorithm receives a single example. We measure performance using two metrics: the online loss or error and the test set performance of the predictor the learning algorithm outputs at the end of a single pass through the training data. We also give some results that show how imp sing sparsity constraints (in the form ofℓ1 and mixed-norm regularization) affects the learning algorithm’s performance. One benefit of the ADAGRAD framework is its ability to straightforwardly generalize to\ndomain constraintsX 6=Rd and arbitrary regularization functionsϕ, in contrast to previous adaptive online algorithms.\nWe experiment with RDA (Xiao, 2010), FOBOS(Duchi and Singer, 2009), adaptive RDA, adaptive FOBOS, the Passive-Aggressive (PA) algorithm (Crammer et al., 2006), and AROW (Crammer et al., 2009). To remind the reader, PA is an online learning procedure withthe update\nxt+1 = argmin x [1−yt 〈zt ,x〉]++ λ 2 ‖x−xt‖22 ,\nwhereλ is a regularization parameter. PA’s update is similar to the update employed by AROW (see (9)), but the latter maintains second order information onx. By using a representer theorem it is also possible to derive efficient updates for PA and AROW when the loss is the logistic loss, log(1+ exp(−yt 〈zt ,xt〉)). We thus we compare the above six algorithms using both hinge and logistic loss."
        },
        {
            "heading": "6.1 Text Classification",
            "text": "The Reuters RCV1 data set consists of a collection of approximately 800,000text articles, each of which is assigned multiple labels. There are 4 high-level categories, Economics, Commerce, Medical, and Government (ECAT, CCAT, MCAT, GCAT), and multiple more spcific categories. We focus on training binary classifiers for each of the four major categori s. The input features we use are 0/1 bigram features, which, post word stemming, give data of approximately 2 million dimensions. The feature vectors are very sparse, however, and mostexamples have fewer than 5000 non-zero features.\nWe compare the twelve different algorithms mentioned in the prequel as well asvariants of FOBOS and RDA withℓ1-regularization. We summarize the results of theℓ1-regularized runs as well as AROW and PA in Table 1. The results for both hinge and logistic lossesare qualitatively and quantitatively very similar, so we report results only for training with the hinge loss in Table 1. Each row in the table represents the average of four different experiments in which we hold out 25% of the data for a test set and perform an online pass on the remaining 75% of the data. For RDA and FOBOS, we cross-validate the stepsize parameterη by simply running multiple passes and then choosing the output of the learner that had the fewest mistakes during training. For PA and AROW we chooseλ using the same approach. We use the same regularization multiplier on theℓ1 term for RDA and FOBOS, selected so that RDA achieved approximately 10% non-zero predictors.\nIt is evident from the results presented in Table 1 that the adaptive algorithms (AROW and ADAGRAD) are far superior to non-adaptive algorithms in terms of error rate on testdata. The ADAGRAD algorithms naturally incorporate sparsity as well since they are run withℓ1-regularization, though RDA has significantly higher sparsity levels (PA and AROW do not have any sparsity). Furthermore, although omitted from the table to avoid clutter, ineverytest with the RCV1 corpus, the\nadaptive algorithms outperformed the non-adaptive algorithms. Moreover, both ADAGRAD-RDA and ADAGRAD-Fobos outperform AROW on all the classification tasks. Unregularized RDA and FOBOS attained similar results as did theℓ1-regularized variants (of course without sparsity), but we omit the results to avoid clutter and because they do not give much more understanding."
        },
        {
            "heading": "6.2 Image Ranking",
            "text": "ImageNet (Deng et al., 2009) consists of images organized according to the nouns in the WordNet hierarchy, where each noun is associated on average with more than 500images collected from the web. We selected 15,000 important nouns from the hierarchy and conducted a large scale image ranking task foreachnoun. This approach is identical to the task tackled by Grangier and Bengio (2008) using the Passive-Aggressive algorithm. To solve this problem, we train 15,000 ranking machines using Grangier and Bengio’s visterms features, which represent patches in an image with 79-dimensional sparse vectors. There are approximately 120 patches per image, resulting in a 10,000-dimensional feature space.\nBased on the results in the previous section, we focus on four algorithms for solving this task: AROW, ADAGRAD with RDA updates andℓ1-regularization, vanilla RDA withℓ1, and PassiveAggressive. We use the ranking hinge loss, which is[1−〈x,z1−z2〉]+ whenz1 is ranked above z2. We train a rankerxc for each of the image classes individually, cross-validating the choice of initial stepsize for each algorithm on a small held-out set. To train an individual ranker for class c, at each step of the algorithm we randomly sample a positive imagez1 for the categoryc and an imagez2 from the training set (which with high probability is a negative example for class c) and perform an update on the examplez1− z2. We let each algorithm take 100,000 such steps for each image category, we train four sets of rankers with each algorithm, andthe training set includes approximately 2 million images.\nFor evaluation, we use a distinct test set of approximately 1 million images. To evaluate a set of rankers, we iterate through all 15,000 classes in the data set. For each class we take all the positive image examples in the test set and sample 10 times as many negative image examples.Following Grangier and Bengio, we then rank the set of positive and negative images and compute precisionat-k for k = {1, . . . ,10} and the average precision for each category. The precision-at-k is defined as the proportion of examples ranked in the topk for a categoryc that actually belong toc, and the average precision is the average of the precisions at each position in which a relevant picture appears. Letting Pos(c) denote the positive examples for categoryc andp(i) denote the position of the ith returned picture in list of images sorted by inner product withxc, the average precision is\n1 |Pos(c)|\n|Pos(c)|\n∑ i=1 i p(i) .\nWe compute the mean of each measurement across all classes, performing this twelve times for each of the sets of rankers trained. Table 2 summarizes our results. We donot report variance as the variance was on the order of 10−5 for each algorithm. One apparent characteristic to note from the table is that ADAGRAD RDA achieves higher levels of sparsity than the other algorithms—using only 73% of the input features it achieves very high performance. Moreover, it outperforms all the algorithms in average precision. AROW has better results than the other algorithms in terms of precision-at-k for k≤ 10, though ADAGRAD’s performance catches up to and eventually surpasses AROW’s ask grows."
        },
        {
            "heading": "6.3 Multiclass Optical Character Recognition",
            "text": "In the well-known MNIST multiclass classification data set, we are given 28× pixel imagesai , and the learner’s task is to classify each image as a digit in{0, . . . ,9}. Linear classifiers do not work well on a simple pixel-based representation. Thus we learn classifierbuilt on top of a kernel machine with Gaussian kernels, as do Duchi and Singer (2009), which gives a different (and nonsparse) structure to the feature space in contrast to our previous experiments. In particular, for the ith example andjth feature, the feature value iszi j = K(ai ,a j), exp ( − 12σ2 ∥ ∥ai −a j ∥ ∥ 2 2 ) . We use a support set of approximately 3000 images to compute the kernels and trainedmulticlass predictors, which consist of one vectorxc ∈ R3000 for each classc, giving a 30,000 dimensional problem. There is no known multiclass AROW algorithm. We therefore compare adaptiveRDA with and without mixed-normℓ1/ℓ2 andℓ1/ℓ∞ regularization (see Section 5.5), RDA, and multiclass Passive Aggressive to one another using the multiclass hinge loss (Crammer et al., 2006). For each algorithm we used the first 5000 of 60,000 training examples to choose the stepsizeη (for RDA) andλ (for PA).\nIn Figure 5, we plot the learning curves (cumulative mistakes made) of multiclass PA, RDA, RDA with ℓ1/ℓ2 regularization, adaptive RDA, and adaptive RDA withℓ1/ℓ2 regularization (ℓ1/ℓ∞\nis similar). From the curves, we see that Adaptive RDA seems to have similar perfo mance to PA, and the adaptive versions of RDA are vastly superior to their non-adaptive counterparts. Table 3 further supports this, where we see that the adaptive RDA algorithms outperform their non-adaptive counterparts both in terms of sparsity (the proportion of non-zero rows)and test set error rates."
        },
        {
            "heading": "6.4 Income Prediction",
            "text": "The KDD census income data set from the UCI repository (Asuncion and Newman, 2007) contains census data extracted from 1994 and 1995 population surveys conducted by the U.S. Census Bureau. The data consists of 40 demographic and employment related variables whichare used to predict whether a respondent has income above or below $50,000. We quantize each feature into bins (5 per feature for continuous features) and take products of features togive a 4001 dimensional feature space with 0/1 features. The data is divided into a training set of 199,523 instances and test set of 99,762 test instances.\nAs in the prequel, we compare AROW, PA, RDA, and adaptive RDA with and without ℓ1regularization on this data set. We use the first 10,000 examples of the trainingset to select the step size parametersλ for AROW and PA andη for RDA. We perform ten experiments on random shuffles of the training data. Each experiment consists of a training pass through some proportion of the data (.05, .1, .25, .5, or the entire training set) and computing the test seterror rate of the learned predictor. Table 4 and Figure 6 summarize the results of these experiments. The variance of the test error rates is on the order of 10−6 so we do not report it. As earlier, the table and figure make it clear that the adaptive methods (AROW and ADAGRAD-RDA) give better performance than non-adaptive methods. Further, as detailed in the table, the ADAGRAD methods can give extremely sparse predictors that still give excellent test set performance. This is consistent with the experiments we have seen to this point, where ADAGRAD gives sparse but highly accurate predictors."
        },
        {
            "heading": "6.5 Experiments with Sparsity-Accuracy Tradeoffs",
            "text": "In our final set of experiments, we investigate the tradeoff between the level of sparsity and the classification accuracy for the ADAGRAD-RDA algorithms. Using the same experimental setup as for the initial text classification experiments described in Section 6.1, we record the average test-set performance of ADAGRAD-RDA versus the proportion of features that are non-zero in the predictor ADAGRAD outputs after a single pass through the training data. To achieve this, we run\nADAGRAD with ℓ1-regularization, and we sweep the regularization multiplierλ from 10−8 to 10−1. These values result in predictors ranging from a completely dense predictor to an all-zeros predictor, respectively.\nWe summarize our results in Figure 7, which shows the test set performanceof ADAGRAD for each of the four categories ECAT, CCAT, GCAT, and MCAT. Within each plot, the horizontal black line labeled AROW designates the baseline performance of AROW on thetext classification task, though we would like to note that AROW generates fully dense predictors. The plots all portray a similar story. With high regularization values, ADAGRAD exhibits, as expected, poor performance as it retains no predictive information from the learning task.Put another way, when the regularization value is high ADAGRAD is confined to an overly sparse predictor which exhibits poor generalization. However, as the regularization multiplierλ decreases, the learned predictor becomes less sparse and eventually the accuracy of ADAGRAD exceeds AROW’s accuracy. It is interesting to note that for these experiments, as soon as the predictor resulting from asinglepass\nthrough the data has more than 1% non-zero coefficients, ADAGRAD’s performance matches that of AROW. We also would like to note that the variance in the test-set error rates for these experiments is on the order of 10−6, and we thus do not draw error bars in the graphs. The performance of ADAGRAD as a function of regularization for other sparse data sets, especially in reation to that of AROW, was qualitatively similar to this experiment."
        },
        {
            "heading": "7. Conclusions",
            "text": "We presented a paradigm that adapts subgradient methods to the geometry of the pr blem at hand. The adaptation allows us to derive strong regret guarantees, which forsome natural data distributions achieve better performance guarantees than previous algorithms. Our online regret bounds can be naturally converted into rate of convergence and generalization bounds(Cesa-Bianchi et al., 2004). Our experiments show that adaptive methods, specifically ADAGRAD-FOBOS, ADAGRAD-RDA, and AROW clearly outperform their non-adaptive counterparts. Furthermore, the ADAGRAD fam-\nily of algorithms naturally incorporates regularization and gives very sparse solutions with similar performance to dense solutions. Our experiments with adaptive methods usea diagonal approximation to the matrix obtained by taking outer products of subgradients computed along the run of the algorithm. It remains to be tested whether using the full outer product matrix can further improve performance.\nTo conclude we would like to underscore a possible elegant generalizationthat interpolates between full-matrix proximal functions and diagonal approximations using block diagonal matrices. Specifically, forv∈ Rd let v= [v⊤[1] · · · v⊤[k]]⊤ wherev[i] ∈ Rdi are subvectors ofv with ∑ki=1di = d. We can define the associated block-diagonal approximation to the outer product matrix∑tτ=1gτg⊤τ by\nGt = t\n∑ τ=1\n\n     \ngτ,[1]g ⊤ τ,[1] 0 · · · 0\n0 gτ,[2]g ⊤ τ,[2] . . . 0 ...\n... .. . 0 0 · · · 0 gτ,[k]g⊤τ,[k]\n\n      .\nIn this case, a combination of Theorems 5 and 7 gives the next corollary.\nCorollary 12 Let Gt be the block-diagonal outer product matrix defined above and the sequence {xt} be defined by the RDA update of (3) withψt(x) = 〈 x,G1/2t x 〉 . Then, for any x∗ ∈ X ,\nRφ(T)≤ 1 η max i ∥ ∥ ∥ x∗[i] ∥ ∥ ∥ 2 2 tr(G1/2T )+η tr(G 1/2 T ).\nA similar bound holds for composite mirror-descent updates, and it is straightforward to get infimal equalities similar to those in Corollary 11 with the infimum taken over block-diagonal matrices. Such an algorithm can interpolate between the computational simplicity of the diagonal proximal functions and the ability of full matrices to capture correlation in the gradient vctors.\nA few open questions stem from this line of research. The first is whetherwe canefficiently use full matrices in the proximal functions, as in Section 4. A second open issue whether nonEuclidean proximal functions, such as the relative entropy, can be used. W also think that the strongly convex case—whenft or ϕ is strongly convex—presents interesting challenges that we have not completely resolved. We hope to investigate both empirical and formal extensions of this work in the near future."
        },
        {
            "heading": "Acknowledgments",
            "text": "There are many people to whom we owe our sincere thanks for this research. Fernando Pereira helped push us in the direction of working on adaptive online methods and has been a constant source of discussion and helpful feedback. Samy Bengio provided uswith a processed version of the ImageNet data set and was instrumental in helping to get our experiments run ing, and Adam Sadovsky gave many indispensable coding suggestions. The anonymousreviewers also gave several suggestions that improved the quality of the paper. Lastly, Sam Roweis was asounding board for some of our earlier ideas on the subject, and we will miss him dearly."
        },
        {
            "heading": "Appendix A. Full Matrix Motivating Example",
            "text": "As in the diagonal case, as the adversary we chooseε > 0 and on roundst = 1, . . . ,η2/ε2 play the vector±v1. After the firstη2/ε2 rounds, the adversary simply cycles through the vectorsv2, . . . ,vd. Thus, for Zinkevich’s projected gradient, we havext = αt,1v1 for some multiplierαt,1 > 0 when t ≤ η2/ε2. After the firstη2/ε2 rounds, we perform the updates\nxt+1 = Π‖x‖2≤ √ d\n(\nxt + η√ t vi\n)\nfor some indexi, but as in the diagonal case,η/ √\nt ≤ ε, and by orthogonality ofvi ,v j , we have xt = Vαt for someαt 0, and the projection step can only shrink the multiplierαt,i for index i. Thus, each coordinate incurs loss at least 1/(2ε), and projected gradient descent suffers losses Ω(d/ε).\nOn the other hand, ADAGRAD suffers loss at mostd. Indeed, sinceg1 = v1 and‖v1‖2 = 1, we haveG21 = v1v ⊤ 1 v1v ⊤ 1 = v1v ⊤ 1 = G1, soG1 = G † 1 = G 1 2 1 , and\nx2 = x1+G † 1 = x1+v1v ⊤ 1 v1 = x1+v1.\nSince〈x2,v1〉= 1, we see that ADAGRAD suffers no loss (andGt = G1) until a vectorzt =±vi for i 6= 1 is played by the adversary. However, an identical argument shows that Gt is simply updated to v1v⊤1 + viv ⊤ i , in which casext = v1+ vi . Indeed, an inductive argument shows that until all the\nvectorsvi are seen, we have‖xt‖2 < √ d by orthogonality, and eventually we have\nxt = d\n∑ i=1\nvi and ‖xt‖2 = √ d\n∑ i=1\n‖vi‖22 = √ d\nso thatxt ∈ X = {x : ‖x‖2 ≤ √\nd} for ADAGRAD for all t. All future predictions thus achieve margin 1 and suffer no loss."
        },
        {
            "heading": "Appendix B. Technical Lemmas",
            "text": "Lemma 13 Let A B 0 be symmetric d×d PSD matrices. Then A1/2 B1/2.\nProof This is Example 3 of Davis (1963). We include a proof for convenience ofthe reader. Let λ be any eigenvalue (with corresponding eigenvectorx) of A1/2−B1/2; we show thatλ ≥ 0. ClearlyA1/2x−λx= B1/2x. Taking the inner product of both sides withA1/2x, we have ∥ ∥A1/2x ∥ ∥\n2 2−\nλ 〈 A1/2x,x 〉 = 〈 A1/2x,B1/2x 〉\n. We use the Cauchy-Schwarz inequality: ∣ ∣ ∣ ∣ ∥ ∥ ∥ A1/2x ∥ ∥ ∥ 2 2 −λ 〈 A1/2x,x 〉 ∣ ∣ ∣ ∣ ≤ ∥ ∥ ∥ A1/2x ∥ ∥ ∥ 2 ∥ ∥ ∥ B1/2x ∥ ∥ ∥ 2 = √ 〈Ax,x〉〈Bx,x〉 ≤ 〈Ax,x〉= ∥ ∥ ∥ A1/2x ∥ ∥ ∥ 2 2\nwhere the last inequality follows from the assumption thatA B. Thus we must haveλ 〈 A1/2x,x 〉 ≥ 0, which impliesλ ≥ 0. The gradient of the function tr(Xp) is easy to compute for integer values ofp. However, whenp is real we need the following lemma. The lemma tacitly uses the fact that there is a unique positive semidefiniteXp whenX 0 (Horn and Johnson, 1985, Theorem 7.2.6).\nLemma 14 Let p∈ R and X≻ 0. Then∇Xtr(Xp) = pXp−1.\nProof We do a first order expansion of(X+A)p whenX ≻ 0 andA is symmetric. LetX =UΛU⊤ be the symmetric eigen-decomposition ofX andVDV⊤ be the decomposition ofΛ−1/2U⊤AUΛ−1/2. Then\n(X+A)p = (UΛU⊤+A)p =U(Λ+U⊤AU)pU⊤ =UΛp/2(I +Λ−1/2U⊤AUΛ−1/2)pΛp/2U⊤\n=UΛp/2V⊤(I +D)pVΛp/2U⊤ =UΛp/2V⊤(I + pD+o(D))VΛp/2U⊤\n=UΛpU⊤+ pUΛp/2V⊤DVΛp/2U⊤+o(UΛ−/2V⊤DVΛp/2U⊤)\n= Xp+UΛ(p−1)/2U⊤AUΛ(p−1)/2U⊤+o(A) = Xp+ pX(p−1)/2AX(p−1)/2+o(A).\nIn the above,o(A) is a matrix that goes to zero faster thanA→ 0, and the second line follows via a first-order Taylor expansion of(1+di)p. From the above, we immediately have\ntr((X+A)p) = trXp+ ptr(Xp−1A)+o(trA),\nwhich completes the proof."
        },
        {
            "heading": "Appendix C. Proof of Lemma 4",
            "text": "We prove the lemma by considering an arbitrary real-valued sequence{ai} and its vector representationa1:i = [a1 · · · ai ]. We are next going to show that\nT\n∑ t=1 a2t ‖a1:t‖2 ≤ 2‖a1:T‖2 , (24)\nwhere we define00 = 0. We use induction onT to prove inequality (24). ForT = 1, the inequality trivially holds. Assume the bound (24) holds true forT −1, in which case\nT\n∑ t=1 a2t ‖a1:t‖2 = T−1 ∑ t=1 a2t ‖a1:t‖2 + a2T ‖a1:T‖2 ≤ 2‖a1:T−1‖2+ a2T ‖a1:T‖2 ,\nwhere the inequality follows from the inductive hypothesis. We definebT = ∑Tt=1a2t and use concavity to obtain that √ bT −a2T ≤ √ bT −a2T 12√bT so long asbT −a 2 T ≥ 0.2 Thus,\n2‖a1:T−1‖2+ a2T ‖a1:T‖2 = 2 √ bT −a2T + a2T√ bT ≤ 2 √ bT = 2‖a1:T‖2 .\nHaving proved the bound (24), we note that by construction thatst,i = ‖g1:t,i‖2, so\nT\n∑ t=1\n〈 gt ,diag(st) −1gt 〉 = T\n∑ t=1\nd\n∑ i=1 g2t,i ‖g1:t,i‖2 ≤ 2 d ∑ i=1 ‖g1:T,i‖2 .\n2. We note that we use an identical technique in the full-matrix case. See Lemma 8."
        },
        {
            "heading": "Appendix D. Proof of Lemmas 8 and 9",
            "text": "We begin with the more difficult proof of Lemma 8. Proof of Lemma 8 The core of the proof is based on the concavity of the function tr(A1/2). However, careful analysis is required asA might not be strictly positive definite. We also use the previous lemma which implies that the gradient of tr(A1/2) is 12A\n−1/2 whenA≻ 0. First, Ap is matrix-concave forA≻ 0 and 0≤ p≤ 1 (see, for example, Corollary 4.1 in Ando,\n1979 or Theorem 16.1 in Bondar, 1994). That is, forA,B≻ 0 andα ∈ [0,1] we have\n(αA+(1−α)B)p αAp+(1−α)Bp . (25)\nNow suppose simplyA,B 0 (but neither is necessarily strict). Then for anyδ > 0, we have A+δI ≻ 0 andB+δI ≻ 0 and therefore\n(α(A+δI)+(1−α)(B+δI))p α(A+δI)p+(1−α)(B+δI)p αAp+(1−α)Bp ,\nwhere we used Lemma 13 for the second matrix inequality. Moreover,αA+ (1− α)B+ δI → αA+(1−α)B asδ → 0. SinceAp is continuous (when we use the unique PSD root), this line of reasoning proves that (25) holds forA,B 0. Thus, we proved that\ntr((αA+(1−α)B)p)≥ α tr(Ap)+(1−α) tr(Bp) for 0≤ p≤ 1 .\nRecall now that Lemma 14 implies that the gradient of tr(A1/2) is 12A −1/2 whenA≻ 0. There-\nfore, from the concavity ofA1/2 and the form of its gradient, we can use the standard first-order inequality for concave functions so that for anyA,B≻ 0,\ntr(A1/2)≤ tr(B1/2)+ 1 2 tr(B−1/2(A−B)) . (26)\nLet A = B− νgg⊤ 0 and suppose only thatB 0. We must take some care sinceB−1/2 may not necessarily exist, and the above inequality does not hold true in the pseudo-inverse sense when B 6≻ 0. However, for anyδ> 0 we know that 2∇B tr((B+δI)1/2)= (B+δI)−1/2, andA−B=−νgg⊤. From (26) and Lemma 13, we have\n2tr(B− tgg⊤)1/2 = 2tr(A1/2) ≤ 2tr((A+δI)1/2) ≤ 2tr(B+δI)1/2−ν tr((B+δI)−1/2gg⊤) . (27)\nNote thatg∈ Range(B), because if it were not, we could choose someu with Bu= 0 and〈g,u〉 6= 0, which would give 〈 u,(B−cgg⊤)u 〉\n=−c〈g,u〉2 < 0, a contradiction. Now letB=V diag(λ)V⊤ be the eigen-decomposition ofB. Sinceg∈ Range(B),\ng⊤(B+δI)−1/2g = g⊤V diag ( 1/ √ λi +δ ) V⊤g\n= ∑ i:λi>0 1√ λi +δ (g⊤vi) 2 −→ δ↓0 ∑i:λi>0 λ−1/2i (g ⊤vi) 2 = g⊤(B†)1/2g .\nThus, by takingδ ↓ 0 in (27), and since both tr(B+ δI)1/2 and tr((B+ δI)−1/2gg⊤) are evidently continuous inδ, we complete the proof.\nProof of Lemma 9 We begin by noting thatδ2I gg⊤, so from Lemma 13 we get(A+gg⊤)1/2 (A+ δ2I)1/2. SinceA and I are simultaneously diagonalizable, we can generalize the inequality√\na+b≤√a+ √ b, which holds fora,b≥ 0, to positive semi-definite matrices, thus,\n(A+δ2I)1/2 A1/2+δI .\nTherefore, ifA+gg⊤ is of full rank, we have(A+gg⊤)−1/2 (A1/2+ δI)−1 (Horn and Johnson, 1985, Corollary 7.7.4(a)). Sinceg∈ Range((A+gg⊤)1/2), we can apply an analogous limiting argument to the one used in the proof of Lemma 8 and discard all zero eigenvalus ofA+gg⊤, which completes the lemma."
        },
        {
            "heading": "Appendix E. Solution to Problem (15)",
            "text": "We prove here a technical lemma that is useful in characterizing the solution of the ptimization problem below. Note that the second part of the lemma implies that we can treat the inverse of the solution matrixS−1 asS†. We consider solving\nmin S\ntr(S−1A) subject to S 0, tr(S)≤ c where A 0 . (28)\nLemma 15 If A is of full rank, then the minimizer of (28) is S= cA 1 2/ tr(A 1 2 ). If A is not of full rank, then setting S= cA 1 2/ tr(A 1 2 ) gives\ntr(S†A) = inf S\n{ tr(S−1A) : S 0, tr(S)≤ c } .\nIn either case,tr(S†A) = tr(A 1 2 )2/c.\nProof Both proofs rely on constructing the Lagrangian for (28). We introduceθ ∈ R+ for the trace constraint andZ 0 for the positive semidefinite constraint onS. In this case, the Lagrangian is\nL(S,θ,Z) = tr(S−1A)+θ(tr(S)−c)− tr(SZ).\nThe derivative ofL with respect toS is\n−S−1AS−1+θI −Z. (29)\nIf S is full rank, then to satisfy the generalized complementarity conditions for the problem (Boyd and Vandenberghe, 2004), we must haveZ = 0. Therefore, we getS−1AS−1 = θI . We now can multiply by Son the right and the left to get thatA= θS2, which implies thatS∝ A12 . If A is of full rank, the optimal solution forS≻ 0 forcesθ to be positive so that tr(S) = c. This yields the solution S= cA 1 2/ tr(A 1 2 ). In order to verify optimality of this solution, we setZ = 0 andθ = c−2 tr(A1/2)2 which gives∇SL(S,θ,Z) = 0, as is indeed required. Suppose now thatA is not full rank and that\nA= Q\n[\nΛ 0 0 0\n]\nQ⊤\nis the eigen-decomposition ofA. Let n be the dimension of the null-space ofA (so the rank ofA is d−n). Define the variables\nZ(θ) = [ 0 0 0 θI ] , S(θ,δ) = 1√ θ Q [ Λ 12 0 0 δI ] Q⊤, S(δ) = c tr(A 1 2 )+δn Q [ Λ 12 0 0 δI ] Q⊤.\nIt is easy to see that trS(δ) = c, and\nlim δ→0\ntr(S(δ)−1A) = tr(S(0)†A) = tr(A 1 2 ) tr(Λ 1 2 )/c= tr(A 1 2 )2/c.\nFurther, letg(θ) = infSL(S,θ,Z(θ)) be the dual of (28). From the above analysis and (29), it is evident that\n−S(θ,δ)−1AS(θ,δ)−1+θI −Z(θ) =−θQ [ Λ− 12 ΛΛ− 12 0 0 δ−2I ·0 ] Q⊤+θI − [ 0 0 0 θI ] = 0.\nSoS(θ,δ) achieves the infimum in the dual foranyδ > 0, tr(S(0)Z(θ)) = 0, and\ng(θ) = √ θ tr(Λ 1 2 )+ √ θ tr(Λ 1 2 )+ √ θδn−θc.\nSettingθ= tr(Λ 12 )2/c2 givesg(θ) = tr(Λ 12 )2/c−δntr(Λ 12 )/c. Takingδ→ 0 givesg(θ) = tr(A12 )2/c, which means that limδ→0 tr(S(δ)−1A) = tr(A 1 2 )2/c = g(θ). Thus the duality gap for the original problem is 0 soS(0) is the limiting solution. The last statement of the lemma is simply pluggingS† = (A†) 1 2 tr(A 1 2 )/c in to the objective being minimized."
        },
        {
            "heading": "Appendix F. Proofs of Propositions 2 and 3",
            "text": "We begin with the proof of Proposition 2. The proof essentially builds upon Xiao (2010) and Nesterov (2009), with some modification to deal with the indexing ofψt . We include the proof for completeness. Proof of Proposition 2Defineψ∗t to be the conjugate dual oftϕ(x)+ψt(x)/η:\nψ∗t (g) = sup x∈X\n{ 〈g,x〉− tϕ(x)− 1 η ψt(x) } .\nSinceψt/η is 1/η-strongly convex with respect to the norm‖·‖ψt , the functionψ ∗ t hasη-Lipschitz continuous gradients with respect to‖·‖ψ∗t :\n‖∇ψ∗t (g1)−∇ψ∗t (g2)‖ψt ≤ η‖g1−g2‖ψ∗t (30)\nfor anyg1,g2 (see, e.g., Nesterov, 2005, Theorem 1 or Hiriart-Urruty and Lemar´ chal, 1996, Chapter X). Further, a simple argument with the fundamental theorem of calculus give that if f has L-Lipschitz gradients,f (y)≤ f (x)+ 〈∇ f (x),y−x〉+(L/2)‖y−x‖2, and\n∇ψ∗t (g) = argmin x∈X\n{\n−〈g,x〉+ tϕ(x)+ 1 η ψt(x) } . (31)\nUsing the bound (30) and identity (31), we can give the proof of the corollary. Indeed, letting gt ∈ ∂ ft(xt) and definingzt = ∑tτ=1gτ, we have\nT\n∑ t=1\nft(xt)+ϕ(xt)− ft(x∗)−ϕ(x∗)\n≤ T\n∑ t=1\n〈gt ,xt −x∗〉−ϕ(x∗)+ϕ(xt)\n≤ T\n∑ t=1 〈gt ,xt〉+ϕ(xt)+sup x∈X\n{\n− T\n∑ t=1 〈gt ,x〉−Tϕ(x)− 1 η ψT(x)\n}\n+ψT(x∗)\n= 1 η ψT(x∗)+ T ∑ t=1 〈gt ,xt〉+ϕ(xt)+ψ∗T (−zT) .\nSinceψt+1 ≥ ψt , it is clear that\nψ∗T(−zT) =− T\n∑ t=1 〈gt ,xT+1〉−Tϕ(xT+1)− 1 η ψT(xT+1)\n≤− T\n∑ t=1 〈gt ,xT+1〉− (T −1)ϕ(xT+1)−ϕ(xT+1)− 1 η ψT−1(xT+1)\n≤ sup x∈X\n(\n−〈zT ,x〉− (T −1)ϕ(x)− 1 η ψT−1(x) ) −ϕ(xT+1) = ψ∗T−1(−zT)−ϕ(xT+1).\nThe Lipschitz continuity of∇ψ∗t , the identity (31), and the fact thatzT −zT−1 =−gT give T\n∑ t=1\nft(xt)+ϕ(xt+1)− ft(x∗)−ϕ(x∗)\n≤ 1 η ψT(x∗)+ T ∑ t=1 〈gt ,xt〉+ϕ(xt+1)+ψ∗T−1(−zT)−ϕ(xT+1)\n≤ 1 η ψT(x∗)+ T ∑ t=1 〈gt ,xt〉+ϕ(xt+1)−ϕ(xT+1)\n+ψ∗T−1(−zT−1)− 〈 ∇ψ∗T−1(zT−1),gT 〉 + η 2 ‖gT‖2ψ∗T−1\n= 1 η ψT(x∗)+ T−1 ∑ t=1 〈gt ,xt〉+ϕ(xt+1)+ψ∗T−1(−zT−1)+ η 2 ‖gT‖2ψ∗T−1 .\nWe can repeat the same sequence of steps that gave the last equality to seethat\nT\n∑ t=1 ft(xt)+ϕ(xt+1)− ft(x∗)−ϕ(x∗)≤ 1 η ψT(x∗)+ η 2\nT\n∑ t=1 ‖gt‖2ψ∗t−1 +ψ ∗ 0(−z0).\nRecalling thatx1 = argminx∈X {ϕ(x)} and thatψ∗0(0) = 0 completes the proof.\nWe now turn to the proof of Proposition 3. We begin by stating and fully proving a (essentially) immediate corollary to Lemma 2.3 of Duchi et al. (2010).\nLemma 16 Let{xt} be the sequence defined by the update (4) and assume that Bψt (·, ·) is strongly convex with respect to a norm‖·‖ψt . Let‖·‖ψ∗t be the associated dual norm. Then for any x ∗,\nη( ft(xt)− ft(x∗))+η(ϕ(xt+1)−ϕ(x∗))≤ Bψt (x∗,xt)−Bψt (x∗,xt+1)+ η2\n2\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t\nProof The optimality ofxt+1 for (4) implies for allx∈ X andϕ′(xt+1) ∈ ∂ϕ(xt+1) 〈\nx−xt+1,η f ′(xt)+∇ψt(xt+1)−∇ψt(xt)+ηϕ′(xt+1) 〉 ≥ 0. (32)\nIn particular, this obtains forx= x∗. From the subgradient inequality for convex functions, we have ft(x∗)≥ ft(xt)+ 〈 f ′t (xt),x∗−xt〉, or ft(xt)− ft(x∗)≤ 〈 f ′t (xt),xt −x∗〉, and likewise forϕ(xt+1). We thus have\nη [ ft(xt)+ϕ(xt+1)− ft(x∗)−ϕ(x∗)] ≤ η 〈\nxt −x∗, f ′t (xt) 〉 +η 〈 xt+1−x∗,ϕ′(xt+1) 〉\n= η 〈 xt+1−x∗, f ′t (xt) 〉 +η 〈 xt+1−x∗,ϕ′(xt+1) 〉 +η 〈 xt −xt+1, f ′t (xt) 〉 = 〈\nx∗−xt+1,∇ψt(xt)−∇ψt(xt+1)−η f ′t (xt)−ηϕ′(xt+1) 〉 + 〈x∗−xt+1,∇ψt(xt+1)−∇ψt(xt)〉+η 〈 xt −xt+1, f ′t (xt) 〉 .\nNow, by (32), the first term in the last equation is non-positive. Thus we hav that\nη [ ft(xt)+ϕ(xt+1)− ft(x∗)−ϕ(x∗)] ≤ 〈x∗−xt+1,∇ψt(xt+1)−∇ψt(xt)〉+η 〈 xt −xt+1, f ′t (xt) 〉\n= Bψt (x ∗,xt)−Bψt (xt+1,xt)−Bψt (x∗,xt+1)+η 〈 xt −xt+1, f ′t (xt) 〉 = Bψt (x ∗,xt)−Bψt (xt+1,xt)−Bψt (x∗,xt+1)+η 〈 η− 1 2 (xt −xt+1), √ η f ′t (xt) 〉\n≤ Bψt (x∗,xt)−Bψt (xt+1,xt)−Bψt (x∗,xt+1)+ 1 2 ‖xt −xt+1‖2ψt +\nη2\n2\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t\n≤ Bψt (x∗,xt)−Bψt (x∗,xt+1)+ η2\n2\n∥ ∥ f ′t (xt) ∥ ∥ 2 ψ∗t .\nIn the above, the first equality follows from simple algebra with Bregman divergences, the second to last inequality follows from Fenchel’s inequality applied to the conjugate functio s 12 ‖·‖ 2 ψt and 1 2 ‖·‖ 2 ψ∗t (Boyd and Vandenberghe, 2004, Example 3.27), and the last inequality fol ows from the assumed strong convexity ofBψt with respect to the norm‖·‖ψt .\nProof of Proposition 3Sum the equation in the conclusion of Lemma 16."
        },
        {
            "heading": "Appendix G. Derivations of Algorithms",
            "text": "In this appendix, we give the formal derivations of the solution to the ADAGRAD update forℓ1regularization and projection to anℓ1-ball, as described originally in Section 5.\nG.1 ℓ1-regularization\nWe give the derivation for the primal-dual subgradient update, as composite mirror-descent is entirely similar. We need to solve update (3), which amounts to\nmin x η〈ḡt ,x〉+ 1 2t δ‖x‖22+ 1 2t 〈x,diag(st)x〉+ηλ‖x‖1 .\nLet x̂ denote the optimal solution of the above optimization problem. Standard subgradient calculus implies that when|ḡt,i | ≤ λ the solution is ˆxi = 0. Similarly, when ¯gt,i < −λ, then x̂i > 0, the objective is differentiable, and the solution is obtained by setting the gradientto zero:\nηḡt,i + Ht,ii\nt x̂i +ηλ = 0 , so that ˆxi = ηt Ht,ii (−ḡt,i −λ) .\nLikewise, when ¯gt,i > λ then x̂i < 0, and the solution is ˆxi = ηtHt,ii (−ḡt,i +λ). Combining the three cases, we obtain the simple update (19) forxt+1,i .\nG.2 ℓ1-ball projections\nThe derivation we give is somewhat terse, and we refer the interested reader to Brucker (1984) or Pardalos and Rosen (1990) for more depth. Recall that our original problem (20) is symmetric in its objective and constraints, so we assume without loss of generality thatv 0 (otherwise, we reverse the sign of each negative component inv, then flip the sign of the corresponding component in the solution vector). This gives\nmin z 1 2 ‖z−v‖22 s.t. 〈a,z〉 ≤ c, z 0 .\nClearly, if〈a,v〉≤ c the optimalz∗= v, hence we assume that〈 ,v〉> c. We also assume without loss of generality thatvi/ai ≥ vi+1/ai+1 for simplicity of our derivation. (We revisit this assumption at the end of the derivation.) Introducing Lagrange multipliersθ ∈R+ for the constraint that〈a,z〉 ≤ c andα ∈ Rd+ for the positivity constraint onz, we get\nL(z,α,θ) = 1 2 ‖z−v‖22+θ(〈a,z〉−c)−〈α,z〉 .\nComputing the gradient ofL , we have∇zL(z,α,θ) = z− v+ θa−α. Suppose that we knew the optimal θ∗ ≥ 0. Using the complementarity conditions onz andα for optimality of z (Boyd and Vandenberghe, 2004), we see that the solutionz∗i satisfies\nz∗i =\n{ vi −θ∗ai if vi ≥ θ∗ai 0 otherwise.\nAnalogously, the complimentary conditions on〈a,z〉 ≤ c show that givenθ∗, we have d\n∑ i=1\nai [vi −θ∗ai ]+ = c or d\n∑ i=1 a2i\n[\nvi ai −θ∗\n]\n+\n= c .\nConversely, had we obtained a valueθ ≥ 0 satisfying the above equation, thenθ would evidently induce the optimalz∗ through the equationzi = [vi −θai ]+.\nNow, let ρ be the largest index in{1, . . . ,d} such thatvi −θ∗ai > 0 for i ≤ ρ andvi −θ∗ai ≤ 0 for i > ρ. From the assumption thatvi/ai ≤ vi+1/ai+1, we havevρ+1/aρ+1 ≤ θ∗ < vρ/aρ. Thus, had we known the last non-zero indexρ, we would have obtained\nρ\n∑ i=1 aivi − vρ aρ\nρ\n∑ i=1\na2i = ρ\n∑ i=1 a2i\n(\nvi ai − vρ aρ\n)\n< c ,\nρ\n∑ i=1 aivi − vρ+1 aρ+1\nρ\n∑ i=1\na2i = ρ+1\n∑ i=1 a2i\n(\nvi ai − vρ+1 aρ+1\n)\n≥ c .\nGivenρ satisfying the above inequalities, we can reconstruct the optimalθ∗ by noting that the latter inequality should equalc exactly when we replacevρ/aρ with θ, that is,\nθ∗ = ∑ ρ i=1aivi −c ∑ρi=1a2i . (33)\nThe above derivation results in the following procedure (when〈a,v〉 > c). We sortv in descending order ofvi/ai and find the largest indexρ such that∑ ρ i=1aivi − (vρ/aρ)∑ ρ−1 i=1 a 2 i < c. We then reconstructθ∗ using equality (33) and return the soft-thresholded values ofvi (see Algorithm 3). It is easy to verify that the algorithm can be implemented inO(d logd) time. A randomized search with bookkeeping (Pardalos and Rosen, 1990) can be straightforwardly used to derive a linear time algorithm."
        }
    ],
    "title": "Adaptive Subgradient Methods for Online Learning and Stochastic Optimization∗",
    "year": 2011
}