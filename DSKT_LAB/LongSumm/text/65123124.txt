id: SP:720f2681f895bcdde7301ac9e549a7553d4d81db
title: KRONECKER RECURRENT UNITS
authors: [{'affiliations': [], 'name': 'Cijo Jose'}, {'affiliations': [], 'name': 'Moustapha Cissé'}]
abstractText: Our work addresses two important issues with recurrent neural networks: (1) they are over-parametrized, and (2) the recurrent weight matrix is ill-conditioned. The former increases the sample complexity of learning and the training time. The latter causes the vanishing and exploding gradient problem. We present a flexible recurrent neural network model called Kronecker Recurrent Units (KRU). KRU achieves parameter efficiency in RNNs through a Kronecker factored recurrent matrix. It overcomes the ill-conditioning of the recurrent matrix by enforcing soft unitary constraints on the factors. Thanks to the small dimensionality of the factors, maintaining these constraints is computationally efficient. Our experimental results on seven standard data-sets reveal that KRU can reduce the number of parameters by three orders of magnitude in the recurrent weight matrix compared to the existing recurrent models, without trading the statistical performance. These results in particular show that while there are advantages in having a high dimensional recurrent space, the capacity of the recurrent part of the model can be dramatically reduced.
references: [{'authors': ['Martı́n Abadi', 'Ashish Agarwal', 'Paul Barham', 'Eugene Brevdo', 'Zhifeng Chen', 'Craig Citro', 'Greg S Corrado', 'Andy Davis', 'Jeffrey Dean', 'Matthieu Devin'], 'title': 'Tensorflow: Large-scale machine learning on heterogeneous distributed systems', 'venue': 'arXiv preprint arXiv:1603.04467,', 'year': 2016}, {'authors': ['Martin Arjovsky', 'Amar Shah', 'Yoshua Bengio'], 'title': 'Unitary evolution recurrent neural networks', 'venue': 'In International Conference on Machine Learning,', 'year': 2016}, {'authors': ['Jimmy Ba', 'Rich Caruana'], 'title': 'Do deep nets really need to be deep? In Advances in neural information processing', 'year': 2014}, {'authors': ['Jimmy Ba', 'Roger Grosse', 'James Martens'], 'title': 'Distributed second-order optimization using kroneckerfactored approximations', 'year': 2016}, {'authors': ['Antonio Valerio Miceli Barone'], 'title': 'Low-rank passthrough neural networks', 'venue': 'arXiv preprint arXiv:1603.03116,', 'year': 2016}, {'authors': ['Yoshua Bengio', 'Patrice Simard', 'Paolo Frasconi'], 'title': 'Learning long-term dependencies with gradient descent is difficult', 'venue': 'IEEE transactions on neural networks,', 'year': 1994}, {'authors': ['Nicolas Boulanger-Lewandowski', 'Yoshua Bengio', 'Pascal Vincent'], 'title': 'Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription', 'venue': 'arXiv preprint arXiv:1206.6392,', 'year': 2012}, {'authors': ['Wenlin Chen', 'James Wilson', 'Stephen Tyree', 'Kilian Weinberger', 'Yixin Chen'], 'title': 'Compressing neural networks with the hashing trick', 'venue': 'In International Conference on Machine Learning,', 'year': 2015}, {'authors': ['Junyoung Chung', 'Caglar Gulcehre', 'KyungHyun Cho', 'Yoshua Bengio'], 'title': 'Empirical evaluation of gated recurrent neural networks on sequence modeling', 'venue': 'arXiv preprint arXiv:1412.3555,', 'year': 2014}, {'authors': ['Junyoung Chung', 'Caglar Gülçehre', 'Kyunghyun Cho', 'Yoshua Bengio'], 'title': 'Gated feedback recurrent neural networks', 'venue': 'In ICML, pp. 2067–2075,', 'year': 2015}, {'authors': ['Moustapha Cisse', 'Piotr Bojanowski', 'Edouard Grave', 'Yann Dauphin', 'Nicolas Usunier'], 'title': 'Parseval networks: Improving robustness to adversarial examples', 'venue': 'arXiv preprint arXiv:1704.08847,', 'year': 2017}, {'authors': ['Matthieu Courbariaux', 'Jean-Pierre David', 'Yoshua Bengio'], 'title': 'Low precision storage for deep learning', 'venue': 'Arxiv: 1412.7024,', 'year': 2014}, {'authors': ['Misha Denil', 'Babak Shakibi', 'Laurent Dinh', 'Nando de Freitas'], 'title': 'Predicting parameters in deep learning', 'venue': 'In Advances in Neural Information Processing Systems,', 'year': 2013}, {'authors': ['Jeffrey L Elman'], 'title': 'Finding structure in time', 'venue': 'Cognitive science,', 'year': 1990}, {'authors': ['John S Garofolo', 'Lori F Lamel', 'William M Fisher', 'Jonathon G Fiscus', 'David S Pallett'], 'title': 'Darpa timit acoustic-phonetic continous speech corpus cd-rom. nist speech disc 1-1.1', 'venue': 'NASA STI/Recon technical report n,', 'year': 1993}, {'authors': ['Alex Graves', 'Jürgen Schmidhuber'], 'title': 'Framewise phoneme classification with bidirectional lstm and other neural network architectures', 'venue': 'Neural Networks,', 'year': 2005}, {'authors': ['Roger Grosse', 'James Martens'], 'title': 'A kronecker-factored approximate fisher matrix for convolution layers', 'venue': 'In International Conference on Machine Learning,', 'year': 2016}, {'authors': ['Moritz Hardt', 'Tengyu Ma', 'Benjamin Recht'], 'title': 'Gradient descent learns linear dynamical systems', 'venue': 'arXiv preprint arXiv:1609.05191,', 'year': 2016}, {'authors': ['Mikael Henaff', 'Arthur Szlam', 'Yann LeCun'], 'title': 'Orthogonal RNNs and long-memory tasks', 'venue': 'arXiv preprint arXiv:1602.06662,', 'year': 2016}, {'authors': ['Geoffrey Hinton', 'Li Deng', 'Dong Yu', 'George E Dahl', 'Abdel-rahman Mohamed', 'Navdeep Jaitly', 'Andrew Senior', 'Vincent Vanhoucke', 'Patrick Nguyen', 'Tara N Sainath'], 'title': 'Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups', 'venue': 'IEEE Signal Processing Magazine,', 'year': 2012}, {'authors': ['Sepp Hochreiter'], 'title': 'Untersuchungen zu dynamischen neuronalen Netzen. PhD thesis, diploma thesis, institut für informatik, lehrstuhl prof. brauer, technische universität münchen', 'year': 1991}, {'authors': ['Sepp Hochreiter', 'Jürgen Schmidhuber'], 'title': 'Long short-term memory', 'venue': 'Neural computation,', 'year': 1997}, {'authors': ['Herbert Jaeger'], 'title': 'The echo state approach to analysing and training recurrent neural networks-with an erratum note', 'venue': 'Bonn, Germany: German National Research Center for Information Technology GMD Technical Report,', 'year': 2001}, {'authors': ['Li Jing', 'Yichen Shen', 'Tena Dubcek', 'John Peurifoy', 'Scott Skirlo', 'Yann LeCun', 'Max Tegmark', 'Marin Soljačić'], 'title': 'Tunable efficient unitary neural networks (EUNN) and their application to RNNs', 'venue': 'Proceedings of the 34th International Conference on Machine Learning,', 'year': 2017}, {'authors': ['Cijo Jose', 'François Fleuret'], 'title': 'Scalable metric learning via weighted approximate rank component analysis', 'venue': 'In European Conference on Computer Vision,', 'year': 2016}, {'authors': ['Diederik Kingma', 'Jimmy Ba'], 'title': 'Adam: A method for stochastic optimization', 'venue': 'arXiv preprint arXiv:1412.6980,', 'year': 2014}, {'authors': ['Alex Krizhevsky', 'Ilya Sutskever', 'Geoffrey E Hinton'], 'title': 'Imagenet classification with deep convolutional neural networks. In Advances in neural information processing', 'year': 2012}, {'authors': ['Quoc Le', 'Tamás Sarlós', 'Alex Smola'], 'title': 'Fastfood-approximating kernel expansions in loglinear time', 'venue': 'In Proceedings of the international conference on machine learning,', 'year': 2013}, {'authors': ['Quoc V Le', 'Navdeep Jaitly', 'Geoffrey E Hinton'], 'title': 'A simple way to initialize recurrent networks of rectified linear units', 'venue': 'arXiv preprint arXiv:1504.00941,', 'year': 2015}, {'authors': ['Yann LeCun', 'John S Denker', 'Sara A Solla'], 'title': 'Optimal brain damage', 'venue': 'In Advances in neural information processing systems,', 'year': 1990}, {'authors': ['Mitchell P Marcus', 'Mary Ann Marcinkiewicz', 'Beatrice Santorini'], 'title': 'Building a large annotated corpus of english: The penn treebank', 'venue': 'Computational linguistics,', 'year': 1993}, {'authors': ['James Martens', 'Roger Grosse'], 'title': 'Optimizing neural networks with kronecker-factored approximate curvature', 'venue': 'In International Conference on Machine Learning,', 'year': 2015}, {'authors': ['Paul Mermelstein'], 'title': 'Distance measures for speech recognition, psychological and instrumental', 'venue': 'Pattern recognition and artificial intelligence,', 'year': 1976}, {'authors': ['Zakaria Mhammedi', 'Andrew Hellicar', 'Ashfaqur Rahman', 'James Bailey'], 'title': 'Efficient orthogonal parametrisation of recurrent neural networks using householder reflections', 'venue': 'arXiv preprint arXiv:1612.00188,', 'year': 2016}, {'authors': ['Tomáš Mikolov'], 'title': 'Statistical Language Models Based on Neural Networks', 'venue': 'PhD thesis,', 'year': 2012}, {'authors': ['Razvan Pascanu', 'Tomas Mikolov', 'Yoshua Bengio'], 'title': 'On the difficulty of training recurrent neural networks', 'venue': 'ICML (3),', 'year': 2013}, {'authors': ['Charles F Van Loan'], 'title': 'The ubiquitous kronecker product', 'venue': 'Journal of computational and applied mathematics,', 'year': 2000}, {'authors': ['Eugene Vorontsov', 'Chiheb Trabelsi', 'Samuel Kadoury', 'Chris Pal'], 'title': 'On orthogonality and learning recurrent networks with long term dependencies', 'venue': 'arXiv preprint arXiv:1702.00071,', 'year': 2017}, {'authors': ['Scott Wisdom', 'Thomas Powers', 'John Hershey', 'Jonathan Le Roux', 'Les Atlas'], 'title': 'Full-capacity unitary recurrent neural networks', 'venue': 'In Advances In Neural Information Processing Systems,', 'year': 2016}, {'authors': ['Yuhuai Wu', 'Elman Mansimov', 'Shun Liao', 'Roger Grosse', 'Jimmy Ba'], 'title': 'Scalable trust-region method for deep reinforcement learning using kronecker-factored approximation', 'venue': 'arXiv preprint arXiv:1708.05144,', 'year': 2017}, {'authors': ['Zichao Yang', 'Marcin Moczulski', 'Misha Denil', 'Nando de Freitas', 'Alex Smola', 'Le Song', 'Ziyu Wang'], 'title': 'Deep fried convnets', 'venue': 'In Proceedings of the IEEE International Conference on Computer Vision, pp', 'year': 2015}, {'authors': ['Xu Zhang', 'Felix X Yu', 'Ruiqi Guo', 'Sanjiv Kumar', 'Shengjin Wang', 'Shi-Fu Chang'], 'title': 'Fast orthogonal projection based on kronecker product', 'venue': 'In Proceedings of the IEEE International Conference on Computer Vision, pp. 2929–2937,', 'year': 2015}, {'authors': ['Shuchang Zhou', 'Jia-Nan Wu', 'Yuxin Wu', 'Xinyu Zhou'], 'title': 'Exploiting local structures with the kronecker layer in convolutional networks', 'venue': 'arXiv preprint arXiv:1512.09194,', 'year': 2015}, {'authors': ['Julian Georg Zilly', 'Rupesh Kumar Srivastava', 'Jan Koutnı́k', 'Jürgen Schmidhuber'], 'title': 'Recurrent highway networks', 'venue': 'arXiv preprint arXiv:1607.03474,', 'year': 2016}]
sections: [{'heading': '1 INTRODUCTION', 'text': 'Deep neural networks have defined the state-of-the-art in a wide range of problems in computer vision, speech analysis, and natural language processing (Krizhevsky et al., 2012; Hinton et al., 2012; Mikolov, 2012). However, these models suffer from two key issues. (1) They are over-parametrized; thus it takes a very long time for training and inference. (2) Learning deep models is difficult because of the poor conditioning of the matrices that parameterize the model. These difficulties are especially relevant to recurrent neural networks. Indeed, the number of distinct parameters in RNNs grows as the square of the size of the hidden state conversely to convolutional networks which enjoy weight sharing. Moreover, poor conditioning of the recurrent matrices results in the gradients to explode or vanish exponentially fast along the time horizon. This problem prevents RNN from capturing long-term dependencies (Hochreiter, 1991; Bengio et al., 1994).\nThere exists an extensive body of literature addressing over-parametrization in neural networks. LeCun et al. (1990) first studied the problem and proposed to remove unimportant weights in neural networks by exploiting the second order information. Several techniques which followed include low-rank decomposition (Denil et al., 2013), training a small network on the soft-targets predicted by a big pre-trained network (Ba & Caruana, 2014), low bit precision training (Courbariaux et al., 2014), hashing (Chen et al., 2015), etc. A notable exception is the deep fried convnets (Yang et al., 2015) which explicitly parameterizes the fully connected layers in a convnet with a computationally cheap and parameter-efficient structured linear operator, the Fastfood transform (Le et al., 2013). These techniques are primarily aimed at feed-forward fully connected networks and very few studies have focused on the particular case of recurrent networks (Arjovsky et al., 2016).\nThe problem of vanishing and exploding gradients has also received significant attention. Hochreiter & Schmidhuber (1997) proposed an effective gating mechanism in their seminal work on LSTMs.\nar X\niv :1\n70 5.\n10 14\n2v 7\n[ cs\n.L G\n] 3\n1 D\nec 2\n01 7\nLater, this technique was adopted by other models such as the Gated Recurrent Units (GRU) (Chung et al., 2015) and the Highway networks (Srivastava et al., 2015) for recurrent and feed-forward neural networks respectively. Other popular strategies include gradient clipping (Pascanu et al., 2013), and orthogonal initialization of the recurrent weights (Le et al., 2015). More recently (Arjovsky et al., 2016) proposed to use a unitary recurrent weight matrix. The use of norm preserving unitary maps prevent the gradients from exploding or vanishing, and thus help to capture long-term dependencies. The resulting model called unitary RNN (uRNN) is computationally efficient since it only explores a small subset of general unitary matrices. Unfortunately, since uRNNs can only span a reduced subset of unitary matrices their expressive power is limited (Wisdom et al., 2016). We denote this restricted capacity unitary RNN as RC uRNN. Full capacity unitary RNN (FC uRNN) (Wisdom et al., 2016) proposed to overcome this issue by parameterizing the recurrent matrix with a full dimensional unitary matrix, hence sacrificing computational efficiency. Indeed, FC uRNN requires a computationally expensive projection step which takes O(N3) time (N being the size of the hidden state) at each step of the stochastic optimization to maintain the unitary constraint on the recurrent matrix. Mhammedi et al. (2016) in their orthogonal RNN (oRNN) avoided the expensive projection step in FC uRNN by parametrizing the orthogonal matrices using Householder reflection vectors, it allows a fine-grained control over the number of parameters by choosing the number of Householder reflection vectors. When the number of Householder reflection vector approaches N this parametrization spans the full reflection set, which is one of the disconnected subset of the full orthogonal set. Jing et al. (2017) also presented a way of parametrizing unitary matrices which allows fine-grained control on the number of parameters. This work called as Efficient Unitary RNN (EURNN), exploits the continuity of unitary set to have a tunable parametrization ranging from a subset to the full unitary set.\nAlthough the idea of parametrizing recurrent weight matrices with strict unitary linear operator is appealing, it suffers from several issues: (1) Strict unitary constraints severely restrict the search space of the model, thus making the learning process unstable. (2) Strict unitary constraints make forgetting irrelevant information difficult. While this may not be an issue for problems with non-vanishing long term influence, it causes failure when dealing with real world problems that have vanishing long term influence 4.7. Henaff et al. (2016) have previously pointed out that the good performance of strict unitary models on certain synthetic problems is because it exploits the biases in these data-sets which favors a unitary recurrent map and these models may not generalize well to real world data-sets. More recently Vorontsov et al. (2017) have also studied this problem of unitary RNNs and the authors found out that relaxing the strict unitary constraint on the recurrent matrix to a soft unitary constraint improved the convergence speed as well as the generalization performance.\nOur motivation is to address the problems of existing recurrent networks mentioned above. We present a new model called Kronecker Recurrent Units (KRU). At the heart of KRU is the use of Kronecker factored recurrent matrix which provide an elegant way to adjust the number of parameters to the problem at hand. This factorization allows us to finely modulate the number of parameters required to encode N ×N matrices, from O(log(N)) when using factors of size 2× 2, to O(N2) parameters when using a single factor of the size of the matrix itself. We tackle the vanishing and exploding gradient problem through a soft unitary constraint (Jose & Fleuret, 2016; Henaff et al., 2016; Cisse et al., 2017; Vorontsov et al., 2017). Thanks to the properties of Kronecker matrices (Van Loan, 2000), this constraint can be enforced efficiently. Please note that KRU can readily be plugged into vanilla real space RNN, LSTM and other variants in place of standard recurrent matrices. However in case of LSTMs we do not need to explicitly enforce the approximate orthogonality constraints as the gating mechanism is designed to prevent vanishing and exploding gradients. Our experimental results on seven standard data-sets reveal that KRU and KRU variants of real space RNN and LSTM can reduce the number of parameters drastically (hence the training and inference time) without trading the statistical performance. Our core contribution in this work is a flexible, parameter efficient and expressive recurrent neural network model which is robust to vanishing and exploding gradient problem.\nThe paper is organized as follows, in section 2 we restate the formalism of RNN and detail the core motivations for KRU. In section 3 we present the Kronecker recurrent units (KRU). We present our experimental findings in section 4 and section 5 concludes our work.'}, {'heading': '2 RECURRENT NEURAL NETWORK FORMALISM', 'text': 'Table 1 summarizes some notations that we use in the paper. We consider the field to be complex rather than real numbers. We will motivate the choice of complex numbers later in this section. Consider a standard recurrent neural network (Elman, 1990). Given a sequence of T input vectors: x0,x1, . . . ,xT−1, at a time step t RNN performs the following:\nht = σ(Wht−1 + Uxt + b) (1) ŷt = Vht + c, (2)\nwhere ŷt is the predicted value at time step t.'}, {'heading': '2.1 OVER PARAMETERIZATION AND COMPUTATIONAL EFFICIENCY', 'text': 'The total number of parameters in a RNN is c(DN +N2 +N +M +MN), where c is 1 for real and 2 for complex parametrization. As we can see, the number of parameters grows quadratically with the hidden dimension, i.e., O(N2). We show in the experiments that this quadratic growth is an over parametrization for many real world problems. Moreover, it has a direct impact on the computational efficiency of RNNs because the evaluation of Wht−1 takes O(N2) time and it recursively depends on previous hidden states. However, other components Uxt and Vht can usually be computed efficiently by a single matrix-matrix multiplication for each of the components. That is, we can perform U[x0, . . . ,xT ] and V[h0, . . . ,hT−1], this is efficient using modern BLAS libraries. So to summarize, if we can control the number of parameters in the recurrent matrix W, then we can control the computational efficiency.'}, {'heading': '2.2 POOR CONDITIONING IMPLIES GRADIENTS EXPLODE OR VANISH', 'text': 'The vanishing and exploding gradient problem refers to the decay or growth of the partial derivative of the lossL(.) with respect to the hidden state ht i.e. ∂L∂ht as the number of time steps T grows (Arjovsky et al., 2016). By the application of the chain rule, the following can be shown (Arjovsky et al., 2016):∥∥∥∥ ∂L∂ht\n∥∥∥∥ ≤ ‖W‖T−t . (3) From Equation 3, it is clear that if the absolute value of the eigenvalues of W deviates from 1 then ∂L ∂ht\nmay explode or vanish exponentially fast with respect to T − t. So a strategy to prevent vanishing and exploding gradient is to control the spectrum of W.'}, {'heading': '2.3 WHY COMPLEX FIELD?', 'text': 'Although Arjovsky et al. (2016) and Wisdom et al. (2016) use complex valued networks with unitary constraints on the recurrent matrix, the motivations for such models are not clear. We give a simple but compelling reason for complex-valued recurrent networks.\nThe absolute value of the determinant of a unitary matrix is 1. Hence in the real space, the set of all unitary (orthogonal) matrices have a determinant of 1 or −1, i.e., the set of all rotations and\nreflections respectively. Since the determinant is a continuous function, the unitary set in real space is disconnected. Consequently, with the real-valued networks we cannot span the full unitary set using the standard continuous optimization procedures. On the contrary, the unitary set is connected in the complex space as its determinants are the points on the unit circle and we do not have this issue.\nAs we mentioned in the introduction (Jing et al., 2017) uses this continuity of unitary space to have a tunable continuous parametrization ranging from subspace to full unitary space. Any continuous parametrization in real space can only span a subset of the full orthogonal set. For example, the Householder parametrization (Mhammedi et al., 2016) suffers from this issue.'}, {'heading': '3 KRONECKER RECURRENT UNITS (KRU)', 'text': 'We consider parameterizing the recurrent matrix W as a Kronecker product of F matrices W0, . . . ,WF−1,\nW = W0 ⊗ · · · ⊗WF−1 = ⊗F−1f=0Wf . (4)\nWhere each Wf ∈ CPf×Qf and ∏F−1 f=0 Pf = ∏F−1 f=0 Qf = N . Wf ’s are called as Kronecker factors.\nTo illustrate the Kronecker product of matrices, let us consider the simple case when ∀f{Pf = Qf = 2}. This implies F = log 2N . And W is recursevly defined as follows:\nW = ⊗log 2N−1f=0 Wf = [\nw0(0, 0) w0(0, 1) w0(1, 0) w0(1, 1)\n] ⊗log 2N−1f=1 Wf , (5)\n= [ w0(0, 0)W1 w0(0, 1)W1 w0(1, 0)W1 w0(1, 1)W1 ] ⊗log 2N−1f=2 Wf . (6)\nWhen ∀f{pf = qf = 2} the number of parameters is 8 log2N and the time complexity of hidden state computation is O(N log2N). When ∀f{pf = qf = N} then F = 1 and we will recover standard complex valued recurrent neural network. We can span every Kronecker representations in between by choosing the number of factors and the size of each factor. In other words, the number of Kronecker factors and the size of each factor give us fine-grained control over the number of parameters and hence over the computational efficiency. This strategy allows us to design models with the appropriate trade-off between computational budget and statistical performance. All the existing models lack this flexibility.\nThe idea of using Kronecker factorization for approximating Fisher matrix in the context of natutal gradient methods have recently recieved much attention. The algorithm was originally presented in Martens & Grosse (2015) and was later extended to convolutional layers (Grosse & Martens, 2016), distributed second order optimization (Ba et al., 2016) and for deep reinforcement learning (Wu et al., 2017). However Kronecker matrices have not been well explored as learnable parameters except (Zhang et al., 2015) used it’s spectral property for fast orthogonal projection and (Zhou et al., 2015) used it as a layer in convolutional neural networks.'}, {'heading': '3.1 SOFT UNITARY CONSTRAINT', 'text': 'Poor conditioning results in vanishing or exploding gradients. Unfortunately, the standard solution which consists of optimization on the strict unitary set suffers from the retention of noise over time. Indeed, the small eigenvalues of the recurrent matrix can represent a truly vanishing long-term influence on the particular problem and in that sense, there can be good or bad vanishing gradients. Consequently, enforcing strict unitary constraint (forcing the network to never forget) can be a bad strategy. A simple solution to get the best of both worlds is to enforce unitary constraint approximately by using the following regularization:∥∥WHf Wf − I∥∥2 ,∀f ∈ {0, . . . , F − 1} (7) Please note that these constraints are enforced on each factor of the Kronecker factored recurrent matrix. This procedure is computationally very efficient since the size of each factor is typically small. It suffices to do so because if each of the Kronecker factors {W0, . . . ,WF−1} are unitary then the\nfull matrix W is unitary (Van Loan, 2000) and if each of the factors are approximately unitary then the full matrix is approximately unitary. We apply soft unitary constraints as a regularizer whose strength is cross-validated on the validation set.\nThis type of regularizer has recently been exploited for real-valued models. (Cisse et al., 2017) showed that enforcing approximate orthogonality constraint on the weight matrices make the network robust to adversarial samples as well as improve the learning speed. In metric learning (Jose & Fleuret, 2016) have shown that it better conditions the projection matrix thereby improving the robustness of stochastic gradient over a wide range of step sizes as well asthe generalization performance. Henaff et al. (2016) and Vorontsov et al. (2017) have also used this soft unitary contraints on standard RNN after identifying the problems with the strict unitary RNN models. However the computational complexity of naively applying this soft constraint is O(N3). This is prohibitive for RNNs with large hidden state unless one considers a Kronecker factorization.'}, {'heading': '4 EXPERIMENTS', 'text': 'Existing deep learning libraries such as Theano (Bergstra et al., 2011), Tensorflow (Abadi et al., 2016) and Pytorch (Paszke et al., 2017) do not support fast primitives for Kronecker products with arbitrary number of factors. So we wrote custom CUDA kernels for Kronecker forward and backward operations. All our models are implemented in C++. We will release our library to reproduce all the results which we report in this paper. We use tanh as activation function for RNN, LSTM and our model KRU-LSTM. Whereas RC uRNN, FC uRNN and KRU uses complex rectified linear units (Arjovsky et al., 2016).'}, {'heading': '4.1 COPY MEMORY PROBLEM', 'text': 'Copy memory problem (Hochreiter & Schmidhuber, 1997) tests the model’s ability to recall a sequence after a long time gap. In this problem each sequence is of length T + 20 and each element in the sequence come from 10 classes {0, . . . , 9}. The first 10 elements are sampled uniformly with replacement from {1, . . . , 8}. The next T − 1 elements are filled with 0, the ‘blank’ class followed by 9, the ‘delimiter’ and the remaining 10 elements are ‘blank’ category. The goal of the model is to output a sequence of T + 10 blank categories followed by the 10 element sequence from the beginning of the input sequence. The expected average cross entropy for a memory-less strategy is 10 log 8 T+20 .\nOur experimental setup closely follows Wisdom et al. (2016) which in turn follows Arjovsky et al. (2016) but T extended to 1000 and 2000. Our model, KRU uses a hidden dimension N of 128 with 2x2 Kronecker factors which corresponds to ≈5K parameters in total. We use a RNN of N = 128 (≈ 19K parameters) , LSTM of N = 128 ( ≈ 72K parameters), RC uRNN of N = 470 ( ≈ 21K parameters) , FC uRNN of N = 128 ( ≈ 37K parameters). All the baseline models are deliberately chosen to have more parameters than KRU. Following Wisdom et al. (2016); Arjovsky et al. (2016),\nwe choose the training and test set size to be 100K and 10K respectively. All the models were trained using RMSprop with a learning rate of 1e−3, decay of 0.9 and a batch size of 20. For both the settings T = 1000 and T = 2000, KRU converges to zero average cross entropy faster than FC uRNN. All the other baselines are stuck at the memory-less cross entropy.\nThe results are shown in figure 1. For this problem we do not learn the recurrent matrix of KRU, We initialize it by random unitary matrix and just learn the input to hidden, hidden to output matrices and the bias. We found out that this strategy already solves the problem faster than all other methods. Our model in this case is similar to a parametrized echo state networks (ESN). ESNs are known to be able to learn long-term dependencies if they are properly initialized (Jaeger, 2001). We argue that this data-set is not an ideal benchmark for evaluating RNNs in capturing long term dependencies. Just a unitary initialization of the recurrent matrix would solve the problem.'}, {'heading': '4.2 ADDING PROBLEM', 'text': 'Following Arjovsky et al. (2016) we describe the adding problem (Hochreiter & Schmidhuber, 1997). Each input vector is composed of two sequences of length T . The first sequence is sampled from U [0, 1]. In the second sequence exactly two of the entries is 1, the ‘marker’ and the remaining is 0. The first 1 is located uniformly at random in the first half of the sequence and the other 1 is located again uniformly at random in the other half of the sequence. The network’s goal is to predict the sum of the numbers from the first sequence corresponding to the marked locations in the second sequence.\nWe evaluate four settings as in Arjovsky et al. (2016) with T=100, T=200, T=400, and T=750. For all four settings, KRU uses a hidden dimension N of 512 with 2x2 Kronecker factors which corresponds to ≈3K parameters in total. We use a RNN of N = 128 (≈ 17K parameters) , LSTM of N = 128 ( ≈ 67K parameters), RC uRNN of N = 512 ( ≈ 7K parameters) , FC uRNN of N = 128 ( ≈ 33K parameters). The train and test set sizes are chosen to be 100K and 10K respectively. All the\nmodels were trained using RMSprop with a learning rate of 1e−3 and a batch size of 20 or 50 with the best results are being reported here.\nThe results are presented in figure 2. KRU converges faster than all other baselines even though it has much fewer parameters. This shows the effectiveness of soft unitary constraint which controls the flow of gradients through very long time steps and thus deciding what to forget and remember in an adaptive way. LSTM also converges to the solution and this is achieved through its gating mechanism which controls the flow of the gradients and thus the long term influence. However LSTM has 10 times more parameters than KRU. Both RC uRNN and FC uRNN converges for T = 100 but as we can observe, the learning is not stable. The reason for this is that RC uRNN and FC uRNN retains noise since they are strict unitary models. Please note that we do not evaluate RC uRNN for T = 400 and T = 750 because we found out that the learning is unstable for this model and is often diverging.'}, {'heading': '4.3 PIXEL BY PIXEL MNIST', 'text': 'As outlined by Le et al. (2015), we evaluate the Pixel by pixel MNIST task. MNIST digits are shown to the network pixel by pixel and the goal is to predict the class of the digit after seeing all the pixels one by one. We consider two tasks: (1) Pixels are read from left to right from top or bottom and (2) Pixels are randomly permuted before being shown to the network. The sequence length for these tasks is T = 28× 28 = 784. The size of the MNIST training set is 60K among which we choose 5K as the validation set. The models are trained on the remaining 55K points. The model which gave the best validation accuracy is chosen for test set evaluation. All the models are trained using RMSprop with a learning rate of 1e−3 and a decay of 0.9.\nThe results are summarized in figure 3 and table 2. On the unpermuted task LSTM achieve the state of the art performance even though the convergence speed is slow. Recently a low rank plus diagonal gated recurrent unit (LRD GRU) (Barone, 2016) have shown to achieves 94.7 accuracy on permuted MNIST with 41.2K parameters whereas KRU achieves 94.5 with just 12K parameters i.e KRU has\n3x parameters less than LRD GRU. Please also note that KRU is a simple model without a gating mechanism. KRU can be straightforwardly plugged into LSTM and GRU to exploit the additional benefits of the gating mechanism which we will show in the next experiments with a KRU-LSTM.'}, {'heading': '4.4 CHARACTER LEVEL LANGUAGE MODELLING ON PENN TREEBANK (PTB)', 'text': 'We now consider character level language modeling on Penn TreeBank data-set (Marcus et al., 1993). Penn TreeBank is composed of 5017K characters in the training set, 393K characters in the validation set and 442K characters in the test set. The size of the vocabulary was limited to 10K most frequently occurring words and the rest of the words are replaced by a special <UNK> character (Mikolov, 2012). The total number of unique characters in the data-set is 50, including the special <UNK> character.\nAll our models were trained for 50 epochs with a batch size of 50 and using ADAM (Kingma & Ba, 2014). We use a learning rate of 1e−3 which was found through cross-validation with default beta parameters (Kingma & Ba, 2014). If we do not see an improvement in the validation bits per character (BPC) after each epoch then the learning rate is decreased by 0.30. Back-propagation through time (BPTT) is unrolled for 30 time frames on this task.\nWe did two sets of experiments to have fair evaluation with the models whose results were available for a particular parameter setting (Mhammedi et al., 2016) and also to see how the performance evolves as the number of parameters are increased. We present our results in table 3. We observe that the strict orthogonal model, oRNN fails to generalize as well as other models even with a high capacity recurrent matrix. KRU and KRU-LSTM performs very close to RNN and LSTM with fewer parameters in the recurrent matrix. Please recall that the computational bottleneck in RNN is the computation of hidden states 2.1 and thus having fewer parameters in the recurrent matrix can significantly reduce the training and inference time.\nRecently HyperNetworks (Ha et al., 2016) have shown to achieve the state of the art performance of 1.265 and 1.219 BPC on the PTB test set with 4.91 and 14.41 million parameters respectively. This is respectively 13 and 38 times more parameters than the KRU-LSTM model which achieves 1.47 test BPC. Also Recurrent Highway Networks (RHN) (Zilly et al., 2016) proved to be a promising model for learning very deep recurrent neural networks. Running experiments, and in particular exploring meta-parameters with models of that size, requires unfortunately computational means beyond what was at our disposal for this work. However, there is no reason that the consistent behavior and improvement observed on the other reference baselines would not generalize to that type of large-scale models.'}, {'heading': '4.5 POLYPHONIC MUSIC MODELING', 'text': 'We exactly follow the experimental framework of Chung et al. (2014) for Polyphonic music modeling (Boulanger-Lewandowski et al., 2012) on two datasets: JSB Chorales and Piano-midi. Similar to (Chung et al., 2014) our main objective here is to have a fair evaluation of different recurrent neural networks. We took the baseline RNN and LSTM models of (Chung et al., 2014) whose model\nsizes were chosen to be small enough to avoid overfitting. We choose the model size of KRU and KRU-LSTM in such way that it has fewer parameters compared to the baselines. As we can in the table 4 both our models (KRU and KRU-LSTM) overfit less and generalizes better. We also present the wall-clock running time of different methods in the figure 4.'}, {'heading': '4.6 FRAMEWISE PHONEME CLASSIFICATION ON TIMIT', 'text': 'Framewise phoneme classification (Graves & Schmidhuber, 2005) is the problem of classifying the phoneme corresponding to a sound frame. We evaluate the models for this task on the real world TIMIT data-set (Garofolo et al., 1993). TIMIT contains a training set of 3696 utterances among which we use 184 as the validation set. The test set is composed of 1344 utterances. We extract 12 Mel-Frequency Cepstrum Coefficients (MFCC) (Mermelstein, 1976) from 26 filter banks and also the log energy per frame. We also concatenate the first derivative, resulting in a feature descriptor of dimension 26 per frame. The frame size is chosen to be 10ms and the window size is 25ms.\nThe number of time steps to which back-propagation through time (BPTT) is unrolled corresponds to the length of each sequence. Since each sequence is of different length this implies that for each sample BPTT steps are different. All the models are trained for 20 epochs with a batch size of 1 using ADAM with default beta parameters (Kingma & Ba, 2014). The learning rate was cross-validated for each of the models from η ∈ {1e−2, 1e−3, 1e−4} and the best results are reported here. The best learning rate for all the models was found out to be 1e−3 for all the models. Again if we do not observe a decrease in the validation error after each epoch, we decrease the learning rate by a factor of γ ∈ {1e−1, 2e−1, 3e−1} which is again cross-validated. Figure 5 summarizes our results.'}, {'heading': '4.7 INFLUENCE OF SOFT UNITARY CONSTRAINTS', 'text': 'Here we study the properties of soft unitary constraints on KRU. We use Polyphonic music modeling data-sets (Boulanger-Lewandowski et al., 2012): JSB Chorales and Piano-midi, as well as TIMIT data-set for this set of experiments. We varied the amplitude of soft unitary constraints from 1e− 7 to 1e− 1, the higher the amplitude the closer the recurrent matrix will be to the unitary set. All other hyper-parameters, such as the learning rate and the model size are fixed. We present our studies in the figure 6. As we increase the amplitude we can see that the recurrent matrix is getting better conditioned and the spectral norm or the spectral radius is approaching towards 1. As we can see that the validation performance can be improved using this simple soft unitary constraints. For JSB Chorales the best validation performance is achieved at an amplitude of 1e − 2, whereas for Piano-midi it is at 1e− 1. For TIMIT phoneme recognition problem, the best validation error is achieved at 1e − 5 but as we increase the amplitude further, the performance drops. This might be explained by a vanishing long-term influence that has to be forgotten. Our model achieve this by cross-validating the amplitude of soft unitary constraints. These experiments also reveals the problems of strict unitary models such as RC uRNN (Arjovsky et al., 2016), FC uRNN (Wisdom et al., 2016), oRNN (Mhammedi et al., 2016) and EURNN (Jing et al., 2017) that they suffer from the retention of noise from a vanishing long term influence and thus fails to generalize.\nA popular heuristic strategy to avoid exploding gradients in RNNs and thereby making their training robust and stable is gradient clipping. Most of the state of the art RNN models use gradient clipping for training. Please note that we are not using gradient clipping with KRU. Our soft unitary constraints offer a principled alternative to gradient clipping.\nMoreover Hardt et al. (2016) recently showed that gradient descent converges to the global optimizer of linear recurrent neural networks even though the learning problem is non-convex. The necessary condition for the global convergence guarantee requires that the spectral norm of recurrent matrix is bounded by 1. This seminal theoretical result also inspires to use regularizers which control the spectral norm of the recurrent matrix, such as the soft unitary constraints.'}, {'heading': '5 CONCLUSION', 'text': 'We have presented a new recurrent neural network model based on its core a Kronecker factored recurrent matrix. Our core reason for using a Kronecker factored recurrent matrix stems from it’s elegant algebraic and spectral properties. Kronecker matrices are neither low-rank nor block-diagonal but it is multi-scale like the FFT matrix. Kronecker factorization provides a fine control over the model capacity and it’s algebraic properties enable us to design fast matrix multiplication algorithms. It’s spectral properties allow us to efficiently enforce constraints like positive semi-definitivity, unitarity and stochasticity. As we have shown, we used the spectral properties to efficiently enforce a soft unitary constraint.\nExperimental results show that our approach out-perform classical methods which uses O(N2) parameters in the recurrent matrix. Maybe as important, these experiments show that both on toy problems (§ 4.1 and 4.2), and on real ones (§ 4.3, 4.4, , and § 4.6), while existing methods require tens of thousands of parameters in the recurrent matrix, competitive or better than state-of-the-art performance can be achieved with far less parameters in the recurrent weight matrix. These surprising results provide a new and counter-intuitive perspective on desirable memory-capable architectures: the state should remain of high dimension to allow the use of high-capacity networks to encode the input into the internal state, and to extract the predicted value, but the recurrent dynamic itself can, and should, be implemented with a low-capacity model.\nFrom a practical standpoint, the core idea in our method is applicable not only to vanilla recurrent neural networks and LSTMS as we showed, but also to a variety of machine learning models such as feed-forward networks (Zhou et al., 2015), random projections and boosting weak learners. Our future work encompasses exploring other machine learning models and on dynamically increasing the capacity of the models on the fly during training to have a perfect balance between computational efficiency and sample complexity.'}, {'heading': 'A ANALYSIS OF VANISHING AND EXPLODING GRADIENTS IN RNN', 'text': 'Given a sequence of T input vectors: x0,x1, . . . ,xT−1, let us consider the operation at the hidden layer t of a recurrent neural network:\nzt = Wtht−1 + Utxt + b (8) ht = σ(zt) (9)\nBy the chain rule,\n∂L ∂ht = ∂L ∂hT ∂hT ∂ht\n(10)\n= ∂L ∂hT T−1∏ k=t ∂hk+1 ∂hk = ∂L ∂hT T−1∏ k=t Jk+1W T (11)\nwhere σ is the non-linear activation function and Jk+1 = diag(σ ′ (zk+1)) is the Jacobian matrix of the non-linear activation function.\n∥∥∥∥ ∂L∂ht ∥∥∥∥ = ∥∥∥∥∥ ∂L∂hT T−1∏ k=t Jk+1W T ∥∥∥∥∥ (12) ≤ ∥∥∥∥ ∂L∂hT ∥∥∥∥ T−1∏ k=t\n∥∥Jk+1WT∥∥ (13) ≤ ∥∥∥∥ ∂L∂hT ∥∥∥∥ ‖W‖T−t T−1∏ k=t ‖Jk+1‖ (14)\nFrom equation 14 it is clear the norm of the gradient is exponentially dependent upon two factors along the time horizon:\n• The norm of the Jacobian matrix of the non-linear activation function ‖Jk+1‖. • The norm of the hidden to hidden weight matrix ‖W‖.\nThese two factors are causing the vanishing and exploding gradient problem.\nSince the gradient of the standard non-linear activation functions such as tanh and ReLU are bounded between [0, 1], ‖Jk+1‖ does not contribute to the exploding gradient problem but it can still cause vanishing gradient problem.'}, {'heading': 'B LONG SHORT-TERM MEMORY (LSTM) (HOCHREITER & SCHMIDHUBER, 1997)', 'text': 'LSTM networks presented an elegant solution to the vanishing and exploding gradients through the introduction of gating mechanism. Apart from the standard hidden state in RNN, LSTM introduced one more state called cell state ct. LSTM has three different gates whose functionality is described as follows:\n• Forget gate (Wf ,Uf ,bf ):Decides what information to keep and erase from the previous cell state.\n• Input gate (Wi,Uf ,bi): Decides what new information should be added to the cell state. • Output gate (Wo,Uo,bo):Decides which information from the cell state is going to the\noutput.\nIn addition to the gates, LSTM prepares candidates for the information from the input gate that might get added to the cell state through the action of input gate. Let’s denote the parameters describing the function that prepares this candidate information as Wc,Uc,bc.\nGiven a sequence of T input vectors: x0,x1, . . . ,xT−1, at a time step t LSTM performs the following:\nft = σ(Wfht−1 + Ufxt + bf ) (15) it = σ(Wiht−1 + Uixt + bi) (16) ot = σ(Woht−1 + Uoxt + bo) (17) ĉt = τ(Wcht−1 + Ucxt + bc) (18) ct = ct−1 ft + ĉt it (19) ht = τ(ct) ot (20)\nwhere σ(.) and τ(.) are the point-wise sigmoid and tanh functions. indicates element-wise multiplication. The first three are gating operations and the 4th one prepares the candidate information. The 5th operation updates the cell-state and finally in the 6th operation the output gate decided what to go into the current hidden state.'}, {'heading': 'C UNITARY EVOLUTION RNN (ARJOVSKY ET AL., 2016)', 'text': 'Unitary evolution RNN (uRNN) proposed to solve the vanishing and exploding gradients through a unitary recurrent matrix, which is for the form:\nW = D3R2F −1D2ΠR1FD1. (21)\nWhere:\n• D1,D2,D3: Diagonal matrices whose diagonal entries are of the from Dkk = eiθk , implies each matrix have N parameters, (θ0, . . . , θN−1). • F and F−1: Fast Fourier operator and inverse fast Fourier operator respectively.\n• R1,R2: Householder reflections. R = I− 2vv H ‖v‖ , where v ∈ C N .\nThe total number of parameters for this uRNN operator is 7N and the matrix vector can be done Nlog(N) time. It is parameter efficient and fast but not flexible and suffers from the retention of noise and difficulty in optimization due its unitarity.'}, {'heading': 'D FULL CAPACITY UNITARY RNN (WISDOM ET AL., 2016)', 'text': 'Full capacity unitary RNN (FC uRNN) does optimization on the full unitary set instead on a subset like uRNN. That is FC uRNN’s recurrent matrix W ∈ U(N). There are several challenges in optimization over unitary manifold especially when combined with stochastic gradient method. The primary challenge being the optimization cost is O(N3) per step.'}, {'heading': 'E ORTHOGONAL RNN (MHAMMEDI ET AL., 2016)', 'text': 'Orthogonal RNN (oRNN) parametrizes the recurrent matrices using Householder reflections.\nW = HN (vN )...HN−K+1(vN−k+1). (22) where\nHK(vK) =\n[ IN−K 0\n0 IK − 2vKv H K\n‖vK‖\n] (23)\nand\nH1(v) = [\nIN−1 0 0 v ∈ {−1, 1}\n] (24)\nwhere vK ∈ RK . The number of parameters in this parametrization is O(NK). When N = K = 1 and v = 1, it spans the rotation subset and when v = −1, it spans the full reflection subset.'}, {'heading': 'F PROPERTIES OF KRONECKER MATRIX (VAN LOAN, 2000)', 'text': 'Consider a matrix W ∈ CN×N factorized as a Kronecker product of F matrices W0, . . . ,WF−1,\nW = W0 ⊗ · · · ⊗WF−1 = ⊗F−1i=0 Wi. (25)\nWhere each Wi ∈ CPi×Qi respectively and ∏f−1 i=0 Pi = ∏F−1 i=0 Qi = N . Wi’s are called as Kronecker factors.\nIf the factors Wi’s are  Nonsingular Symmetric Stochatsic Orthogonal Unitary PSD Toeplitz  then W is  Nonsingular Symmetric Stochatsic Orthogonal Unitary PSD Block Toeplitz  Theorem 1. If ∀i ∈ 0, . . . , F − 1, Wi is unitary then W is also unitary.\nProof.\nWHW = (W0 ⊗ · · · ⊗Wf−1)H(W0 ⊗ · · · ⊗Wf−1) (26) = (WH0 ⊗ · · · ⊗WHf−1)(W0 ⊗ · · · ⊗Wf−1) (27) = WH0 W0 ⊗ · · · ⊗WHf−1Wf−1 = I. (28)'}, {'heading': 'G PRODUCT BETWEEN A DENSE MATRIX AND A KRONECKER MATRIX', 'text': 'For simplicity here we use real number notations. Consider a dense matrix X ∈ RM×K and a Kronecker factored matrix W ∈ RN×K . That is W = ⊗F−1f=0Wf , where each Wf ∈ RPf×Qf\nrespectively and ∏F−1 f=0 Pf = N and ∏F−1 f=0 Qf = K. Let us illustrate the matrix product XW T resulting in a matrix Y ∈ RM×N .\nY = XWT . (29)\nThe computational complexity first expanding the Kronecker factored matrix and then computing the matrix product isO(MNK). This can be reduced by exploiting the recursive definition of Kronecker matrices. For examples when N = K and ∀f{Pf = Qf = 2}, the matrix product can be computed in O(MN logN) time instead of O(MN2). The matrix product in 29 can be recursively defined as\nY = (. . . (X WT0 )⊗ · · · ⊗WTF−1). (30)\nPlease note that the binary operator is not the standard matrix multiplication operator but instead it denotes a strided matrix multiplication. The stride is computed according to the algebra of Kronecker matrices. Let us define Y recursively:\nY0 = X W0 (31) Yf = Yf−1 Wf . (32)\nCombining equation 34 and 32\nY = YF−1 = (. . . (X WT0 )⊗ · · · ⊗WTF−1). (33)\nWe use the above notation for Y in the algorithm. That is the algorithm illustrated here will cache all the intermediate outputs (Y0, . . . ,YF−1) instead of just YF−1. These intermediate outputs are then\nlater to compute the gradients during the back-propagation. This cache will save some computation during the back-propagation. If the model is just being used for inference then the algorithm can the organized in such a way that we do not need to cache the intermediate outputs and thus save memory.\nAlgorithm for computing the product between a dense matrix and a Kronecker factored matrix34 is given below 1. All the matrices are assumed to be stored in row major order. For simplicity the algorithm is illustrated in a serial fashion. Please note the lines 4 to 15 except lines 9-11 can be trivially parallelized as it writes to independent memory locations. The GPU implementation exploits this fact.\nAlgorithm 1 Dense matrix product with a Kronecker matrix, Y = (. . . (XWT0 )⊗ · · · ⊗WTF−1)\nInput: Dense matrix X ∈ RM×K , Kronecker factors {W0, . . . ,WF−1} : Wf ∈ Rpf×qf , Size of each Kronecker factors {(P0, Q0), . . . , (PF−1, QF−1)} : ∏F−1 f=0 Pf = N, ∏F−1 f=0 Qf = K, Output: Output matrix YF−1 ∈ RM×N 1: for f = 0 to F − 1 do 2: stride = K/Qf 3: index = 0 4: for m = 0 to M − 1 do 5: Xm = X +m×K 6: for p = 0 to Pf − 1 do 7: for s = 0 to stride− 1 do 8: Yf [index] = 0 9: for q = 0 to Qk − 1 do 10: Yf [index] = Yf [index] + Xm[q × stride+ s]×Wf [p×Qf + q] 11: end for 12: index = index+ 1 13: end for 14: end for 15: end for 16: K = stride 17: M = M × Pf 18: X = Yf 19: end for'}, {'heading': 'H GRADIENT COMPUTATION IN A KRONECKER LAYER', 'text': 'Following the notations from the above section G, here we illustrate the algorithm for computing the gradients in a Kronecker layer. To be clear and concrete the Kronecker layer does the following computation in the forward pass 32.\nY = YF−1 = (. . . (X WT0 )⊗ · · · ⊗WTF−1). (34)\nThat is, the Kronecker layer is parametrized by a Kronecker factored matrix W = ⊗F−1f=0Wf stored as it factors {W0, . . . ,WF−1} and it takes an input X and produces output Y = YF−1 using the algorithm 1.\nThe following algorithm 2 computes the Gradient of the Kronecker factors: {gW0, . . . ,gWF−1} and the Jacobian of the input matrix gX given the Jacobian of the output matrix: gY = gYF−1.\nAlgorithm 2 Gradient computation in a Kronecker layer.\nInput: Input matrix X ∈ RM×K , Kronecker factors {W0, . . . ,WF−1} : Wf ∈ Rpf×qf , Size of each Kronecker factors {(P0, Q0), . . . , (PF−1, QF−1)} : ∏F−1 f=0 Pf = N, ∏F−1 f=0 Qf = K,\nAll intermediate output matrices from the forward pass: {Y0, . . . ,YF−1}, Jacobian of output matrix: gYF−1 ∈ RM×N Output: Gradient of Kronecker factors: {gW0, . . . ,gWF−1} and Jacobian of input matrix: gX ∈ RM×N .\n1: T = M ×N 2: strideP = 1 3: strideQ = 1 4: gY = gYF−1 5: for f = F − 1 to 0 do 6: R = strideP × Pf 7: S = strideQ×Qf 8: T = T/Pf 9: Z = nullptr\n10: gZ = nullptr 11: if f == 0 then'}, {'heading': '12: Z = X', 'text': '13: gZ = gX 14: else'}, {'heading': '15: gZ = Yf−1', 'text': '16: Z = gZ 17: end if 18: index = 0 19: for t = 0 to T − 1 do 20: Zt = Z + t× S 21: for p = 0 to Pf − 1 do 22: for s = 0 to strideQ− 1 do 23: for q = 0 to Qk − 1 do 24: gWf [p×Qk + 1] = gWf [p×Qk + 1] + Zt[q × strideQ+ s]× gY[index] 25: end for 26: index = index+ 1 27: end for 28: end for 29: end for 30: index = 0 31: for t = 0 to T − 1 do 32: gYt = gY + t×R 33: for p = 0 to Pf − 1 do 34: for s = 0 to strideQ− 1 do 35: gZ[index] = 0 36: for q = 0 to Qk − 1 do 37: gZ[index] = gZ[index] + gY[q × strideQ+ s]×Wf [q × Pf + q] 38: end for 39: index = index+ 1 40: end for 41: end for 42: end for 43: gY = gZ //We reuse the memory for the intermediate outputs to store the gradients. 44: strideQ = S 45: strideP = R×Qf/Pf 46: end for'}]
