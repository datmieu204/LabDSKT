id: SP:07ca5797df5ae58660663bad45e54295859f4176
title: A Static Verification Framework for Message Passing in Go using Behavioural Types
authors: [{'affiliations': [], 'name': 'Julien Lange'}, {'affiliations': [], 'name': 'Nicholas Ng'}, {'affiliations': [], 'name': 'Bernardo Toninho'}, {'affiliations': [], 'name': 'Nobuko Yoshida'}]
abstractText: The Go programming language has been heavily adopted in industry as a language that efficiently combines systems programming with concurrency. Go’s concurrency primitives, inspired by process calculi such as CCS and CSP, feature channel-based communication and lightweight threads, providing a distinct means of structuring concurrent software. Despite its popularity, the Go programming ecosystem offers little to no support for guaranteeing the correctness of message-passing concurrent programs. This work proposes a practical verification framework for message passing concurrency in Go by developing a robust static analysis that infers an abstract model of a program’s communication behaviour in the form of a behavioural type, a powerful process calculi typing discipline. We make use of our analysis to deploy a model and termination checking based verification of the inferred behavioural type that is suitable for a range of safety and liveness properties of Go programs, providing several improvements over existing approaches. We evaluate our framework and its implementation on publicly available real-world Go code.
references: [{'authors': ['Davide Ancona', 'Viviana Bono', 'Mario Bravetti', 'Joana Campos', 'Giuseppe Castagna', 'Pierre-Malo Deniélou', 'Simon J. Gay', 'Nils Gesbert', 'Elena Giachino', 'Raymond Hu', 'Einar Broch Johnsen', 'Francisco Martins', 'Viviana Mascardi', 'Fabrizio Montesi', 'Rumyana Neykova', 'Nicholas Ng', 'Luca Padovani', 'Vasco T. Vasconcelos', 'Nobuko Yoshida'], 'title': 'Behavioral Types in Programming Languages', 'venue': 'Foundations and Trends in Programming Languages,', 'year': 2017}, {'authors': ['Andrew W. Appel'], 'title': 'SSA is Functional Programming', 'venue': 'SIGPLAN Notices 33,', 'year': 1998}, {'authors': ['Cyrille Artho', 'Masami Hagiya', 'Richard Potter', 'Yoshinori Tanabe', 'FranzWeitl', 'Mitsuharu Yamamoto'], 'title': 'Software model checking for distributed systems with selector-based, non-blocking communication', 'venue': 'In ASE', 'year': 2013}, {'authors': ['Brad Fitzpatrick'], 'title': 'linux/amd64 deadlock detection failed', 'year': 2015}, {'authors': ['Sagar Chaki', 'Sriram K. Rajamani', 'Jakob Rehof'], 'title': 'Types as models: model checking message-passing programs', 'venue': 'In POPL', 'year': 2002}, {'authors': ['Witold Charatonik', 'Andrew D. Gordon', 'Jean-Marc Talbot'], 'title': 'Finite- Control Mobile Ambients', 'venue': 'In ESOP. 295–313', 'year': 2002}, {'authors': ['Sjoerd Cranen', 'Jan Friso Groote', 'Jeroen J.A. Keiren', 'Frank P.M. Stappers', 'Erik P. de Vink', 'Wieger Wesselink', 'Tim A.C. Willemse'], 'title': 'An Overview of the mCRL2 Toolset and Its Recent Advances', 'year': 2013}, {'authors': ['Pierre-Malo Deniélou', 'Nobuko Yoshida'], 'title': 'Multiparty Session Types Meet Communicating Automata', 'venue': 'In ESOP (LNCS),', 'year': 2012}, {'authors': ['E.W. Dijkstra'], 'title': 'Cooperating sequential process', 'venue': 'Programming Languages', 'year': 1965}, {'authors': ['Stephan Falke', 'Deepak Kapur', 'Carsten Sinz'], 'title': 'Termination Analysis of C Programs Using Compiler Intermediate Languages', 'venue': 'In RTA', 'year': 2011}, {'authors': ['Stephan Falke', 'Deepak Kapur', 'Carsten Sinz'], 'title': 'Termination Analysis of Imperative Programs Using Bitvector Arithmetic', 'year': 2012}, {'authors': ['Thomas Gibson-Robinson', 'Philip Armstrong', 'Alexandre Boulgakov', 'A.W. Roscoe'], 'title': 'FDR3 — A Modern Refinement Checker for CSP. In Tools and Algorithms for the Construction and Analysis of Systems (Lecture', 'venue': 'Notes in Computer Science),', 'year': 2014}, {'authors': ['Jan Friso Groote', 'Mohammad Reza Mousavi'], 'title': 'Modeling and Analysis of Communicating Systems', 'year': 2014}, {'authors': ['Klaus Havelund', 'Thomas Pressburger'], 'title': 'Model Checking JAVA Programs using JAVA PathFinder', 'venue': 'STTT 2,', 'year': 2000}, {'authors': ['Tony Hoare'], 'title': 'Communicating Sequential Processes', 'year': 1985}, {'authors': ['Kohei Honda', 'Nobuko Yoshida', 'Marco Carbone'], 'title': 'Multiparty Asynchronous Session Types', 'venue': 'In POPL’08', 'year': 2008}, {'authors': ['Hans Hüttel', 'Ivan Lanese', 'Vasco T. Vasconcelos', 'Luís Caires', 'Marco Carbone', 'Pierre-Malo Deniélou', 'Dimitris Mostrous', 'Luca Padovani', 'António Ravara', 'Emilio Tuosto', 'Hugo Torres Vieira', 'Gianluigi Zavattaro'], 'title': 'Foundations of Session Types and Behavioural Contracts', 'venue': 'ACM Comput. Surv', 'year': 2016}, {'authors': ['Atsushi Igarashi', 'Naoki Kobayashi'], 'title': 'A generic type system for the Pi-calculus', 'venue': 'Theor. Comput. Sci. 311,', 'year': 2004}, {'authors': ['Dexter Kozen'], 'title': 'Results on the Propositional mu-Calculus', 'venue': 'Theor. Comput. Sci', 'year': 1983}, {'authors': ['Daniel Kroening', 'Daniel Poetzl', 'Peter Schrammel', 'BjörnWachter'], 'title': 'Sound static deadlock analysis for C/Pthreads', 'venue': 'In ASE', 'year': 2016}, {'authors': ['Julien Lange', 'Nicholas Ng', 'Bernardo Toninho', 'Nobuko Yoshida'], 'title': 'Fencing off Go: Liveness and Safety for Channel-based Programming', 'venue': 'In POPL 2017', 'year': 2017}, {'authors': ['Julien Lange', 'Emilio Tuosto', 'Nobuko Yoshida'], 'title': 'From Communicating Machines to Graphical Choreographies', 'venue': 'In POPL', 'year': 2015}, {'authors': ['Jeff Magee', 'Jeff Kramer'], 'title': 'Concurrency: State Models & Java Programs', 'year': 1999}, {'authors': ['Robin Milner'], 'title': 'A Calculus of Communicating Systems', 'venue': 'Lecture Notes in Computer Science,', 'year': 1980}, {'authors': ['Robin Milner'], 'title': 'Communication and Concurrency', 'year': 1989}, {'authors': ['Nicholas Ng', 'Nobuko Yoshida'], 'title': 'Static deadlock detection for concurrent go by global session graph synthesis', 'venue': 'In CC', 'year': 2016}, {'authors': ['Luca Padovani'], 'title': 'Deadlock and Lock Freedom in the Linear π -Calculus', 'venue': 'In CSL-LICS’14, Thomas A. Henzinger and Dale Miller (Eds.). ACM Press,', 'year': 2014}, {'authors': ['Corina S. Pasareanu', 'Willem Visser', 'David H. Bushnell', 'Jaco Geldenhuys', 'Peter C. Mehlitz', 'Neha Rungta'], 'title': 'Symbolic PathFinder: integrating symbolic execution with model checking for Java bytecode analysis', 'venue': 'Autom. Softw. Eng. 20,', 'year': 2013}, {'authors': ['Sameer Ajmani'], 'title': 'Go Concurrency Patterns: Pipelines and cancellation', 'venue': 'https://blog.golang.org/pipelines', 'year': 2014}, {'authors': ['Kai Stadtmüller', 'Martin Sulzmann', 'Peter Thiemann'], 'title': 'Static Trace-Based Deadlock Analysis for Synchronous Mini-Go', 'venue': 'APLAS', 'year': 2016}, {'authors': ['Nick Stenning'], 'title': 'Building a new router for GOV.UK', 'venue': 'https://gdstechnology. blog.gov.uk/2013/12/05/building-a-new-router-for-gov-uk/. (June 2017)', 'year': 2017}, {'authors': ['Willem Visser', 'Klaus Havelund', 'Guillaume P. Brat', 'Seungjoon Park'], 'title': 'Model Checking Programs', 'venue': 'In The Fifteenth IEEE International Conference on Automated Software Engineering,', 'year': 2000}, {'authors': ['Kai Wei'], 'title': 'How we built Uber engineering’s highest query per second service using Go. https://eng.uber.com/go-geofence', 'year': 2016}]
sections: [{'text': 'This work proposes a practical verification framework for message passing concurrency in Go by developing a robust static analysis that infers an abstract model of a program’s communication behaviour in the form of a behavioural type, a powerful process calculi typing discipline. We make use of our analysis to deploy a model and termination checking based verification of the inferred behavioural type that is suitable for a range of safety and liveness properties of Go programs, providing several improvements over existing approaches. We evaluate our framework and its implementation on publicly available real-world Go code.\nCCS CONCEPTS • Theory of computation→ Verification bymodel checking; Type theory; Process calculi; • Software and its engineering→ Model checking; Automated static analysis; Software verification; Concurrent programming languages; ACM Reference Format: Julien Lange, Nicholas Ng, Bernardo Toninho, and Nobuko Yoshida. 2018. A Static Verification Framework for Message Passing in Go using Behavioural Types. In ICSE ’18: ICSE ’18: 40th International Conference on Software Engineering , May 27-June 3, 2018, Gothenburg, Sweden. ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3180155.3180157'}, {'heading': '1 INTRODUCTION', 'text': 'Modern programming languages have evolved with the ever increasing need for highly available, interactive software services, providing programmers with frameworks that facilitate the development of such intricate communicating systems. Amongst these languages, the Go programming language created at Google in 2007 targets the development of concurrent software systems by integrating channel-based concurrency and lightweight threads as distinctive language features, greatly inspired by advances in formal languages for concurrency theory known as process calculi [43]. Go\nICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden © 2018 Copyright held by the owner/author(s). This is the author’s version of the work. It is posted here for your personal use. Not for redistribution. The definitive Version of Record was published in ICSE ’18: ICSE ’18: 40th International Conference on Software Engineering , May 27-June 3, 2018, Gothenburg, Sweden, https://doi.org/10.1145/3180155.3180157.\nenables programmers to write statically-typed concurrent software, and has been used successfully in a range of industrial settings such as Uber [45] and Dropbox’s infrastructure [15], the Docker [14] software container platform, the Kubernetes [27] cluster manager, among others [9, 41].\nHowever, beyond its simple static type system, Go provides fairly few assurances on the correctness of concurrent code. At compile time, Go only enforces that messages exchanged via communication channels adhere to the declared channel payload types, providing no way of detecting common concurrency errors such as deadlocks or undelivered messages. At runtime, Go offers only a toy global deadlock detector. This is in sharp contrast with the rich body of work on process calculi-based verification, where a plethora of typebased and logic-based techniques enable reasoning about safety and liveness properties of interactive systems.\nGiven the foundations of Go’s message-passing concurrency in process calculi, our work aims to bridge the divide between the foundations and programming practices by applying modern process calculi based verification techniques to real-world Go concurrent programming. Concretely, we propose a static verification framework for concurrency and message-passing communication using concurrent behavioural types [24], which have been developed extensively in concurrency theory since the early 90s.\nTo achieve this, we crucially address the substantial conceptual gap that exists between a formal mathematical language (a process calculus) and a general purpose programming language with concurrency features. Our approach analyses general Go source code and distills from programs behavioural types that serve as a faithful model of its message-passing concurrent behaviour. Our behavioural types consist of a simplified form of concurrent processes which are reminiscent of Concurrent Communicating Systems (CCS) [34] or Communicating Sequential Processes (CSP) [22] (which inspired the design of the Go language). Given such a formally grounded model, we may then apply a range of process calculi oriented verification techniques to Go. Specifically, we convert Go source code into a static single assignment (SSA) form which provides a fine-grained view of the concurrency primitives used in programs in a quasi-functional form [2], enabling our behavioural type inference. We then employ model checking and terminationchecking techniques to automatically verify safety and liveness properties such as deadlock-freedom and communication safety.\nA significant advantage of our approach over previous works [30, 36, 40] is that our inference procedure covers a much larger part of the Go language allowing for the automatic extraction of an accurate model of a program’s concurrency-related features, resulting in a more precise analysis with reduced numbers of false alarms and undetected errors. Our integration with a general purpose model checker also enables us to modularly verify arbitrary safety and\n1 func prod(ch chan int) { 2 for i := 0; i < 5; i++ { 3 ch <- i // Send i to ch 4 } 5 close(ch) // No further values accepted at ch 6 } 7 func cons(ch1 , ch2 chan int) { 8 for { 9 select {\nliveness properties, over the more single-minded nature of previously proposed techniques, as well as take advantage of advances in model checking to provide better performance scaling.\nConcurrent Programming in Go. We provide an overview of the Go programming language with an emphasis on the challenges of concurrent programming and how our verification framework can check for common concurrency errors in programs.\nGo is a language with message-passing concurrency features and lightweight threads (known as goroutines). The key feature of Go’s concurrency primitives is the predominance of channelbased communication over shared memory based communication amongst threads. In Go, a channel consists of a (typed) buffer that can be used by an arbitrary number of threads for read and write operations. Channels are synchronous by default (i.e. blocking on reads and writes) but can be made asynchronous by specifying a buffer size during channel creation. Asynchronous channels provide non-blocking sends while the buffer is not full.\nWe introduce the Go programming language with the program in Figure 1 which implements a producer/consumer concurrent pattern with two producers and one consumer thread, communicating over a pair of synchronous channels. The producer code (lines 1-6) is written as a function that takes as a parameter a channel ch that can carry payloads of type int. A producer merely sends an integer value over the given communication channel ch (written ch <- i in Go, where i is the value to be sent) a predetermined number of times (encoded as a for loop) and then closes the channel, signalling that no further values are to be sent.\nThe consumer code (lines 7-14) is specified as a function taking two channels ch1 and ch2 (one per producer). The cons function consists of a common Go idiom known as a for-select loop: a potentially infinite loop (the parameterless for on line 8) containing a selective communication construct (line 9). The behaviour of select is such that the consumer waits for an input on either ch1 or ch2 (inputs in Go are written <-ch). Whenever communication is available, the appropriate case is selected. The consumer prints the received integer from either producer. Despite the channels being closed by the producers, the consumer’s inputs still succeed.\nFinally, the program entry point (main in lines 15-20) sets up the producers and consumer by creating the two synchronous channels ch1 and ch2 (line 16), spawning two producers in parallel (achieved by the go prefix to the function calls, which creates a goroutine that runs in parallel with the main program executing the prod function) and then running the cons function.\nCommon concurrency errors in Go. We describe common errors in channel-based Go programming, as well as limitations of Go’s built-in runtime detector: Channel safety errors: Once a channel is closed, receive actions always succeed (receiving messages in-flight or a default value for the payload type), but all send and close actions performed on the channel raise a runtime error. Hence, channels should be closed at most once and no message should be sent on closed channels. Global deadlocks: The Go runtime contains a global deadlock detector that signals a runtime error when all goroutines in a program are stuck (i.e. deadlocked). However it is often the case that when certain libraries are imported (such as the commonly used net library for networking) the global deadlock detector is silently disabled [5], i.e. all global deadlocks are just ignored. Partial deadlocks: It is often the case that a program’s communication cannot progress despite some of its goroutines not being stuck. This is known as a partial deadlock or as a failure of liveness. For instance, the cons function above is being executed with the wrong channels (ch1 twice instead of ch1 and ch2), due to a programmer error. Running the program results in a system that is not live, since the second producer is not interacting with the consumer – the outputs are never matched with their respective inputs. Since only a subset of the goroutines are stuck, these errors cannot be detected by the Go runtime.\nA static verification framework for Go. This paper proposes a static analysis toolchain dubbed Godel Checker [31], which can automatically detect safety and liveness errors in real-world Go programs. The workflow is presented in Figure 2, consisting of three layers: given a Go program we first perform (1) behavioural type inference (detailed in § 3) that extracts a behavioural type model for the program (§ 2). In this stage, we use the SSA (static single assignment) package from the Go project and apply a control flow analysis to obtain behavioural types. We then apply (2) a model checking tool, mCRL2 [10], to the extracted behavioural types (§ 4). This enables us to check types with a finite state-space (i.e. finite control) for the absence of global deadlocks, as well as several Go specific safety properties (including channel safety). Finally, to pinpoint potentially problematic loops and accurately detect partial deadlocks, we augment our approach with a termination analysis for loops in the original Go source code using a term-rewriting\nbased tool, KITTeL [17] (§ 5). We show benchmarks for (publicly available) Go programs and compare with existing tools (§ 6).'}, {'heading': '2 BEHAVIOURAL TYPES FOR GO', 'text': 'This section introduces behavioural types [24] for concurrent Go (which are infered as an abstract model of Go – see § 3) and their relationship with Go programs, following our previous work in [30].\nBehavioural types are a typing discipline in which types express the possible actions of a program in a fine-grained way [24]. When applied to communication and concurrency, behavioural types act as an abstract specification of all communication actions that may be performed in a program. Moreover, behavioural types are an executable specification. They have a natural operational meaning and evolve throughout program execution.\nThe syntax of types is given below, it extends the types defined in [30] with general sequencing. The types abstract away data elements, singling out the concurrency specific features such as spawning of threads (i.e. goroutines), creation of communication channels, send and receive actions, and selective communication.\nα B u | u | τ T B {ti (ỹi ) = Ti }i ∈I in S T , S B α ;T | T ; S | T ⊕ S | N{αi ;Ti }i ∈I | (T | S) | 0\n| (newn a);T | closeu;T | t⟨ũ⟩ | ⌊a⌋nk | a ⋆\nCommunication is specified with the α prefix, where α can be u, denoting a send on channelu,u, denoting the dual receive action on channelu and τ , denoting a silent internal step (u is either a constant channel or a variable). T ; S models the sequential composition of T and S . The construct closeu signals that channel u is to be closed. We represent conditional branching with theT ⊕S construct, denoting a non-deterministic internal choice betweenT and S . Thus, our type level analogue of conditional branching does not depend on data but rather simulates the ability to take either branch of a conditional through a non-deterministic step.\nWe model Go’s selective communication with N{αi ;Ti }i ∈I . The construct waits for the availability of one of the αi communication actions. When some action α j becomes available, it is executed and the communication evolves to behaviour Tj (discarding the other options). When more than one communication action is available, one is chosen non-deterministically. Since τ actions are always available to fire, we can use a τ action in a select construct to model timeouts or default behaviours when no other actions are available. The parallel composition construct T | S denotes the parallel execution ofT and S ; the construct 0 denotes no behaviour.\nChannels in Go are synchronous buffers by default, but may also be created with a bound, achieving asynchronous communication. Send actions are non-blocking until the number of messages in the buffer reaches the bound and, dually, receive actions on empty buffers are blocking until a message is available. (newn a);T denotes the creation of a channel a (with a bound n) which can be used locally in T . If the bound n is set to 0, then a is a synchronous channel. We often write (newa);T for (new0 a);T and assume that the scope of a extends as far to the right as possible.\nConstruct t⟨ũ⟩ denotes a function call with parameter ũ. We often identify a list ũ with its underlying set and write x ∈ ũ if x is a element of ũ. We use the following two runtime constructs to define the semantics of types in § 4: ⌊a⌋nk represents a communication\nchannel at a (where n is the maximum capacity of the queue and k is the current number of messages in it) and a⋆ represents a closed channel a.\nThe type of a program, sometimes written {ti(ỹi ) = Ti }i ∈I in S , is a set of (potentially mutually recursive) definitions Ti with a distinguished program entry point S . Recursive definitions can be parameterised by communication channels and represent the goroutines that are executed in the program. For each type definition ti(ỹi ) = Ti we assume that the free names of Ti are included in ỹi .\nExample 2.1 (Type for Consumer-Producer and their Properties). The behavioural type for the program of Figure 1 is given below.{ prod(ch) = ch;prod⟨ch ⟩ ⊕ close ch cons(ch1, ch2) = N{ch1; cons⟨ch1, ch2⟩, ch2; cons⟨ch1, ch2⟩ } main() = (new ch1, ch2); (prod⟨ch1⟩ | prod⟨ch2⟩ | cons⟨ch1, ch1⟩)\n} in main⟨⟩\nDefinition prod(ch) specifies the type for the Producer function, while cons(ch1, ch2) stands for the type of the Consumer function, and main⟨⟩ is the type of the program entry point (i.e. the main function). Notice how the imperative control structures are transformed into recursive definitions and the data elements are erased. For instance, the type prod specifies the behaviour of performing an internal choice (denoted by the ⊕ construct) between sending on ch and recursing or closing the channel ch and terminating.\nGiven that behavioural types act as a form of executable specifications, it is natural to consider properties of types in terms of their executions, as well as their relationship with program properties.'}, {'heading': '2.1 Behavioural Properties of Types', 'text': 'The property of global deadlock-freedom (GDF) entails that if a communication action is available to fire, the type can always make progress, meaning that a type as a whole is never globally stuck. For instance, the type main in Example 2.1 satisfies GDF since the communication actions in subcomponents prod⟨ch1⟩ and cons⟨ch1, ch1⟩ can always make progress, despite the fact that actions in prod⟨ch2⟩ are always stuck.\nThe property of liveness, also known as partial deadlock freedom, is strictly stronger than GDF, given that every live type is also GDF. It states that all communications that can become enabled in a type can always eventually fire. For instance, replacing the call to cons⟨ch1, ch1⟩ with cons⟨ch1, ch2⟩ makes the type main⟨⟩ in Example 2.1 satisfy liveness. We note that in the presence of internal choice (i.e. conditional branching), liveness requires that communication actions in both branches must eventually succeed, but when facing external choice (i.e. the select construct), only branches that can be selected are required to eventually succeed. For instance, the following single-producer variant of main⟨⟩ also satisfies liveness even though the ch2 branch in the select construct can never be taken: (new ch1, ch2); (prod⟨ch1⟩ | cons⟨ch1, ch2⟩).\nIn § 4, we formally define the above properties, as well as other properties that are verified in our work, in the modal µ-calculus.'}, {'heading': '2.2 Relationship between Types and Programs', 'text': 'In our analysis, a conditional is abstracted as a non-deterministic choice between the two alternative behaviours present in the then\n1 func main() { 2 ch := make(chan int) // Create channel 3 go sendFn(ch) // Run as goroutine 4 x := recvVal(ch) // Ordinary func call 5 for i := 0; i < x; i++ { 6 print(i) 7 } 8 close(ch) // Close channel ch 9 }\n10 func sendFn(c chan int) { 11 c <- 42 // Send on channel c 12 } 13 func recvVal(c chan int) int { 14 return <-c // Receive from channel c 15 }\nListing 1: A simple concurrent program in Go.\nand else branches. This coarse abstraction introduces a subtle interaction between non-terminating program behaviour and datadependent communication wrt. liveness [30, § 5] (we note that this issue does not affect GDF or Channel Safety). For instance, consider the following Go program:\n1 func send(n int , c chan int) { 2 if n%2 == 0 { // Conditional (send if n is even) 3 c <- n // Send to channel c 4 } 5 send(n, c) 6 } 7 func recv(c chan int) { 8 for { // Infinite loop 9 x := <-c // Receive from channel c\n10 } 11 } 12 func main() {'}, {'heading': '13 c := make(chan int)', 'text': ''}, {'heading': '14 go send(3, c)', 'text': '15 go recv(c) 16 }\nThe type for the function send (lines 1-6) is send(c) = c ; send⟨c⟩ ⊕ send⟨c⟩. Similarly, the type for recv (line 9) is recv(c) = c ; recv⟨c⟩. The type for the program above is deemed live since the then branch of the conditional in send can always eventually be reached through recursion, ensuring that the inputs in recv are matched. However, in the program the then branch of the conditional can never be reached and so the inputs in recv cannot succeed.\nThis example is symptomatic of a mismatch between type and program liveness in the presence of infinite executions that flow through a conditional. Note that it is not the case that the simple existence of non-termination makes the liveness analysis unsound [30, § 5]. For instance, for the example in § 1, type liveness implies program liveness, despite the presence of non-termination, since there is no communication contingent on a data-dependent test.\nIn § 5, we address this issue by deploying a lightweight termination analysis of iterative behaviour in our framework.'}, {'heading': '3 BEHAVIOURAL TYPE INFERENCE', 'text': 'We detail one of the main contributions of our work: the development and formalisation of a procedure that infers, whenever possible, behavioural types from Go source code. The inference consists of two key steps: (1) the conversion of Go source code to\na static single assignment (SSA) intermediate representation (IR), using the ssa package from the Go standard library; and (2) the extraction of the communication structure as behavioural types from SSA blocks.'}, {'heading': '3.1 From Go source code to SSA IR', 'text': 'The ssa package [4] represents source code in SSA form and provides a high-level API for manipulating Go source code programatically. Go programs are organised as packages which consist of package variables and functions (also definable within bodies of functions). Each function is transformed into a list of blocks of SSA instructions, with one block marked as the function entry point.\nFigure 3 gives a graphical view of the SSA representation of the program in Listing 1. Each of the three Go functions main(), sendFn (), and recvVal() becomes a set of blocks (graphically, a dotted box represents the scope of the function). The last instruction of a block is always a control flow instruction ( i f , jump, or r e t u r n) connecting the block to its successors (if any). The successor relation is shown in the graph via edges connecting blocks within a function. There are also entry and return arrows for function entry and exit respectively, implicit from the SSA IR. Table 1 summarises the instructions of interest to our inference.\nCommunication instructions. Go’s channel-based communication constructs are actual primitive language constructs. Thus, the key operations such as channel creation make(chan T), cf. line 2 from Listing 1, sending and receiving values over channels, ch <- value and <-ch respectively (lines 11 and 14), spawning of goroutines (go sendFn() in line 3), and closing channels, i.e. close operation (line 8), are all explicit in the SSA IR. As a result, identifying the channel operations that match with the corresponding behavioural types is straightforward.\nSelect instructions. Non-deterministic selective communication (select) also appears explicitly in the SSA representation but requires a more intricate representation. We illustrate the structure of the SSA representation of the select block from Listing 2 in\nFigure 4. Listing 2 shows a simple function myselect(c)which consists of a select construct featuring three cases: the first is guarded by a receive action on channel c, the second is guarded by a timeout, and the last is the default case (executed if none of the other cases are ready to be executed). The SSA IR of myselect(c) consists of 6 blocks. Block 0 is the entry point of the function, containing the SSA instruction for select. Note that the instruction s e l e c t nonblocking [<−c , <− t 0 ] contains only two cases. The default case is identified by the keyword nonblocking; if a select does not specify a default case its SSA representation becomes s e l e c t blocking [<−c , <− t 0 ] . We note that timeouts are implemented in Go as channels (e.g., t0) that receive a message after a predetermined time. This message is placed into the channel by the runtime and not by a user-level send. The statement t 2 = e x t r a c t t 1 #0 determines the index of the case which will be executed and stores it in t2. Block 0 ends with an if-then-else construct, which is the first of an if-then-else chain identifying which case of the select is to be executed depending on the value of t2. Blocks 2 and 4 represent the bodies of the first two cases, respectively. Block 5 contains the body of the default case (the default case is always the last block of the chain); if a select statement does not specify a default case, then this block contains a “panic” instruction which cannot be executed in normal circumstances. Finally, block 1 represents the code that follows the select statement.\nPhi instructions. Another key SSA instruction is phi [ Blk i : vi ] i ∈InEdges which is used to select between two or more variables when merging the control flow into one SSA block. An example of such an instruction is given in block 3 of Figure 3 where the instruction is used to select the value of variable t5 (the index of the for loop) depending on whether the predecessor of block 3 is block 0 or block 1. The former corresponds to the initialisation step of the loop (in which case the index is 0), the latter corresponds to an execution of the body of the loop.\nConventions. Given an SSA statement s , e.g., t 0 = make chan i n t 0 , the left-hand-side (LHS) is the part of the statement on the left of the = symbol (the variable t0). The key features of the SSA representation are that, within the scope of a function, all the LHS of the statements in the blocks of that function are\n1 func myselect(c chan int) { 2 select { 3 case msg := <-c: 4 print("received: ", msg) 5 case <-time.After(time.Second): 6 print("timeout: ready in 1s") 7 default: 8 print("default: always ready") 9 }\n10 }\nListing 2: A select statement in Go.\npairwise distinct. Also, the static typing information is available for each statement. In addition, variables declared at the package level are initialised in a special init() function. Variables that are accessed by anonymous functions appear in the header of the SSA representation of that function as free variables.'}, {'heading': '3.2 Extracting type definition bodies', 'text': "In Step (2) we soundly approximate, whenever possible, the communication behaviour of Go programs with the type language. First, for each SSA block n in each function fun(x̃), we generate a type signature of the form funn(ỹ, t̃ , ṽ) where: ỹ is a subsequence of x̃ where each y in ỹ is a channel parameter t̃ is a list of channel variables that appear in the LHS of the\nstatements in the predecessors of block n and do not appear in the LHS in block n ṽ is a list of global channel variables (declared outside of function fun, e.g., package level variables).\nWe store all signatures in an environment ∆ and write ∆(fun,n) for the signature of block n in function fun.\n3.2.1 Core procedure: genFunction. We present the core algorithm, the genFunction procedure, which generates a type abstraction from an SSA block. The procedure takes five parameters: fun, the name of the function being considered; n, the identifier of the block; k , the line number within block n; ρ, the type we have constructed thus far; and Γ, a context which maps each channel variable name to its representative.\nfunction genFunction(fun, n, k, ρ, Γ) switch s← statement at line k do\ncase t =make chan T S do genFunction(fun, n, k+1, ρ ; (newS t), Γ[t 7→ t])\ncase t = l o c a l chan T do genFunction(fun, n, k+1, ρ, Γ[t 7→ ⊥])\ncase t <−v or <− t or t '=<− t do genFunction(fun, n, k+1, ρ ;mkPrefixΓ(s), Γ) case c l o s e ( t ) do genFunction(fun, n, k+1, ρ ; close Γ(t), Γ)\ncase r e t u r n do return ρ ; 0 case jump i do return ρ ;mkJumpΓ(fun, i) case i f _ goto i e l s e j do\nreturn ρ ; (mkJumpΓ(fun, i) ⊕ mkJumpΓ(fun, j)) case s e l e c t b [д1, . . . , дj ] do\nρc ← mkJumpΓ(fun, n+1) for i in [1, . . . , j] do\nρi ← mkPrefixΓ(дi ) ρ′i ← mkJumpΓ(fun, n+2∗i)\nif b = nonblocking then ρd ← mkJumpΓ(fun, n+1+2∗j) return N{ρi ; ρ′i ; ρc }i∈{1, . . ., j } ∪ {τ ; ρd ; ρc }\nelse return N{ρi ; ρ′i ; ρc }i∈{1, . . ., j } case F ( x̃ ) or t =F ( x̃ ) do\nif t is a channel then abort else genFunction(fun, n, k+1, ρ ;mkCallΓ(F, x̃ ), Γ)\ncase go F ( x̃ ) do ρ′← genFunction(fun, n, k+1, ◦, Γ) return ρ ; (mkCallΓ(F, x̃ ) | ρ′)\ncase ∗ t 0 = t 1 or t 0 = ∗ t 1 do if t 1 is a channel then\ngenFunction(fun, n, k+1, ρ, Γ[t0 7→ Γ(t1)]) else genFunction(fun, n, k+1, ρ, Γ)\ncase phi [ Blk i :vi ] i∈InEdges do if ∃i ∈ InEdges : vi is a channel then abort else genFunction(fun, n, k+1, ρ, Γ)\notherwise do genFunction(fun, n, k+1, ρ, Γ)\nAlgorithm 1: Pseudo-code of genFunction\nThe context Γ is crucial in our development as Go allows channels to be aliased (i.e., several variables may contain a reference to the same channel) and channel variables to be overwritten, e.g., a channel variable may refer to different channels at different point of the execution of a program, or may be declared and only initialised at a later point. We keep track of aliased channels by assigning a unique representative to each newly created channel. We write Γ[t 7→ t′] for the context Γ where the mapping from t is updated to t′. We assume that Γ[t 7→ t′] is undefined if t ∈ dom(Γ) and Γ(t) , ⊥ in order to disallow channel overwriting.\nAlgorithm for genFunction. Our algorithm relies on auxiliary (partial) functions for the translations from statements to types:\nmkPrefixΓ(s) send/receive actions and select guards mkJumpΓ(fun, j) jump statements mkCallΓ(fun, x̃) function calls\nEach function uses context Γ to generate communication actions and type definition calls, respectively.\nAlgorithm 1 gives the implementation of genFunction which iterates over the lines of block n in function fun and makes a case analysis depending on the structure of the statement s found at line k . The procedure returns a behavioural type or aborts whenever an invocation to auxiliary functions is undefined or when the algorithm reaches an “abort” statement, since in these cases we cannot guarantee a sound approximation of program behaviour. In particular, the algorithm aborts if a channel variable is overwritten (a new channel is assigned to it). Channel creation/declaration. If s is a channel creation statement, variable t becomes the representative name for this channel and we update the environment with Γ[t 7→ t]. The SSA representation guarantees that t is unique in function fun. We create the corresponding new channel type construct and recursively call genFunction over the next line. If s is a channel declaration statement, we update the environment with Γ[t 7→ ⊥]. Note that t can only be used after it is initialised. Send/receive. If s is a send or receive statement, we translate it to a type construct with a call to mkPrefixΓ(s), defined below:\nmkPrefixΓ(s) =  u if s = t <−v and Γ(t) = u u if s ∈ {<− t , t '= <− t } and Γ(t) = u τ if s = <− t and t is a timeout channel\nTimeout channels are dedicated channels created at compile time to encode timeouts, they are never added in the context Γ. Close is mapped to its respective type primitive, via context lookup. Return.We return the type built so far appended with the termination construct. Jump. We translate a jump statement into a type function call through the auxiliary function defined below, which uses the globally available signature environment (∆).\nmkJumpΓ(fun, j) =  funj⟨ỹ, Γ(t̃), ṽ⟩ if ∆(fun, j) = funj(ỹ, t̃ , ṽ) and ∀t ∈ t̃ : Γ(t) , ⊥ ⊥ otherwise\nmkJumpΓ(fun, j) models a jump to another block within the same enclosing function hence there is no need to rename the parameters nor the “global” variables from the function signature (since they are fixed within the scope of the function). Instead, the internally declared variables are replaced by their representatives using Γ. The function mkJumpΓ(fun, j) is undefined if any of the t̃ arguments maps to an uninitialised channel in order to guarantee that these cannot be overwritten in the definition of fun. The ỹ and ṽ arguments are assumed to be initialised by the parent function. Conditional constructs are also translated straightforwardly using ⊕ and type definition call. Select. If s is a s e l e c t construct then s is followed by a chain of blocks linked by if-then-else statements, which encode the branching structure of the select, as explained in § 3.1. The jump to the continuation of the select statement is stored in ρc , while the guard and body of each case is stored into ρi and ρ ′i , respectively. If the select statement contains a default case (b = nonblocking), we additionally translate the last block of the chain into a type function call. The guard and body of each case is then appended with the\nfunction genBody(fun, n) funn(ỹ, t̃, ṽ) ← ∆(fun, n) Γ← [x 7→ x ]x∈ỹ, t̃,ṽ return genFunction(fun, n, 0, ◦, Γ)\nfunction genEquations() return {∆(fun, n) = genBody(fun, n) | (fun, n) ∈ dom(∆)} in main0 ⟨⟩\nAlgorithm 2: Pseudo-code of the overall algorithm.\ntype function call corresponding to the continuation and all the components are packaged into an external choice construct. Function calls. If s is a function call, we create a corresponding type definition call using the auxiliary function mkCallΓ(fun, x̃), which defined as follows:\nmkCallΓ(fun, x̃) =  fun0⟨Γ(x̃), ṽ⟩ if ∆(fun, 0) = fun0(ỹ, ṽ) and ∀x ∈ x̃ : Γ(x) , ⊥ ⊥ otherwise\nNote that the arguments are replaced by their representatives according to Γ and the function is undefined if any of them refers to an uninitialised channel. Goroutines. If s spawns a new goroutine, we proceed similarly to the function call case but place the call in parallel with its continuation, which is computed through a call to genFunction, starting with an empty behavioural type (denoted by ◦). Aliasing. If s stores a channel variable into another, we update the context with Γ[t0 7→ Γ(t1)] (which is undefined if Γ(t0) , ⊥). Phi. If s is a phi statement, we proceed only if it does not overwrite channels – we discuss how to lift this restriction in § 5.\nWe skip all other statements as they do not pertain to communication or concurrency.\n3.2.2 Top-level procedure: genEquations. Finally, we generate the body of type definitions using the genFunction procedure and thus obtain a set of recursive equations as required. Algorithm 2 gives the overall generation process. We iterate over each type signature (and therefore each SSA block) to generate a type implementation starting with a context Γ which is initialised to the identity function for each of the parameters. The algorithm returns a set of (possibly mutually recursive) type definitions, whose entry point is the program entry point, e.g.,main0⟨⟩.\nExample 3.1. Consider the Go program from Listing 1 and its SSA representation in Figure 3. The set of type definitions infered from this example is given below.\nmain0() = (new t0); (sendFn0⟨t0⟩ | recvVal0⟨t0⟩;main3⟨t0⟩) main1(t0) = main3⟨t0⟩ main2(t0) = close t0; 0 main3(t0) = main1⟨t0⟩ ⊕main2⟨t0⟩ sendFn0(c) = c; 0 recvVal0(c) = c; 0\nNote that the spawning of the goroutine sendFn(ch) becomes a parallel composition of the main thread with sendFn0⟨t0⟩.\nExample 3.2. Consider the Go program from Listing 2 and its SSA representation in Figure 4. Its inferred type definitions are\ngiven below. myselect0(c)=N { c;myselect2⟨c⟩;myselect1⟨c⟩, τ ;myselect4⟨c⟩;myselect1⟨c⟩, τ ;myselect5⟨c⟩;myselect1⟨c⟩\n} myselecti(c)= 0 for i ∈ {1, 2, 4, 5} myselect3(c)= myselect4⟨c⟩ ⊕myselect5⟨c⟩\nThe type’s entry point is myselect0(c) and myselect3(t0) is unused. Note how each branch of the select consists of the sequential composition of a guard, a type function call corresponding to the body of the branch, and a call to the continuationmyselect1⟨t0⟩."}, {'heading': '4 MODEL CHECKING BEHAVIOURAL TYPES', 'text': 'We present our model checking based analysis of the finite control fragment of behavioural types. We proceed in three steps: (1) we generate a (finite) labelled transition system (LTS) for the types from a set of operational semantics rules; (2) we define properties of the states of the LTS in terms of the immediate actions behavioural types can take; and (3) we give safety and liveness properties expressed in the modal µ-calculus [28].\nThe notion of finite control has several definitions in the literature [8, 11] but is generally understood to refer to having finitely many reachable states (possibly up-to some equivalence relation). Here we adopt the definition of finite control used by the mCRL2 toolchain [10]: types cannot feature parallel composition or channel creation operators under recursion, which is a sufficient condition to guarantee a finite state space. For instance, types of the form t(x̃) = t⟨x̃⟩ | T or t(x) = (newa); t⟨a⟩ are not finite control as the former generates infinitely many instances of type t(x̃) while the latter generates infinitely many channels.\nSemantics of types. Before proceeding to Step (1), i.e., the generation of a labelled transition system (LTS) from behavioural types, we introduce the semantics of types. The semantics follows\nstandard definitions from CCS and CSP, accounting for the constructs that are specific to the Go programming language. The labels, ranged over by α and β , have the form:\nα , β B a | a | τ | τa | cloa | cloa | a⋆ | •a | a•\nand their meaning is given in Table 2. We assume types are in normal form, with all channel creations at the outermost top level. In a finite control setting we can always soundly rewrite types to satisfy this normal form using the equivalences defined in Figure 6. Thus, a program’s type is always of the form:\n{ti (ỹi ) = Ti }i ∈I in (newn0 a0) . . . (newnk ak ); t0⟨⟩ where the several Ti contain no channel creations. We also make use of the following transition which initialises all the channels accordingly and write A for the set of all initialised channels: {ti (ỹi ) = Ti }i ∈I in (newn0 a0) . . . (newnk ak ); t0⟨⟩\nτ−→ {ti (ỹi ) = Ti }i ∈I in (t0⟨⟩ | ⌊a0⌋n00 | . . . | ⌊ak ⌋ nk 0 )\nWe give the semantic rules for behavioural types in Figure 5, adapted from [30], where T\nα−→ T ′ denotes that T reduces to T ′ by producing α , according to the rules in Figure 5. In the first line, the rules respectively model send, receive and silent actions. In the second line, the rules respectively model close actions, the closure of channel a and a closed buffer sending default values. In the third line, the rules respectively model a silent transition representing an internal choice and an external choice. The fourth line gives the standard rules for parallel and general sequencing. The rule in the fifth line models the synchronisation between a type or buffer firing a send-like action (i.e., a send action, a closed buffer, or a non-empty asynchronous buffer) and a receive action or a non-full buffer. The sixth line gives standard rules to deal with αequivalence and unfolding of definition calls. In the seventh line, the rules respectively model the synchronisation of a type and a buffer a to effectively close a, and the action of adding (resp. removing) an element in (resp. from) a buffer, where n is the capacity of the queue and k is the number of messages currently stored in the queue. We have omitted symmetric rules for parallel and synchronisations.\nIn Step (1), given a finite control type in normal form, we construct a finite labelled transition system which represents all possible executions of t0⟨⟩, i.e., the entry point type under all the name restrictions. The LTS of t0⟨⟩ is a tuple T = (S, t0⟨⟩,−→,A) such that S is a set of states implicitly labelled by behavioural type terms (we often identify labels and states), t0⟨⟩ ∈ S is the initial state, A ⊆ {τ } ∪ {τa | a ∈ A} is the set of labels, and −→⊆ S × A × S is the transition relation T\nα−→ T ′ where the label α can be either a silent move, i.e., τ , or a synchronisation over a channel, e.g., τa .\nTable 2: (Predicate) labels\na / a send / receive on channel a τa synchronisation over a τ silent action cloa / cloa request to close a / closing a a⋆ channel a is closed •a / a• push / pop on buffer a õ waiting to synchronise over the actions in õ\na;T ↓a closea;T ↓cloa a;T ↓a a⋆ ↓a⋆\n∀i ∈ {1, . . . ,n} : αi ↓oi N{αi ;T }i ∈{1, ...,n } ↓{o1 ...on }\nT ↓o T ;T ′ ↓o\nT ↓a T ′ ↓a or T ′ ↓a⋆ T | T ′ ↓τa\nT {ã/x̃} ↓o t(x̃) = T t⟨ã⟩ ↓o\nT ↓a αi ↓a T | N{αi ; Si }i ∈I ↓τa\nT ↓a or T ↓a⋆ αi ↓a T | N{αi ; Si }i ∈I ↓τa\nk < n ⌊a⌋nk ↓•a k ≥ 1 ⌊a⌋nk ↓a• T ↓a T ′ ↓•a T | T ′ ↓τa T ↓a• αi ↓a T | N{αi ; Si }i ∈I ↓τa\nT ↓o T | T ′ ↓o\nT ↓o a < fn(o) (newn a);T ↓o\nT ↓o T ≡ T ′\nT ↓o\nFigure 7: Barb predicates for types.\nProperties of behavioural type states. In Step (2), we define predicates over the state labels of the LTS defined above. This allows us to analyse what actions a given state (or type) can fire immediately. Concretely, we define a family of predicates of the form T ↓o or T ↓õ which holds if T is ready to fire action o or one of the actions in õ, with o,oi ∈ {a,a,τa , cloa,a⋆,• a,a•}. Table 2 explains the meaning of each label and Figure 7 gives the defining rules of the predicates T ↓o and T ↓õ . Essentially, T ↓o if T is immediately ready to fire actiono (witho , τ ) andT ↓õ ifT contains an external choice which does not feature a branch guarded by τ (i.e., τ < õ). We have, e.g., ¬(τ ;T ↓o ) for any o and ¬(N{τ ;T1, a;T2} ↓õ ) for any õ, which is an important subtlety for defining accurate safety and liveness properties.\nLiveness and safety properties. In Step (3), we encode liveness and channel properties (including those discussed in § 2.1) in the µ-calculus [28] extended with the atomic propositions on state labels defined in Step (2).\nA µ-calculus formula ϕ is interpreted on a pointed LTS, i.e., an LTS with a starting state T , we write T |=T ϕ if T satisfies ϕ in the LTS T . Namely, formula ⊤ holds for every T (while ⊥ never holds). The construct [α]ϕ is amodal operator that is satisfied if, for each α-derivativeT ′ ofT (i.e.T ′ is reachable fromT by performing action α ), the formula ϕ holds in T ′. The dual modality is ⟨α⟩ϕ which holds if there is an α-derivative T ′ of T such that ϕ holds in T ′. Construct νx.ϕ (resp. µx.ϕ) is the standard greatest (resp. smallest) fixpoint operator (binding x in ϕ). The atomic proposition ↓o (resp. ↓õ ) holds iffT ↓o (resp.T ↓õ ). Given a set of actionsA ⊆ A, we write [A]ϕ for∧α ∈A[α]ϕ and ⟨A⟩ϕ for∨α ∈A⟨α⟩ϕ.\nWe now describe several properties which can be verified using the model checker mCRL2 [10]. Below we refer to the formulae given in Figure 8. Given a µ-calculus formula ϕ, formula Ψ (ϕ) holds if ϕ holds for all reachable states, while formula Φ (ϕ) holds if ϕ holds in some reachable state. Formula Ψ (ψt ) holds if no terminal state is reachable in T , i.e., the behavioural types only exhibit infinite executions; dually formulaψc holds if there are no cycles in T , this property is useful as it implies that liveness of types corresponds with liveness of programs (cf. § 2.2). Formula Ψ ( ψд\n) models the global deadlock-freedom property discussed in § 2.1, i.e., the formula holds if for each state T in T if T is ready to execute a send or receive action, then T has a successor. Formula Ψ ( ψla ∧ψlb ) models the liveness property (cf. § 2.1). It holds if for all state T in T (i) if T is ready to send/receive on a, there is always eventually a synchronisation on a (cf.ψla ), and (ii) ifT has a select construct, which does not contain a τ -branch, there is always eventually a synchronisation over one of the channels guarding the construct (cf.ψlb ). Formula Ψ (ψs ) models the channel safety property, i.e., no send nor close action is executed on a channel that is already closed. Formula Ψ (ψe ) models eventual reception, which guarantees that when a channel is not empty, the head of its buffer can eventually be consumed.'}, {'heading': '5 IMPLEMENTATION', 'text': 'We present the Godel Checker toolchain of Figure 2 which consists of two core components: an inference tool and a type verifier.\nInference tool. The type inference tool implements the core algorithms described in § 3, with additional adjustments to support analysis of real world Go programs, which we discuss below. Uninitialised channels: Uninitialised channels (or nil channels) can be used in Go, but they always block on communication. To model this behaviour, we prefix any communication on an uninitialised channel with a (new a) construct (with a fresh). Composite data structures: Our tool supports channels that are stored in structs by flattening such constructs into several channels. We only support structures that store finitely many channels (e.g., arrays or linked-list of channels are not supported). Uniform representation of functions: A uniform representation of callable objects is used as an abstraction when obtaining the type signature of an SSA block. This allows us to support return values\nand closures by uniformly converting return values and closure binding as additional function parameters. Channels in phi instructions: We support SSA instructions to merge control flow (phi ) when they refer to channels by adding a parameter to the type definition of its enclosing block and modifying function calls accordingly.\nType verifier. The type verifier transforms the inferred behavioural types into an LTS and properties into µ-calculus formulae following the methodology in § 4 for the mCRL2model checker, and also into input for the KiTTeL termination analyser. Model checking: Once a behavioural type has been inferred from Go source code, we translate it straightforwardly to the mCRL2 language [19]. Before generating the µ-calculus formulae described in § 4, we analyse the model so to build the smallest formulae possible. Finally, we run the mCRL2 model checker for each formula and return the result to the user. Termination checking: To address the mismatch between types and programs detailed in § 2.2 we deploy a termination analysis of loops, using the KITTeL termination analyser [16]. The tool targets C programs and is based on integer term rewriting. The choice of this particular analyser amounts to the syntax of Go being close to C, its usability and performance.\nThe analysis takes advantage of the inference procedure of § 3 to collect the locations and parameters of loops in a given program, which are then checked for termination. Our analysis checks that the loop parameters are enough to make each loop eventually terminate, regardless of the non-loop code within the loop itself. This enables us to pinpoint program locations where liveness of types may not entail the analogue property in the program – if the termination analysis identifies the program as terminating, the liveness properties on types and programs coincide [30, § 5].\nThe analysis generates all loops in the original Go program as a set of C functions, ignoring all other Go statements. Each C function (and thus, each loop) is then individually checked for termination. Since loops can be nested, our analysis takes this into account by replicating the nesting in the generated C functions. For instance, for the following code snippet, 1 func f(n int) { 2 for i := 0; i < n; i++ { 3 for j := 0; j < 10; j++ { ... } 4 } 5 }\nour tool generates a single C function f containing the two loops. Statically unknown values in loop parameters (e.g. the parameter n of function f above) are generated as parameters of the respective C functions. This forces the termination checker to verify termination for all possible values of the unknown parameter. Such values can appear due to usages of function arguments, values contained in dynamic data structures or communicated data.\nOur analysis relies on the following: loops in Go programs generate types with conditional branching combined with recursion; most programs use traditional imperative control flow features such as for loops, for-range loops (i.e. loops over a fixed finite data structure) and for-select loops (i.e. an infinite loop with a select that can break the loop – the Consumer function of Figure 1) instead of recursion; we assume that loop indices are not modified in loop bodies and that no goto-like constructs are used in a loop.\nSince the analysis only takes into account loop parameters, a loop that indefinitely blocks (e.g. due to communication) may be identified as terminating. However, if our analysis identifies the inferred types as live and the termination check validates the program, both termination and program liveness are guaranteed.'}, {'heading': '6 EVALUATION', 'text': 'Table 3 lists several benchmarks of our tool against other static deadlock detection tools for Go (a detailed comparison of these tools is given in § 7). The benchmarks were run with go1.8.3 on an 8-core Intel i7-3770 machine with 16GB RAM on a 64-bit Linux. The model checker we used was mCRL2 v201707.1.\nThe results for Godel Checker are shown in columns 4–12. Column 4 shows the number of states in the input LTS as a measurement of the relative complexity of each program (proportional to the number of concurrency-related operations rather than the number of lines of code). Columns 5–8 shows the core formulae of Figure 8 in § 4, i.e. no global deadlock (ψд ), liveness (ψl ), channel safety (ψs ) and eventual reception (ψe ). A ✓ mark means that the considered tool reports that the property holds. For example, in the case of Godel Checker, a ✓ mark under columnψд means that the formula Ψ ( ψд ) evaluates to true. In the case of GoInfer/Gong a ✓ mark under column Live means that the tool reports the program to be live, as defined in [30]. A × mark indicates that the considered tool reports that the property in question does not hold. Columns 9–12 list the running time of Godel Checker, where Column 10 lists the inference time, Columns 10 and 11 are the model checking times for liveness, and both liveness and channel safety, respectively. The total run time can be obtained by adding Column 9 to Column 10 or 11. Unless otherwise stated, all times are in milliseconds. Column 12 (Term) shows the result of the termination check, which proves the termination of loops in the given program, or times out after\n15s. A program that times out is conservatively assumed not to terminate.\nColumns 13–14 pertain to the dingo-hunter tool from [36]. The time includes both communicating finite state machine extraction and their analysis, but does not include building the global graph and only checks for liveness. Columns 15–16 pertain to the gopherlyzer tool [40], which only checks for global deadlockfreedom (most programs had to be manually adjusted in order to be accepted by this tool – see § 7 for the severe practical limitations of the tool). Columns 17–19 refer to the GoInfer/Gong tool from [30]. The times include both type inference and analysis stages, which only accounts for liveness and channel safety checks. Most programs in Table 3 are taken either from other papers on the static verification of Go programs [30, 36, 40] or from publicly available source code. Programs 7, and 15–22 are benchmarks introduced by this work. Programs that are unsupported by a tool are marked with n/a. Table 3 includes all the benchmarks from previous works, except for 3 non-finite control examples from [30] which our tool cannot analyse (i.e., like sieve) and htcat from [36] which is manually transformed to be supported by dingo-hunter.\nPrograms 1–7 are typical concurrent programs from the literature. The sieve program is not finite control (it spawns an infinite number of threads), thus it can only be analysed by GoInfer/Gong. Program 6 is a (three) dining philosophers program where the first fork can be released, while Program 7 is the traditional deadlocking version (Program 19 is as Program 6 but with 5 philosophers). dingo-hunter does not support Programs 6, 7, and 19 due to dynamically spawned goroutines, while gopherlyzer does not support them due to a nested select statement. GoInfer/Gong analyses them correctly, but is much slower than Godel Checker.\nPrograms 8–12 consist of idiomatic Go patterns which are all handled correctly and quickly by our tool. Program 13 is a publicly\navailable program which is not live. Program 14 is an implementation of the alternating bit protocol. Program 15 is the ProducerConsumer example from § 1, which is not live. All tools were able to verify this simple program. Program 16 demonstrates the mismatch between type and program liveness, where the type is live but due to an erroneous loop the program does not terminate and causes a partial deadlock. The termination check identifies this as possibly non-terminating, while GoInfer/Gong incorrectly identifies it as live. Program 17 closes a channel twice which flags a violation of channel safety in Godel Checker and GoInfer/Gong. Interestingly, dingo-hunter detects a deadlock (a false alarm) due to its representation of channel closure as a message exchange, but not due to the double close. gopherlyzer also detects a deadlock incorrectly due to the same reason. Program 18 is a program that violates the eventual reception property by sending an asynchronous message that is never received – none of the earlier tools can detect this.\nPrograms 19–22 demonstrate the scalability of our approach. Program 22 is a concurrent data stream multiplexer, for handling multiple independent data streams in a single TCP connection. It consists of 16k lines of code of which only a small portion relate to concurrency (which is the case with common concurrent Go applications). The program is not natively finite control since it spawns request handlers as goroutines in a loop. Noting that request handlers do not interact with each other, we modified the program to handle requests sequentially and enable our analysis.\nWe note that while the execution time for small programs is slightly higher than the other tools (but still under 2 seconds), Godel Checker is a more general tool since it can verify arbitrary properties expressible in the µ-calculus and our precise inference allows us to reduce both the false alarms and, crucially, undetected liveness errors. The verification times also suffer from the initialisation of mCRL2 (the tool uses 3 binaries). In small programs the running times are generally dominated by this fact, which is the reason why the times are quite similar. This is amortised in programs with large state spaces (cf. second part of Table 3), where the efficiency of mCRL2 produces gains of several orders of magnitude over gopherlyzer and GoInfer/Gong while performing more detailed analyses. We note that a significant portion of the inference time is due to the translation into SSA by the ssa package.\nLimitations.As explained in § 3, our inference does not support channel variable overwriting, i.e., we only support immutable channel variables. In addition, it does not support channels in dynamic data structures – such as arrays, slices (variable sized arrays) and dictionaries – or recursively defined data structures (e.g. linked lists). However, our tool ensures that such data structures do not contain channels and can be safely ignored, signalling an error otherwise. We also require channel buffer sizes to be statically known. While the inference is agnostic to the finite control limitation of the model checking tool, if a type is inferred successfully, it must be finite control in order for our type verifier to produce an output. We note that these limitations are also present in the other tools mentioned in this section (GoInfer/Gong supports infinite state systems by performing a bounded verification).'}, {'heading': '7 RELATEDWORK AND CONCLUSION', 'text': 'Applying programanalyses to real-world software. The errorprone nature of concurrent software has led to a plethora of works on automated verification of concurrency via program analysis. However, these works mostly target lock-based concurrency (such as those based on Java Pathfinder [3, 21, 38, 44] or abstract interpretation [29]) and so are of a fundamentally different nature than our work targetting message-based concurrency in Go. Verification of Go programs. Despite the young age of Go, it has received some attention from the research community. The work of [36] is to the best of our knowledge the first to tackle static verification of Go programs. Their work uses multiparty session types [23] and their connection to communicating automata [12, 32] to check for liveness in Go by extracting communicating finite state machines from source code. However, their work cannot support dynamic spawning of goroutines (requiring all goroutines to be executing before any communication takes place) nor asynchrony. This severely limits the applicability of their work. Their analysis also does not cover many features of Go which results in crashes in the analysis, such as phi instructions and uninitialised channels.\nUsing a form of regular expressions with a fork construct, the work of [40] captures thread spawning in synchronous Go programs. Their analysis is extremely limited: it does not support asynchrony, closing channels nor selective communication with non-trivial case bodies. Moreover, their work uses the guru tool to manually obtain aliasing information in order to identify channels, and assumes that all functions can be inlined. As a result, their tool fails to analyse programs that cannot be trivially inlined — e.g. programs with aliased channel or repeated usages of the same function — ruling out most useful programs.\nOur previous work [30] infers behavioural types from Go code which are checked for liveness and safety properties using a technique akin to bounded symbolic execution. The GoInfer/Gong tool explicitly executes the type LTS which has scalability issues with large state spaces (see § 6) and is specialised for liveness and channel safety, whereas our tool can check for a much wider range of properties of interest (in general we can verify any property that can be represented as a µ-calculus formula). The type inference of [30] (which was not formalised until this work) did not have full support for closures nor general sequencing, needed to accurately represent most imperative programming patterns. Behavioural types. There is a vast body of work on behavioural types for concurrency (see [1, 24] for general surveys). The main contrast between our work and most of those in [1, 24] is that we use behavioural types as a component in a larger analysis that can automatically check for a range of safety and liveness properties, instead of focusing solely on forms of deadlock-freedom. The work [7] proposes a framework combining a behavioural type analysis with model checking. Their work uses the π -calculus as a source language and extracts CCS-like behavioural types based on [25], which can then be checked for properties written as an LTL formula. The main limitation of their work is the requirement of explicit type annotations in processes. Moreover, it is not clear how to represent our notions of global and partial deadlock-freedom (as well as channel safety) as a general LTL formula. LTL formulas can use “always” and “eventually” modalities to describe reachable\nstates, but cannot mention specific communication actions which requires non-obvious encodings. Note that most previous works [7, 24] are developed in the context of process calculi and are not applicable to a general purpose language.\nConcluding remarks. We have presented a static verification framework for channel-based concurrency in Go which we have implemented in the Godel Checker tool. As shown in § 6, our inference procedure allows us to accurately cover a broader class of Go programs without the need for annotations or significant user input. By integrating our approach with a general purpose model checker, we are able to modularly verify arbitrary safety and liveness properties. Compared to other existing tools, our approach provides significantly better performance for larger programs, verifying more properties and with better outcomes in terms of both false alarms and, crucially, undetected liveness errors.\nGiven the general nature of our inference procedure, our framework is not necessarily limited to mCRL2, nor model checking techniques in general. For future work we plan to use other process calculi verification techniques such as [37], as well as other model checkers for concurrency such as [18]. Also, the general idea for our inference can in principle be applied to other concurrency-centric languages that rely on some form of SSA-like intermediate representation. We plan to apply our techniques to the Erlang language via the Core Erlang [6] intermediate representation. We also plan to address the OpenCL 2.0 heterogeneous programming framework [20] which provides pipe objects (akin to Go channels) that are used for inter-kernel communications and are prone to deadlocks.'}, {'heading': 'ACKNOWLEDGMENTS', 'text': 'The work is partially supported by the EPSRC (grants EP/K034413/1, EP/K011715/1, EP/L00058X/1, EP/N027833/1, and EP/N028201/1)'}]
